(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{321:function(t,s,a){"use strict";a.r(s);var n=a(14),e=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[t._v("操作系统")]),t._v(" "),s("h1",{attrs:{id:"进程和线程区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#进程和线程区别"}},[t._v("#")]),t._v(" 进程和线程区别？")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th"),t._v(" "),s("th",[t._v("进程")]),t._v(" "),s("th",[t._v("线程")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("概念")]),t._v(" "),s("td",[t._v("运行时的程序")]),t._v(" "),s("td",[t._v("是进程的子任务")])]),t._v(" "),s("tr",[s("td",[t._v("从属关系")]),t._v(" "),s("td",[t._v("一个进程可以有多个线程")]),t._v(" "),s("td",[t._v("一个线程只属于一个进程")])]),t._v(" "),s("tr",[s("td",[t._v("调度粒度")]),t._v(" "),s("td",[t._v("是操作系统调度的最小单位")]),t._v(" "),s("td",[t._v("是CPU调度的最小单位")])]),t._v(" "),s("tr",[s("td",[t._v("内存")]),t._v(" "),s("td",[t._v("有独立内存单元，进程之间互不影响")]),t._v(" "),s("td",[t._v("多个线程共享所在进程的内存，线程也有自己的内存空间")])]),t._v(" "),s("tr",[s("td",[t._v("切换开销")]),t._v(" "),s("td",[t._v("大")]),t._v(" "),s("td",[t._v("小")])]),t._v(" "),s("tr",[s("td",[t._v("通信")]),t._v(" "),s("td",[t._v("共享内存、管道、信号量、套接字socket")]),t._v(" "),s("td",[t._v("1. 共享内存（临界区）; 2. 事件（信号），如java的wait() notify()；3. 互斥量，如Synchronized、Lock")])])])]),t._v(" "),s("h1",{attrs:{id:"父进程和子进程的关系"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#父进程和子进程的关系"}},[t._v("#")]),t._v(" 父进程和子进程的关系")]),t._v(" "),s("p",[t._v("fork()会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，Linux中引入了写时复制（COW）技术，也就是只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。在fork之后exec之前两个进程用的是相同的物理空间（内存区），子进程的代码段、数据段、堆栈都是指向父进程的物理空间，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间，如果不是因为exec，内核会给子进程的数据段、堆栈段分配相应的物理空间（至此两者有各自的进程空间，互不影响），而代码段继续共享父进程的物理空间（两者的代码完全相同）。而如果是因为exec，由于两者执行的代码不同，子进程的代码段也会分配单独的物理空间。")]),t._v(" "),s("h1",{attrs:{id:"io模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#io模型"}},[t._v("#")]),t._v(" IO模型")]),t._v(" "),s("p",[t._v("一个输入操作通常包括两个阶段：")]),t._v(" "),s("ul",[s("li",[t._v("等待数据准备好")]),t._v(" "),s("li",[t._v("从内核向进程复制数据")])]),t._v(" "),s("p",[t._v("对于一个套接字上的输入操作，第一步通常涉及等待数据从网络上到达本系统，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。")]),t._v(" "),s("p",[t._v("Unix 有五种 I/O 模型：")]),t._v(" "),s("ul",[s("li",[t._v("阻塞式 I/O（BIO，Blocking I/O）")]),t._v(" "),s("li",[t._v("非阻塞式 I/O（NIO，Non-blocking I/O），jdk1.4："),s("code",[t._v("java.nio")]),t._v("包。")]),t._v(" "),s("li",[t._v("I/O 复用")]),t._v(" "),s("li",[t._v("信号驱动式 I/O（SIGIO）")]),t._v(" "),s("li",[t._v("异步 I/O（AIO，Asynchronous I/O），jdk1.7："),s("code",[t._v("java.nio.channels.AsynchronousSocketChannel")]),t._v("等")])]),t._v(" "),s("blockquote",[s("p",[s("strong",[t._v("阻塞/非阻塞")]),t._v("关注的是程序在等待调用结果（消息，返回值）时的状态：")]),t._v(" "),s("ul",[s("li",[t._v("阻塞：调用结果返回之前，当前线程被挂起，直到结果返回才继续执行。")]),t._v(" "),s("li",[t._v("非阻塞：无论调用结果是否返回，都不影响当前线程继续执行。")])]),t._v(" "),s("p",[s("strong",[t._v("同步/异步")]),t._v("关注的是消息通信机制：")]),t._v(" "),s("ul",[s("li",[t._v("同步：方法A调用方法B，没得到B的结果之前， A不返回，一直等待B的结果到来A才返回。")]),t._v(" "),s("li",[t._v("异步：方法A调用方法B之后，就直接返回了，不需要等待B的结果（B有结果后回调通知A）。")])])]),t._v(" "),s("p",[t._v("举个例子，中午吃饭：")]),t._v(" "),s("ul",[s("li",[t._v("自选餐线，我们点餐的时候都得在队伍里排队等待，必须等待前面的同学打好菜才到我们，这就是同步阻塞模型BIO。")]),t._v(" "),s("li",[t._v("煮面餐线，会给我们发个号牌，不需排队原地等待，可以做其他事情，面煮好之后凭号来拿，这就是同步非阻塞NIO。")]),t._v(" "),s("li",[t._v("包厢模式，我们只要点好菜，坐在包厢可以自己玩，等到饭做好，服务员亲自送，无需自己取，这就是信号驱动SIGIO。")]),t._v(" "),s("li",[t._v("包厢模式，点菜之后，等着服务员"),s("strong",[t._v("直接塞肚子里")]),t._v("，这就是异步非阻塞模型AIO。")])]),t._v(" "),s("h2",{attrs:{id:"阻塞式-io"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#阻塞式-io"}},[t._v("#")]),t._v(" 阻塞式 IO")]),t._v(" "),s("p",[t._v("应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。")]),t._v(" "),s("p",[t._v("应该注意到，在阻塞的过程中，其它应用进程还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其它应用进程还可以执行，所以不消耗 CPU 时间，这种模型的 CPU 利用率会比较高。")]),t._v(" "),s("p",[t._v("下图中，recvfrom() 用于接收 Socket 传来的数据，并复制到应用进程的缓冲区 buf 中。这里把 recvfrom() 当成"),s("strong",[t._v("系统调用")]),t._v("。")]),t._v(" "),s("div",{staticClass:"language-c line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ssize_t")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("recvfrom")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" sockfd"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("buf"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("size_t")]),t._v(" len"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" flags"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("sockaddr")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("src_addr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("socklen_t")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("addrlen"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("img",{attrs:{src:"images/操作系统/1492928416812_4.png",alt:"img"}}),t._v(" "),s("h2",{attrs:{id:"非阻塞式-io-nio"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#非阻塞式-io-nio"}},[t._v("#")]),t._v(" 非阻塞式 IO（NIO）")]),t._v(" "),s("p",[t._v("应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询（polling）。")]),t._v(" "),s("p",[t._v("由于 CPU 要处理更多的系统调用，因此这种模型的 CPU 利用率比较低。")]),t._v(" "),s("img",{attrs:{src:"images/操作系统/1492929000361_5.png",alt:"img"}}),t._v(" "),s("h2",{attrs:{id:"i-o-复用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#i-o-复用"}},[t._v("#")]),t._v(" I/O 复用")]),t._v(" "),s("p",[t._v("使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中。")]),t._v(" "),s("p",[t._v("它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即"),s("strong",[t._v("事件驱动 I/O")]),t._v("。")]),t._v(" "),s("p",[t._v("如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统"),s("strong",[t._v("开销更小")]),t._v("。")]),t._v(" "),s("img",{attrs:{src:"images/操作系统/1492929444818_6.png",alt:"img"}}),t._v(" "),s("h2",{attrs:{id:"信号驱动-i-o"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#信号驱动-i-o"}},[t._v("#")]),t._v(" 信号驱动 I/O")]),t._v(" "),s("p",[t._v("应用进程使用 "),s("strong",[t._v("sigaction")]),t._v(" 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。")]),t._v(" "),s("p",[t._v("相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。")]),t._v(" "),s("img",{attrs:{src:"images/操作系统/1492929553651_7.png",alt:"img"}}),t._v(" "),s("h2",{attrs:{id:"异步-i-o"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#异步-i-o"}},[t._v("#")]),t._v(" 异步 I/O")]),t._v(" "),s("p",[t._v("应用进程执行 "),s("strong",[t._v("aio_read")]),t._v(" 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。")]),t._v(" "),s("p",[t._v("异步 I/O 与信号驱动 I/O 的区别：异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。")]),t._v(" "),s("img",{attrs:{src:"images/操作系统/1492930243286_8.png",alt:"img"}}),t._v(" "),s("h2",{attrs:{id:"五大-i-o-模型比较"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#五大-i-o-模型比较"}},[t._v("#")]),t._v(" 五大 I/O 模型比较")]),t._v(" "),s("ul",[s("li",[t._v("同步 I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段（第二阶段），应用进程会阻塞。包括阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O")]),t._v(" "),s("li",[t._v("异步 I/O：第二阶段应用进程不会阻塞。")])]),t._v(" "),s("p",[t._v("在第一阶段不会阻塞的：非阻塞式 I/O 、信号驱动 I/O 和异步 I/O 。")]),t._v(" "),s("p",[t._v("全程无阻塞的：异步IO。")]),t._v(" "),s("img",{attrs:{src:"images/操作系统/1492928105791_3.png",alt:"img"}}),t._v(" "),s("h3",{attrs:{id:"阻塞式io到非阻塞式io的演进"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#阻塞式io到非阻塞式io的演进"}},[t._v("#")]),t._v(" 阻塞式IO到非阻塞式IO的演进")]),t._v(" "),s("p",[t._v("服务端为了处理客户端的连接和请求的数据，写了如下伪代码。")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[t._v("listenfd "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("socket")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("   "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 打开一个网络通信端口（fd）*")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("bind")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("listenfd"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 绑定")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("listen")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("listenfd"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("      "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 监听")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    connfd "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("accept")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("listenfd"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 阻塞建立连接")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" n "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("read")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("connfd"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" buf"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 阻塞读数据")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("doSomeThing")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("buf"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 利用读到的数据做些什么")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("close")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("connfd"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("     "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 关闭连接，循环等待下一个连接")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br")])]),s("blockquote",[s("p",[t._v("*注："),s("strong",[t._v("文件描述符")]),t._v("（file descriptor，后文简称"),s("strong",[t._v("fd")]),t._v("）是一个索引值，指向一个文件记录表，该表记录内核为每一个进程维护的文件信息。")]),t._v(" "),s("p",[s("strong",[t._v("Linux中，一切皆文件")]),t._v("。因此一个socket（即tcp连接）也是一个文件，对应一个fd。")])]),t._v(" "),s("p",[t._v("这段代码与客户端的交互流程：")]),t._v(" "),s("img",{staticStyle:{zoom:"67%"},attrs:{src:"images/操作系统/阻塞io.gif",alt:"未命名图片"}}),t._v(" "),s("p",[t._v("可以看到，服务端的线程阻塞在了两个地方，一个是 accept 函数，一个是 read 函数。")]),t._v(" "),s("p",[t._v("如果再把 read 函数的细节展开，我们会发现其阻塞在"),s("strong",[t._v("网卡--内核缓冲区")]),t._v("、"),s("strong",[t._v("内核缓冲区--用户缓冲区buf")]),t._v(" 两个阶段")]),t._v(" "),s("img",{staticStyle:{zoom:"67%"},attrs:{src:"images/操作系统/read.png",alt:"图片"}}),t._v(" "),s("p",[t._v("所以，如果这个连接的客户端一直不发数据，那么服务端线程将会一直阻塞在 read 函数上不返回，也无法接受其他客户端连接。")]),t._v(" "),s("p",[t._v("为了解决上面的问题，其关键在于改造这个 read 函数。")]),t._v(" "),s("p",[t._v("一种办法是每次都创建一个新的进程或线程，去调用 read 函数，并做业务处理。这样，当给一个客户端建立好连接后，就可以立刻等待新的客户端连接，而不用阻塞在原客户端的 read 请求上：")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    connfd "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("accept")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("listenfd"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 阻塞建立连接")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("pthread_create")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("doWork"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 创建一个新的线程")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("doWork")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" n "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("read")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("connfd"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" buf"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 阻塞读数据")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("doSomeThing")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("buf"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 利用读到的数据做些什么")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("close")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("connfd"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("     "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 关闭连接，循环等待下一个连接")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br")])]),s("p",[t._v("这样本质上并不是非阻塞IO，只是开多线程而已，线程各自调用read还是阻塞的。而且线程太多会耗尽服务器资源。")]),t._v(" "),s("p",[t._v("真正的非阻塞IO是"),s("strong",[t._v("操作系统层面提供非阻塞read函数")]),t._v("。该read函数要在没有数据到达时（拷贝到了内核缓冲区），立刻返回一个错误值（-1），而不是阻塞地等待。")]),t._v(" "),s("p",[t._v("操作系统提供了这样的功能，只需要在调用 read 前，将fd设置为非阻塞即可：")]),t._v(" "),s("div",{staticClass:"language-c line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("fcntl")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("connfd"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" F_SETFL"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" O_NONBLOCK"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 设置非阻塞")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" n "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("read")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("connfd"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" buffer"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" SUCCESS"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br")])]),s("p",[t._v("非阻塞的 read，指的是在数据到达前（即数据还未到达网卡，或者到达网卡但还没有拷贝到内核缓冲区之前）这个阶段是非阻塞的。")]),t._v(" "),s("p",[t._v("当数据已到达内核缓冲区，此时调用 read 函数仍然是阻塞的，需要等待数据从内核缓冲区拷贝到用户缓冲区，才能返回。")]),t._v(" "),s("p",[t._v("整体流程：")]),t._v(" "),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"images/操作系统/640-1694017231081-6.png",alt:"图片"}}),t._v(" "),s("h1",{attrs:{id:"io多路复用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#io多路复用"}},[t._v("#")]),t._v(" IO多路复用")]),t._v(" "),s("blockquote",[s("p",[t._v("I/O multiplexing，翻译成IO多路复用有歧义，其实并不是多路IO复用一个物理链路，而是："),s("strong",[t._v("多个IO复用一次系统调用")]),t._v("，通过记录跟踪每个I/O流(sock)的状态，由单个线程来同时管理多个I/O流 。")]),t._v(" "),s("p",[t._v("IO多路复用是相对于阻塞IO而言的，单个线程调用操作系统的阻塞IO就会挂起，无法处理多个IO（fd）")])]),t._v(" "),s("p",[t._v("select, poll, 和 epoll 都是 Linux 中常见的 I/O 多路复用技术，它们可以用于同时监听多个"),s("strong",[t._v("文件描述符")]),t._v("（file descriptor，后文简称fd），当任意一个fd"),s("strong",[t._v("就绪")]),t._v("时，就能够非阻塞的读写数据。")]),t._v(" "),s("ul",[s("li",[t._v("select 是最原始的 I/O 多路复用技术，它的缺点是最多只能监听 1024 个文件描述符。")]),t._v(" "),s("li",[t._v("poll 在 select 的基础上，取消了监听文件描述符个数的限制，但是复杂度增加，并且线程不安全。")]),t._v(" "),s("li",[t._v("epoll 在 poll 的基础上进一步优化了复杂度，并且"),s("strong",[t._v("线程安全")]),t._v("。")])]),t._v(" "),s("h2",{attrs:{id:"三者比较"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三者比较"}},[t._v("#")]),t._v(" 三者比较")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th"),t._v(" "),s("th",[t._v("select")]),t._v(" "),s("th",[t._v("poll")]),t._v(" "),s("th",[t._v("epoll")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("fd长度（个数）")]),t._v(" "),s("td",[t._v("1024")]),t._v(" "),s("td",[t._v("无限制*")]),t._v(" "),s("td",[t._v("无限制*")])]),t._v(" "),s("tr",[s("td",[t._v("遍历所有fd")]),t._v(" "),s("td",[t._v("是")]),t._v(" "),s("td",[t._v("是")]),t._v(" "),s("td",[t._v("否")])]),t._v(" "),s("tr",[s("td",[t._v("把fd从用户态copy到内核态")]),t._v(" "),s("td",[t._v("是")]),t._v(" "),s("td",[t._v("是")]),t._v(" "),s("td",[t._v("否")])])])]),t._v(" "),s("p",[t._v("*注：上限是系统可以打开的最大文件数，远大于1024，具体可以用命令"),s("code",[t._v("cat /proc/sys/fs/file-max")]),t._v("查看。在1GB内存的机器上，大于10万。")]),t._v(" "),s("h2",{attrs:{id:"select"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#select"}},[t._v("#")]),t._v(" select")]),t._v(" "),s("blockquote",[s("p",[t._v("接前面 "),s("a",{attrs:{href:"####%E9%98%BB%E5%A1%9E%E5%BC%8FIO%E5%88%B0%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%8FIO%E7%9A%84%E6%BC%94%E8%BF%9B"}},[t._v("阻塞式IO到非阻塞式IO的演进")]),t._v("  的思路，可以每 accept 一个客户端连接后，将这个文件描述符（connfd）放到一个数组里。然后起一个新的线程一直循环这个数组，调用每一个元素的非阻塞 read 方法，这样就能用"),s("strong",[t._v("一个线程处理多个客户端连接")]),t._v("。")]),t._v(" "),s("div",{staticClass:"language-c line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[t._v("fdlist"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("connfd"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("fd "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),t._v(" fdlist"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("read")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("fd"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("doSomeThing")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br")])]),s("p",[t._v("但每次遍历遇到 read 返回 -1 时仍然是一次浪费资源的系统调用。在 while 循环里做系统调用是不划算的，每次调用都有开销，合理的做法是一次系统调用，在调用中while循环。")]),t._v(" "),s("p",[t._v("这就引出了select。")])]),t._v(" "),s("p",[t._v("select是操作系统提供的系统调用函数，传入一个"),s("strong",[t._v("fd数组")]),t._v("发给操作系统， 让操作系统去遍历，确定哪个fd可以读写（顾名思义，select 【选择】就绪的fd）。方法定义如下，可以监听read、write、except（异常）类型的fd：")]),t._v(" "),s("div",{staticClass:"language-c line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 返回>0为就绪的fd数；返回-1为出错；返回0为超时")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("select")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" nfds"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// nfds:监控的文件描述符集里最大文件描述符加1")]),t._v("\n    fd_set "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("readfds"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// readfds：监控有读数据到达文件描述符集合，指针")]),t._v("\n    fd_set "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("writefds"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// writefds：监控写数据到达文件描述符集合，指针")]),t._v("\n    fd_set "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("exceptfds"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// exceptfds：监控异常发生达文件描述符集合, 指针")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("timeval")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("timeout"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// timeout：定时阻塞监控时间，3种情况：1.NULL，永远等下去 2.设置timeval，等待固定时间                                                                // 3.设置timeval里时间均为0，检查描述字后立即返回，轮询")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br")])]),s("p",[t._v("服务端代码示例：")]),t._v(" "),s("p",[t._v("一个线程不断接受客户端连接，并把 socket 文件描述符放到一个 list 里。")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    connfd "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("accept")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("listenfd"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("fcntl")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("connfd"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("F_SETFL")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("O_NONBLOCK")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    fdlist"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("connfd"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br")])]),s("p",[t._v("另一个线程不再自己遍历，而是调用 select，将这个fd 数组交给操作系统去遍历。")]),t._v(" "),s("p",[t._v("不过，当 select 函数返回后，用户依然需要遍历刚刚提交给操作系统的 list，但是"),s("strong",[t._v("少了很多无效的系统调用")])]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    nready "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("select")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("list"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 传入一个fd list，返回已就绪fd的个数")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("fd "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),t._v(" fdlist"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 用户层依然要遍历")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 只读已就绪的fd")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("fd "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("read")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("fd"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" buf"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 总共只有 nready 个已就绪fd，不用过多遍历")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),t._v("nready "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("break")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br")])]),s("p",[t._v("总结：")]),t._v(" "),s("ol",[s("li",[t._v("select 调用需要传入 fd 数组，需要拷贝一份到内核，高并发场景下这样的拷贝消耗的资源是惊人的。（可优化为不复制）")]),t._v(" "),s("li",[t._v("select 在内核层仍然是通过遍历的方式检查fd的就绪状态，是个同步的过程，也是"),s("strong",[t._v("阻塞")]),t._v("的，只不过无系统调用切换上下文的开销。（内核层可优化为异步事件通知）")]),t._v(" "),s("li",[t._v("select 仅仅返回可读文件描述符的个数，具体哪个可读还是要用户自己遍历。（可优化为只返回给用户就绪的文件描述符，无需用户做无效的遍历）")])]),t._v(" "),s("p",[t._v("select 的流程图：")]),t._v(" "),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"images/操作系统/640-1694014902940-3.png",alt:"图片"}}),t._v(" "),s("h2",{attrs:{id:"poll"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#poll"}},[t._v("#")]),t._v(" poll")]),t._v(" "),s("p",[t._v("也是操作系统提供的函数，用法是调用poll返回后，轮询fd列表获取就绪的fd。")]),t._v(" "),s("div",{staticClass:"language-c line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("poll")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("pollfd")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("fds"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" nfds_tnfds"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" timeout"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("pollfd")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    intfd"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/*文件描述符*/")]),t._v("\n    shortevents"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/*监控的事件*/")]),t._v("\n    shortrevents"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/*监控事件中满足条件返回的事件*/")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br")])]),s("p",[s("strong",[t._v("select 和 poll 的比较")])]),t._v(" "),s("ul",[s("li",[t._v("poll对select的改进：取消了监听"),s("strong",[t._v("1024个fd")]),t._v("的限制（poll的fds基于链表，select的fd列表是数组）。")]),t._v(" "),s("li",[t._v("select 会"),s("strong",[t._v("修改描述符")]),t._v("，而 poll 不会；")]),t._v(" "),s("li",[t._v("poll 提供了更多的事件类型，并且对fd的重复利用上比 select 高。")]),t._v(" "),s("li",[t._v("线程不安全：如果一个线程对某个fd调用了 select 或者 poll，另一个线程关闭了该fd，会导致调用结果不确定。")]),t._v(" "),s("li",[t._v("速度：都很慢，因为拷贝fd还是要在内核态和用户态之间切换。")]),t._v(" "),s("li",[t._v("可移植性：几乎所有的系统都支持 select，但是只有比较新的系统支持 poll。")])]),t._v(" "),s("h2",{attrs:{id:"epoll"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#epoll"}},[t._v("#")]),t._v(" epoll")]),t._v(" "),s("p",[t._v("针对上面select总结的三点进行了改进：")]),t._v(" "),s("ol",[s("li",[t._v("拷贝一份 fd 集合到内核（用"),s("strong",[t._v("红黑树")]),t._v("存储），无需用户每次都重新传入，只需告诉内核修改的部分即可。")]),t._v(" "),s("li",[t._v("内核不再通过轮询的方式找到就绪的 fd ，而是通过"),s("strong",[t._v("异步 IO 事件")]),t._v("唤醒，也避免 fd 再从内核拷贝到用户的开销。")]),t._v(" "),s("li",[t._v("内核仅会将有 IO 事件的 fd 返回给用户，用户也无需遍历整个 fd 集合。")])]),t._v(" "),s("p",[t._v("使用示例：")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("创建一个 epoll 句柄，size告诉内核监听的fd数量：")]),t._v(" "),s("div",{staticClass:"language-c line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("epoll_create")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" size"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])])]),t._v(" "),s("li",[s("p",[t._v("向内核注册新的fd或改变某个fd的状态，以此监控fd。该方法将传入fd拷贝到内核，而不是在epoll_wait方法中重复拷贝，保证epoll只拷贝一次。所有fd在内核中用"),s("strong",[t._v("红黑树")]),t._v("维护。通过异步回调将就绪的fd放入链表，进程调用 "),s("code",[t._v("epoll_wait()")]),t._v(" 便可以得到事件完成的fd。")]),t._v(" "),s("div",{staticClass:"language-c line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("epoll_ctl")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" epfd"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" op"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" fd"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("epoll_event")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("event"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])])]),t._v(" "),s("li",[s("p",[t._v("类似于 select ，调用"),s("code",[t._v("epoll_wait")]),t._v("返回就绪状态的fd，若有则直接使用，而不像poll和select需要遍历")]),t._v(" "),s("div",{staticClass:"language-c line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("epoll_wait")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" epfd"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("epoll_event")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("events"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" max events"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" timeout"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])])])]),t._v(" "),s("p",[t._v("总之，epoll 只需要将fd从进程缓冲区向内核缓冲区拷贝一次，并且进程不需要通过轮询来获得就绪的fd。")]),t._v(" "),s("p",[t._v("流程图：")]),t._v(" "),s("p",[s("img",{attrs:{src:"images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/v2-8a58e70c01e31c15d6f58f9d68b59906_720w.png",alt:"img"}})]),t._v(" "),s("ul",[s("li",[t._v("epoll 仅适用于 Linux。")]),t._v(" "),s("li",[t._v("epoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也不会产生像 select 和 poll 的不确定情况。")])]),t._v(" "),s("h2",{attrs:{id:"q-多路复用比阻塞io快的原因"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#q-多路复用比阻塞io快的原因"}},[t._v("#")]),t._v(" Q：多路复用比阻塞IO快的原因？")]),t._v(" "),s("p",[t._v("错误：用一个线程就可以监控多个文件描述符。（这样的效果，完全可以由用户态去遍历文件描述符并调用其非阻塞的 read 函数实现）")]),t._v(" "),s("p",[t._v("正确：操作系统提供了这样的系统调用，使得原来的 while 循环里多次系统调用，变成了一次系统调用 + 内核层 while 循环遍历这些文件描述符。（就好比我们平时写业务代码，把原来 while 循环里调 http 接口进行批量，改成了让对方提供一个批量添加的 http 接口，然后我们一次 rpc 请求就完成了批量添加。）")]),t._v(" "),s("h2",{attrs:{id:"q-epoll的两种模式是"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#q-epoll的两种模式是"}},[t._v("#")]),t._v(" Q：epoll的两种模式是？")]),t._v(" "),s("p",[t._v("我们知道epoll是通过epoll_wait来获取就绪的fd，那么如果就绪的fd一直没有被消费，该如何处理呢？这就有了两种模式。LT（level trigger）和ET（edge trigger）：")]),t._v(" "),s("ul",[s("li",[t._v("LT模式（"),s("strong",[t._v("默认模式")]),t._v("）：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。支持阻塞和非阻塞。")]),t._v(" "),s("li",[t._v("ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须"),s("strong",[t._v("立即处理")]),t._v("该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。只支持非阻塞。")])]),t._v(" "),s("p",[t._v("因为ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞socket，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。")]),t._v(" "),s("h2",{attrs:{id:"应用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#应用场景"}},[t._v("#")]),t._v(" 应用场景")]),t._v(" "),s("p",[t._v("很容易产生一种错觉认为只要用 epoll 就可以了，select 和 poll 都已经过时了，其实它们都有各自的使用场景。")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("select 应用场景\nselect 的 timeout 参数精度为微秒，而 poll 和 epoll 为毫秒，因此 select 更加适用于"),s("strong",[t._v("实时性")]),t._v("要求比较高的场景，比如核反应堆的控制。select 可移植性更好，几乎被所有主流平台所支持。")])]),t._v(" "),s("li",[s("p",[t._v("poll 应用场景\npoll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。")])]),t._v(" "),s("li",[s("p",[t._v("epoll 应用场景\n只需要运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接。")]),t._v(" "),s("p",[t._v("需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。")]),t._v(" "),s("p",[t._v("需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll。因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且 epoll 的描述符存储在内核，不容易调试。")])])]),t._v(" "),s("h1",{attrs:{id:"swap交换分区"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#swap交换分区"}},[t._v("#")]),t._v(" Swap交换分区")]),t._v(" "),s("p",[t._v("Linux中的一个区域，类似于Windows的虚拟内存，当内存不足时，把一部分硬盘空间虚拟成内存，解决内存容量不足的问题。")]),t._v(" "),s("p",[t._v("合理取值一般是"),s("strong",[t._v("内存的2倍")])]),t._v(" "),s("h1",{attrs:{id:"程序编译"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#程序编译"}},[t._v("#")]),t._v(" 程序编译")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("程序功能的实现通常可以分为两个阶段：")])]),t._v(" "),s("li",[s("p",[t._v("静态处理阶段（static），在程序本身开始执行前的处理。通常包括：")])]),t._v(" "),s("li",[s("ul",[s("li",[t._v("翻译阶段（编译）：对源程序做各种检查（语法检查，类型检查等）和变换，将其转变为某种适宜动态执行的形式")]),t._v(" "),s("li",[t._v("连接阶段（可能）：构造出可动态运行的程序形式")]),t._v(" "),s("li",[t._v("装载阶段（可能）：把可运行程序装入运行环境，必要的处理")])])]),t._v(" "),s("li",[s("p",[t._v("动态执行阶段（run-time），指程序的实际运行期间")])]),t._v(" "),s("li",[s("p",[t._v("例：若变量x 的（绝对或相对）位置可静态确定，运行中就可以直接访问。若不能静态确定，运行中每次访问都要查表，效率就比较低")])]),t._v(" "),s("li",[s("p",[t._v("语言的“编译实现”：在静态阶段完成尽可能多的处理工作，对源程序做深入的分析和变换，生成的目标形式通常与源程序差异巨大")])])]),t._v(" "),s("h1",{attrs:{id:"amdahl定律"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#amdahl定律"}},[t._v("#")]),t._v(" Amdahl定律")]),t._v(" "),s("p",[t._v("加快某部件执行速度所获得的系统性能加速比，受限于该部件在系统中所占的比例。")]),t._v(" "),s("p",[t._v("Amdahl定律既可以用来确定系统中对性能限制最大的部件，也可以用来计算通过改进某些部件所获得的系统性能的提高。")]),t._v(" "),s("ul",[s("li",[t._v("Amdahl定律：加快某部件执行速度所获得的系统性能加速比，受限于该部件在系统中所占的比例。")]),t._v(" "),s("li",[t._v("Amdahl定律既可以用来确定系统中对性能限制最大的部件，也可以用来计算通过改进某些部件所获得的系统性能的提高。")])]),t._v(" "),s("img",{staticStyle:{zoom:"50%"},attrs:{src:"images/操作系统/未命名图片.jpg",alt:"未命名图片"}}),t._v(" "),s("img",{staticStyle:{zoom:"33%"},attrs:{src:"images/操作系统/1png.jpg",alt:"1png"}})])}),[],!1,null,null,null);s.default=e.exports}}]);