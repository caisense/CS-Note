# 传输层-TCP

## TCP 首部格式

<img src="images/计算机网络/55dc4e84-573d-4c13-a765-52ed1dd251f9.png" alt="img" style="zoom:50%;" />

- **序号 seq** ：用于对**数据部分**字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。

  因为占32位，所以取值范围0~2^31-1。当序号到达最后一个时，下一个序号又回到0

- **确认号 ack** ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。

  取值范围也是0~2^31-1，到达最后一个回头

- **数据偏移** ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。

- **确认 ACK** ：当 ACK=1 时确认号字段ack有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1（除了FIN）。

- **同步 SYN** ：在**连接建立时**用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。

- **终止 FIN** ：用来**释放一个连接**，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。

- **窗口** ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。

## 三次握手（三报文握手）

<img src="images/计算机网络/e92d0ebc-7d46-413b-aec1-34a39602f787.png" alt="img" style="zoom:50%;" />

假设 A 为客户端，B 为服务器端。三次握手的报文**都不携带数据**。

- 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。

- A 向 B 发送连接请求报文，SYN=1，**ACK=0**（因为是**初始报文**，不需要对任何报文确认），选择一个初始的序号 x。

- B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1（因为A发来的报文不携带数据，所以期望收到下一个报文序号是x+1），同时也选择一个初始的序号 y。

- A 收到 B 的连接确认报文后，还要向 B 发出确认，ACK=1，确认号为 y+1，序号为 x+1。

  注意这是一个**普通报文**，可以携带数据。如果未携带数据则不消耗序号seq，即A发出的下一个报文seq仍为x+1。而前两个报文虽然不带数据，但都消耗一个序号。

- B 收到 A 的确认后，连接建立，双方都可以进行收发。

- 数据传送时，**ack=发送方的seq+发送方的len**。（具体见wireshark抓包一节）

  注意：带SYN、FIN的报文不同，ack=发送方的seq+发送方的len**+1**。

## 四次挥手（四报文挥手）

<img src="images/计算机网络/f87afe72-c2df-4c12-ac03-9b8d581a8af8.jpg" alt="img" style="zoom: 67%;" />

以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单（前两个报文：u为A上一个报文的序号+1，v为B的上一个报文序号+1。第三个报文：w为**半关闭状态**下B发送的上一个报文序号+1，u+1是对之前A发送释放连接报文的**重复确认**）。

并且不讨论 ACK（因为 ACK 在连接建立之后都为 1）。

- A 发送连接释放报文，FIN=1。
- B 收到之后发出确认，此时 TCP 属于**半关闭状态**，B 能向 A 发送数据但是 A 不能向 B 发送数据。
- 当 B 不再需要连接时，发送连接释放报文，FIN=1。
- A 收到后发出确认，进入 TIME-WAIT 状态，**等待 2 MSL**（最大报文存活时间）后释放连接。
- B 收到 A 的确认后**立刻**释放连接。

## Q：为什么三次握手不能简化为两次？

一句话：防止重复建立连接。

考虑情况：客户端发送的连接请求c1如果在网络中滞留，隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接c2。

但是这个滞留的连接请求c1最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器对连接c2请求的确认，因此就不会再次打开连接。

**通俗理解（全网独家！！！）**

客户端是主动方，只用两次握手就能建立**单向**连接了。但服务器是被动方，也需要一去一回两次握手建立**单向**连接，本质上总共需要四次握手才能建立双向连接。但服务器发送响应给客户端，和服务器发送建立连接的请求，这两次可以优化为一次，因此三次就足够。

## Q：为什么要四次挥手？

类似于《Q：为什么三次握手不能简化为两次？》的通俗理解，结束双向连接也需要双方分别结束单向连接，共四次。

第一次挥手后，服务器就进入 CLOSE-WAIT 状态，是为了让服务器端发送还未传送完毕的数据。

**为何不像三次握手那样将服务器的两次握手合并成一次？**

因为此时连接已建立，应该让服务器充分利用连接。

**TIME_WAIT**

客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。两个理由：

- 确保A最后一个确认报文能够到达B。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文（超时重传），导致A一直无法关闭。
- 为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。

## Q：2MSL如何得出？

**类似问题：如何保证A发出最后一个连接释放报文，B一定能关闭？**

考虑最坏情况：A发出最后一个连接释放报文，最多1MSL到达B，如果该报文丢失，则B发起超时重传（B发出FIN也会等2MSL），最多1MSL到达A，总共经历2MSL。如果2MSL后没收到B的报文，则说明B没有超时重传，确认B已经关闭，因此A可以放心关闭。

# 传输层-UDP

## UDP 首部格式

<img src="images/计算机网络/d4c3a4a1-0846-46ec-9cc3-eaddfca71254.jpg" alt="img" style="zoom:50%;" />

首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。

## Q：TCP和UDP不同？

|          | TCP                                                          | UDP                                                          |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 面向     | 字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块） | 报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部） |
| 连接     | 面向连接                                                     | 无连接                                                       |
| 交付     | 可靠交付                                                     | 尽最大可能交付                                               |
| 拥塞控制 | 有                                                           | 无                                                           |
|          | 全双工                                                       |                                                              |
|          | 点对点（一对一）                                             | 一对一、一对多、多对一、多对多                               |

## TCP可靠传输

TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。

一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下：
$$
RTTs = (1-a)*RTTs+a*RTT
$$
其中，0 ≤ a ＜ 1，RTTs 随着 a 的增加更容易受到 RTT 的影响。

超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下：
$$
RTO=RTTs+4*RTTd
$$
其中 RTTd 为偏差的加权平均值。

## TCP滑动窗口

窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。

发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。

接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。

![img](images/计算机网络/a3253deb-8d21-40a1-aae4-7d178e4aa319.jpg)

##  TCP 流量控制

流量控制是为了控制发送方发送速率，保证接收方来得及接收。

接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。

##  TCP 拥塞控制

如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。

<img src="images/计算机网络/51e2ed95-65b8-4ae9-8af3-65602d452a25.jpg" alt="img" style="zoom:50%;" />

TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。

发送方需要维护一个叫做**拥塞窗口**（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。

为了便于讨论，做如下假设：

- 接收方有足够大的接收缓存，因此不会发生流量控制；
- 虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。

![img](images/计算机网络/910f613f-514f-4534-87dd-9b4699d59d31.png)

### 1. 慢开始与拥塞避免

发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 ...

注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd >= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。

如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。

### 2. 快重传与快恢复

在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。

在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。

在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。

慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。

![img](images/计算机网络/f61b5419-c94a-4df1-8d4d-aed9ae8cc6d5.png)

# 应用层-HTTP

## HTTP头部

是HTTP报文的一部分

### 1.通用头

是客户端和服务器都可以使用的头部，可以在客户端、服务器和其他应用程序之间提供一些非常有用的通用功能

|    首部字段名     |                    说明                    |
| :---------------: | :----------------------------------------: |
|   Cache-Control   |               控制缓存的行为               |
|    Connection     | 控制不再转发给代理的首部字段、管理持久连接 |
|       Date        |             创建报文的日期时间             |
|      Pragma       |                  报文指令                  |
|      Trailer      |             报文末端的首部一览             |
| Transfer-Encoding |         指定报文主体的传输编码方式         |
|      Upgrade      |               升级为其他协议               |
|        Via        |            代理服务器的相关信息            |
|      Warning      |                  错误通知                  |

### 2.请求头

是请求报文特有的，它们为服务器提供了一些额外信息，比如客户端希望接收什么类型的数据

|     首部字段名      |                      说明                       |
| :-----------------: | :---------------------------------------------: |
|       Accept        |            用户代理可处理的媒体类型             |
|   Accept-Charset    |                  优先的字符集                   |
|   Accept-Encoding   |                 优先的内容编码                  |
|   Accept-Language   |             优先的语言（自然语言）              |
|    Authorization    |                  Web 认证信息                   |
|       Expect        |              期待服务器的特定行为               |
|        From         |               用户的电子邮箱地址                |
|        Host         |               请求资源所在服务器                |
|      If-Match       |              比较实体标记（ETag）               |
|  If-Modified-Since  |               比较资源的更新时间                |
|    If-None-Match    |        比较实体标记（与 If-Match 相反）         |
|      If-Range       |      资源未更新时发送实体 Byte 的范围请求       |
| If-Unmodified-Since | 比较资源的更新时间（与 If-Modified-Since 相反） |
|    Max-Forwards     |                 最大传输逐跳数                  |
| Proxy-Authorization |         代理服务器要求客户端的认证信息          |
|        Range        |               实体的字节范围请求                |
|       Referer       |            对请求中 URI 的原始获取方            |
|         TE          |                传输编码的优先级                 |
|     User-Agent      |              HTTP 客户端程序的信息              |

### 3.响应头

便于客户端提供信息，比如，客服端在与哪种类型的服务器进行交互

|     首部字段名     |             说明             |
| :----------------: | :--------------------------: |
|   Accept-Ranges    |     是否接受字节范围请求     |
|        Age         |     推算资源创建经过时间     |
|        ETag        |        资源的匹配信息        |
|      Location      |   令客户端重定向至指定 URI   |
| Proxy-Authenticate | 代理服务器对客户端的认证信息 |
|    Retry-After     |   对再次发起请求的时机要求   |
|       Server       |    HTTP 服务器的安装信息     |
|        Vary        |   代理服务器缓存的管理信息   |
|  WWW-Authenticate  |   服务器对客户端的认证信息   |

### 4.实体头

指的是用于应对实体主体部分的头部，比如，可以用实体头部来说明实体主体部分的数据类型

|    首部字段名    |          说明          |
| :--------------: | :--------------------: |
|      Allow       | 资源可支持的 HTTP 方法 |
| Content-Encoding | 实体主体适用的编码方式 |
| Content-Language |   实体主体的自然语言   |
|  Content-Length  |     实体主体的大小     |
| Content-Location |   替代对应资源的 URI   |
|   Content-MD5    |   实体主体的报文摘要   |
|  Content-Range   |   实体主体的位置范围   |
|   Content-Type   |   实体主体的媒体类型   |
|     Expires      | 实体主体过期的日期时间 |
|  Last-Modified   | 资源的最后修改日期时间 |

## 请求报文

客户端发送一个请求报文给服务器，服务器根据请求报文中的信息进行处理，并将处理结果放入响应报文中返回给客户端。

请求报文结构：

- 第一行是包含了请求方法、URL、协议版本；
- 接下来的多行都是请求首部 Header，每个首部都有一个首部名称，以及对应的值。
- 一个**空行**用来分隔首部和内容主体 Body
- 最后是请求的内容主体（13行

```text
GET http://www.example.com/ HTTP/1.1
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8
Cache-Control: max-age=0
Host: www.example.com
If-Modified-Since: Thu, 17 Oct 2019 07:18:26 GMT
If-None-Match: "3147526947+gzip"
Proxy-Connection: keep-alive
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 xxx

param1=1&param2=2
```

## 响应报文

服务器返回给客户端的报文

- 第一行包含协议版本、状态码以及描述，最常见的是 200 OK 表示请求成功了
- 接下来多行也是首部内容
- 一个**空行**分隔首部和内容主体
- 最后是响应的内容主体（18行

```text
HTTP/1.1 200 OK
Age: 529651
Cache-Control: max-age=604800
Connection: keep-alive
Content-Encoding: gzip
Content-Length: 648
Content-Type: text/html; charset=UTF-8
Date: Mon, 02 Nov 2020 17:53:39 GMT
Etag: "3147526947+ident+gzip"
Expires: Mon, 09 Nov 2020 17:53:39 GMT
Keep-Alive: timeout=4
Last-Modified: Thu, 17 Oct 2019 07:18:26 GMT
Proxy-Connection: keep-alive
Server: ECS (sjc/16DF)
Vary: Accept-Encoding
X-Cache: HIT

<!doctype html>
<html>
<head>
    <title>Example Domain</title>
	// 省略... 
</body>
</html>
```

## URL

HTTP 使用 URL（ **U** niform **R**esource **L**ocator，统一资源定位符）来定位资源，它是 URI（**U**niform **R**esource **I**dentifier，统一资源标识符）的子集，URL 在 URI 的基础上增加了定位能力。

URN（Uniform Resource Name，统一资源名称），也是URI的子集，它只是用来定义一个资源的名称，并不具备定位该资源的能力。例如 urn:isbn:0451450523 用来定义一个书籍名称，但是却没有表示怎么找到这本书。

![img](images/计算机网络/8441b2c4-dca7-4d6b-8efb-f22efccaf331.png)

## HTTP方法

HTTP/1.0 定义了三种：GET, POST 和 HEAD 

HTTP/1.1 增加了六种：OPTIONS, PUT, PATCH, DELETE, TRACE 和 CONNECT

| 方法                                   | 描述                                                         |
| :------------------------------------- | ------------------------------------------------------------ |
| GET                                    | 请求指定的页面信息，并返回具体内容，通常只用于读取数据。     |
| POST                                   | 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立或已有资源的更改。 |
| HEAD                                   | 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头，确认 URL 的有效性以及资源更新的日期时间等。 |
| =================HTTP1.1新增========== | ======================HTTP1.1新增=======================     |
| PUT                                    | 替换 URL 标识的资源（如文件等），没有的话就新增，**不带验证机制**。（不安全） |
| DELETE                                 | 请求服务器删除资源数据，同样不带验证机制。（不安全）         |
| PATCH                                  | 是对 PUT 方法的补充，用来对已知资源进行**局部更新**（PUT只能完全替换）。（不安全） |
| CONNECT                                | 将服务器作为**代理**，建立隧道让服务器代替用户进行访问。使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。 |
| OPTIONS                                | 查询指定的 URL 能够支持的 HTTP 请求方法。例如会返回 `Allow: GET, POST, HEAD, OPTIONS` 这样的内容。 |
| TRACE                                  | 回显服务器收到的请求数据，即服务器返回自己收到的数据，主要用于测试和诊断。（不安全，容易受到 XST 攻击） |

put示例：

```html
PUT /new.html HTTP/1.1
Host: example.com
Content-type: text/html
Content-length: 16

<p>New File</p>
```

patch示例：

```html
PATCH /file.txt HTTP/1.1
Host: www.example.com
Content-Type: application/example
If-Match: "e0023aa4e"
Content-Length: 100

[description of changes]
```

delete示例：

```html
DELETE /file.html HTTP/1.1
```

## HTTP状态码

服务器返回的 **响应报文** 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。

| 状态码 |            类别            |            含义            |
| :----: | :------------------------: | :------------------------: |
|  1XX   |   Informational（信息）    |     接收的请求正在处理     |
|  2XX   |      Success（成功）       |      请求正常处理完毕      |
|  3XX   |   Redirection（重定向）    | 需要进行附加操作以完成请求 |
|  4XX   | Client Error（客户端错误） |     服务器无法处理请求     |
|  5XX   | Server Error（服务器错误） |     服务器处理请求出错     |

### 1XX 信息

- **100 Continue** ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。

### 2XX 成功

- **200 OK**
- **204 No Content** ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。
- **206 Partial Content** ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。

### 3XX 重定向

指当浏览器请求一个URL时，服务器返回一个重定向指令，告诉浏览器地址已经变了，麻烦使用新的URL再重新发送新请求。

**过程**

如果浏览器发送`GET /hi`请求，Spring的`RedirectServlet`将处理此请求。由于`RedirectServlet`在内部又发送了重定向响应，因此，浏览器会收到如下响应：

```
HTTP/1.1 302 Found
Location: /hello
```

当浏览器收到302响应后，它会立刻根据`Location`的指示发送一个新的`GET /hello`请求。

```ascii
┌───────┐   GET /hi     ┌───────────────┐
│Browser│ ────────────> │RedirectServlet│
│       │ <──────────── │               │
└───────┘   302         └───────────────┘


┌───────┐  GET /hello   ┌───────────────┐
│Browser│ ────────────> │ HelloServlet  │
│       │ <──────────── │               │
└───────┘   200 <html>  └───────────────┘
```

观察Chrome浏览器的网络请求，可以看到两次HTTP请求，并且浏览器的地址栏路径自动更新为`/hello`：

<img src="images/计算机网络/image-20230104172235427.png" alt="image-20230104172235427" style="zoom: 67%;" />

**注意**：301和302区别：如果服务器发送301，浏览器会**缓存**`/hi`到`/hello`这个重定向的关联，下次请求`/hi`的时候，浏览器就直接发送`/hello`请求了。

- **301 Moved Permanently** ：永久性重定向
- **302 Found** ：临时性重定向
- **303 See Other** ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。
- 注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。
- **304 Not Modified** ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。
- **307 Temporary Redirect** ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。

### 4XX 客户端错误

- **400 Bad Request** ：请求报文中存在语法错误。
- **401 Unauthorized** ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。
- **403 Forbidden** ：请求被拒绝。
- **404 Not Found**：服务器上没有找到请求的资源

### 5XX 服务器错误

- **500 Internal Server Error** ：服务器正在执行请求时发生错误。
- **503 Service Unavailable** ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。

## 连接管理

<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/HTTP1_x_Connections.png" alt="img" style="zoom: 67%;" />****



**短连接与长连接**

当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问的 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。

长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。

- 从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 `Connection : close`；
- 在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 `Connection : Keep-Alive`。

**流水线**

默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。

流水线是在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟。

## Session

Session 是浏览器和服务器会话过程中，服务器会分配的一块储存空间 。

因为HTTP协议是一个无状态协议，即Web应用程序无法区分收到的两个HTTP请求是否是同一个浏览器发出的。为了跟踪用户状态，服务器可以向浏览器分配一个唯一ID，并以Cookie的形式发送到浏览器，浏览器在后续访问时总是附带此Cookie，这样，服务器就可以识别用户身份。

**Session机制**

指这种基于唯一ID识别用户身份的机制。每个用户第一次访问服务器后，会自动获得一个Session ID（即发送给浏览器的Cookie）。如果用户在一段时间内没有访问服务器，那么Session会自动失效，下次即使带着上次分配的Session ID访问，服务器也认为这是一个新用户，会分配新的Session ID。

### java操作

JavaEE的Servlet机制内建了对Session的支持。我们以登录为例，当一个用户登录成功后，我们就可以把这个用户的名字放入一个`HttpSession`对象，以便后续访问其他页面的时候，能直接从`HttpSession`取出用户名：

```java
@WebServlet(urlPatterns = "/signin")
public class SignInServlet extends HttpServlet {
    // 模拟一个数据库:
    private Map<String, String> users = Map.of("bob", "bob123", "alice", "alice123", "tom", "tomcat");

    // POST请求时处理用户登录:
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        String name = req.getParameter("username");
        String password = req.getParameter("password");
        String expectedPassword = users.get(name.toLowerCase());
        if (expectedPassword != null && expectedPassword.equals(password)) {
            // 判断用户登录成功后，立刻将用户名放入当前HttpSession中
            req.getSession().setAttribute("user", name);
            resp.sendRedirect("/");
        } else {
            resp.sendError(HttpServletResponse.SC_FORBIDDEN);
        }
    }
}
```

服务器识别Session的关键就是依靠一个名为`JSESSIONID`的Cookie。在Servlet中第一次调用`req.getSession()`时，Servlet容器自动创建一个Session ID，然后通过一个名为`JSESSIONID`的Cookie发送给浏览器：

![session](images/计算机网络/l.jpeg)

除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。

Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。

## Cookie

因为HTTP 协议是无状态的，HTTP/1.1 引入 Cookie 来保存状态信息，是服务器发送到**用户浏览器**并保存在**本地**的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。

Cookie是Session机制的一种实现方式（其他实现还有隐藏表单、URL末尾附加ID等，但不如Cookie常用）。实际上，Servlet提供的`HttpSession`本质上就是通过一个名为`JSESSIONID`的Cookie来跟踪用户会话的。除了这个名称外，其他名称的Cookie我们可以任意使用。

Cookie 曾一度用于客户端数据的存储，现已淘汰。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。



### 创建过程

服务器发送的响应报文中包含首部字段： Set-Cookie 。客户端得到响应报文后把 Cookie 内容保存到浏览器中。

```html
HTTP/1.0 200 OK
Content-type: text/html
Set-Cookie: yummy_cookie=choco
Set-Cookie: tasty_cookie=strawberry

[page content]
```

客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器。

```html
GET /sample_page.html HTTP/1.1
Host: www.example.org
Cookie: yummy_cookie=choco; tasty_cookie=strawberry
```

### 持久性 Cookie

- 会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。
- 持久性 Cookie：指定过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。

```html
Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;
```

### java操作

如果我们想要设置一个Cookie，例如，记录用户选择的语言，可以编写一个`LanguageServlet`：

```java
@WebServlet(urlPatterns = "/pref")
public class LanguageServlet extends HttpServlet {

    private static final Set<String> LANGUAGES = Set.of("en", "zh");

    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        String lang = req.getParameter("lang");
        if (LANGUAGES.contains(lang)) {
            // 创建一个新的Cookie:
            Cookie cookie = new Cookie("lang", lang);
            // 该Cookie生效的路径范围:
            cookie.setPath("/");
            // 该Cookie有效期:
            cookie.setMaxAge(8640000); // 8640000秒=100天
            // 将该Cookie添加到响应:
            resp.addCookie(cookie);
            // 如果访问的是https网页，还需要调用setSecure(true)，否则浏览器不会发送该Cookie。
        }
        resp.sendRedirect("/");
    }
}
```

读取Cookie主要依靠遍历`HttpServletRequest`附带的所有Cookie。

```java
private String parseLanguageFromCookie(HttpServletRequest req) {
    // 获取请求附带的所有Cookie:
    Cookie[] cookies = req.getCookies();
    // 如果获取到Cookie:
    if (cookies != null) {
        // 循环每个Cookie:
        for (Cookie cookie : cookies) {
            // 如果Cookie名称为lang:
            if (cookie.getName().equals("lang")) {
                // 返回Cookie的值:
                return cookie.getValue();
            }
        }
    }
    // 返回默认值:
    return "en";
}
```

### 浏览器禁用 Cookie

此时无法使用 Cookie 保存用户信息，只能用 Session。

此外，不能再将 Session ID 存放到 Cookie 中，而是使用 **URL 重写技术**，将 Session ID 作为 URL 的参数进行传递。

### 安全性问题

存储在浏览器中，容易被恶意查看

### 服务器集群问题

多台服务器集群使用反向代理作为网站入口：

```ascii
                                     ┌────────────┐
                                ┌───>│Web Server 1│
                                │    └────────────┘
┌───────┐     ┌─────────────┐   │    ┌────────────┐
│Browser│────>│Reverse Proxy│───┼───>│Web Server 2│
└───────┘     └─────────────┘   │    └────────────┘
                                │    ┌────────────┐
                                └───>│Web Server 3│
                                     └────────────┘
```

如果多台Web Server采用无状态集群，那么反向代理总是以轮询方式将请求依次转发给每台Web Server，这会造成一个用户在Web Server 1存储的Session信息，在Web Server 2和3上并不存在，即从Web Server 1登录后，如果后续请求被转发到Web Server 2或3，那么用户看到的仍然是未登录状态。

**解决**

- 方案一：在所有Web Server之间进行**Session复制**，但这样会严重消耗网络带宽，并且，每个Web Server的内存均存储所有用户的Session，内存使用率很低。
- 方案二：采用**粘滞会话**（Sticky Session）机制，即反向代理在转发请求的时候，总是根据JSESSIONID的值判断，相同的JSESSIONID总是转发到固定的Web Server，但这需要反向代理的支持。

无论采用何种方案，使用Session机制，会使得Web Server的集群很难扩展，因此，Session适用于中小型Web应用程序。**对于大型Web应用程序来说，通常需要避免使用Session机制**。

### **使用 Session 维护用户登录状态**

**Session存服务端redis，客户端只存Session ID（放Cookie）**

- 用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；
- 服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；
- 服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID（需要考虑安全性，不能让它被恶意攻击者轻易获取），客户端收到响应报文之后将该 Cookie 值存入浏览器中；
- 客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。

## Q：Cookie与Session比较？

|          | Cookie                                            | 客户端Session                                       | 服务端Session                               |
| -------- | ------------------------------------------------- | --------------------------------------------------- | ------------------------------------------- |
| 格式     | ASCII码字符串                                     | 字符串                                              | 任意类型（但本质上还是字符串）              |
| 大小     | 4KB                                               | 5MB（在浏览器中称sessionStorage）                   | 无上限                                      |
| 生命周期 | 过期时间 之前，一直有效（页面或浏览器关闭后失效） | 过期时间 之前，一直有效；（页面或浏览器关闭后失效） | 一直有效（服务器程序终止后失效）            |
| 存储位置 | 浏览器（客户端）                                  | 浏览器（客户端）                                    | 服务器上（文件、数据库或者内存，甚至Redis） |
| 安全性   | 差，易被恶意查看（解决：加密，在服务器解密）      |                                                     | 好，因为不存客户端。可以安全存放用户信息    |
| 用途     | 会话状态管理、个性化设置、浏览器行为跟踪          |                                                     | 同Cookie                                    |

## 缓存

### 优点

- 缓解服务器压力；
- 降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并且缓存服务器在地理位置上也有可能比源服务器来得近，例如浏览器缓存。

### 实现方法

- 让代理服务器进行缓存；
- 让客户端浏览器进行缓存。

### Cache-Control

HTTP/1.1 通过 Cache-Control 首部字段来控制缓存。

**1 禁止进行缓存**

no-store 指令规定不能对请求或响应的任何一部分进行缓存。

```html
Cache-Control: no-store
```

**2 强制确认缓存**

no-cache 指令规定缓存服务器需要先向源服务器验证缓存资源的有效性，只有当缓存资源有效时才能使用该缓存对客户端的请求进行响应。

```html
Cache-Control: no-cache
```

**3 私有缓存和公共缓存**

private 指令规定了将资源作为私有缓存，只能被单独用户使用，一般存储在用户浏览器中。

```html
Cache-Control: private
```

public 指令规定了将资源作为公共缓存，可以被多个用户使用，一般存储在代理服务器中。

```html
Cache-Control: public
```

**4 缓存过期机制**

max-age 指令出现在请求报文，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。

max-age 指令出现在响应报文，表示缓存资源在缓存服务器中保存的时间。

```html
Cache-Control: max-age=31536000
```

Expires 首部字段也可以用于告知缓存服务器该资源什么时候会过期。

```html
Expires: Wed, 04 Jul 2012 08:26:05 GMT
```

- 在 HTTP/1.1 中，会优先处理 max-age 指令；
- 在 HTTP/1.0 中，max-age 指令会被忽略掉。

### 内容协商

通过内容协商返回最合适的内容，例如根据浏览器的默认语言选择返回中文界面还是英文界面。

**类型**

**1.1 服务端驱动型**

客户端设置特定的 HTTP 首部字段，例如 Accept、Accept-Charset、Accept-Encoding、Accept-Language，服务器根据这些字段返回特定的资源。

它存在以下问题：

- 服务器很难知道客户端浏览器的全部信息；
- 客户端提供的信息相当冗长（HTTP/2 协议的首部压缩机制缓解了这个问题），并且存在隐私风险（HTTP 指纹识别技术）；
- 给定的资源需要返回不同的展现形式，共享缓存的效率会降低，而服务器端的实现会越来越复杂。

**1.2 代理驱动型**

服务器返回 300 Multiple Choices 或者 406 Not Acceptable，客户端从中选出最合适的那个资源。

**Vary**

```html
Vary: Accept-Language
```

在使用内容协商的情况下，只有当缓存服务器中的缓存满足内容协商条件时，才能使用该缓存，否则应该向源服务器请求该资源。

例如，一个客户端发送了一个包含 Accept-Language 首部字段的请求之后，源服务器返回的响应包含 `Vary: Accept-Language` 内容，缓存服务器对这个响应进行缓存之后，在客户端下一次访问同一个 URL 资源，并且 Accept-Language 与缓存中的对应的值相同时才会返回该缓存。

## 内容编码

浏览器发送 Accept-Encoding 首部，其中包含有它所支持的压缩算法，以及各自的优先级。服务器则从中选择一种，使用该算法对响应的消息主体进行压缩，并且发送 Content-Encoding 首部来告知浏览器它选择了哪一种算法。由于该内容协商过程是基于编码类型来选择资源的展现形式的，响应报文的 Vary 首部字段至少要包含 Content-Encoding。

常见编码：gzip、compress、deflate、identity

## 范围请求

如果网络出现中断，服务器只发送了一部分数据，范围请求可以使得客户端只请求服务器未发送的那部分数据，从而避免服务器重新发送所有数据。

**1.Range**

在请求报文中添加 Range 首部字段指定请求的范围。

```html
GET /z4d4kWk.jpg HTTP/1.1
Host: i.imgur.com
Range: bytes=0-1023
```

请求成功的话服务器返回的响应包含 206 Partial Content 状态码。

```html
HTTP/1.1 206 Partial Content
Content-Range: bytes 0-1023/146515
Content-Length: 1024
...
(binary content)
```

**2.Accept-Ranges**

响应首部字段 Accept-Ranges 用于告知客户端是否能处理范围请求，可以处理使用 bytes，否则使用 none。

```html
Accept-Ranges: bytes
```

**3.响应状态码**

- 在请求成功的情况下，服务器会返回 206 Partial Content 状态码。
- 在请求的范围越界的情况下，服务器会返回 416 Requested Range Not Satisfiable 状态码。
- 在不支持范围请求的情况下，服务器会返回 200 OK 状态码。

## 分块传输编码

Chunked Transfer Encoding，可以把数据分割成多块，让浏览器逐步显示页面。

## 多部分对象集合

一份报文主体内可含有多种类型的实体同时发送，每个部分之间用 boundary 字段定义的分隔符进行分隔，**每个部分**都可以有首部字段。

例如，上传多个表单时可以使用如下方式

```html
Content-Type: multipart/form-data; boundary=AaB03x

--AaB03x
Content-Disposition: form-data; name="submit-name"

Larry
--AaB03x
Content-Disposition: form-data; name="files"; filename="file1.txt"
Content-Type: text/plain

... contents of file1.txt ...
--AaB03x--
```

第一行是首部，表示是多部份对象，边界分隔符是“AaB03x”

第3行 表示一个部分对象的起始边界，第4行是其首部，名称为“submit-name”，内容是Larry

第7行 表示另一个部分对象的起始边界，第8行是其首部，表示名称为“files”，文件名为“file1.txt”，11行开始是文件内容

第12行表示多部份的结束，在分隔符之后加上“--”

## 通信数据转发

**1.代理**

代理服务器接受客户端的请求，并且转发给其它服务器。

使用代理的主要目的是：

- 缓存
- 负载均衡
- 网络访问控制
- 访问日志记录

代理服务器分为正向代理和反向代理两种

- 正向代理：客户端请求经过代理到达服务器，服务器不知道真正的客户端是谁
- 反向代理：服务器响应经过代理到达客户端，客户端不知道真正的服务器是谁



**2.网关**

与代理服务器不同的是，网关服务器会将 HTTP 转化为其它协议进行通信，从而请求其它非 HTTP 服务器的服务。

**3.隧道**

使用 SSL 等加密手段，在客户端和服务器之间建立一条安全的通信线路。



## HTTP1.1

### Q：HTTP1.0与HTTP1.1比较？

|          | HTTP1.0                                                      | HTTP1.1                                                      |
| -------- | :----------------------------------------------------------- | ------------------------------------------------------------ |
| 连接长短 | 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接 | 默认**长连接**，完成一次HTTP请求和响应后，可以接着复用该连接；但必须**串行**（一个连接不能同时发送多个请求）。 |
| 连接数   | 一个                                                         | 支持同时打开**多个 TCP 连接**                                |
| 方法     | 定义三种方法：GET, POST 和 HEAD                              | 增加了六种：OPTIONS, PUT, PATCH, DELETE, TRACE 和 CONNECT    |
| 状态码   |                                                              | 新增状态码 100（表示信息）                                   |
| 新特性   |                                                              | 支持分块传输编码                                             |
| 新特性   |                                                              | 支持虚拟主机（一台服务器拥有多个域名，在逻辑上可以看成多个服务器） |
| 新特性   |                                                              | 新增缓存处理指令 max-age                                     |
| 新特性   |                                                              | 连接支持流水线（`Pipelining`字段，同时发出多个请求，不用一个个等待响应） |



## HTTPS

HTTP 有以下安全性问题：

- 使用明文进行通信，内容可能会被窃听；
- 不验证通信方的身份，通信方的身份有可能遭遇伪装；
- 无法证明报文的完整性，报文有可能遭篡改。

HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，即 HTTPS 使用隧道通信。

通过SSL，HTTPS 解决了上述三个安全性问题，具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。

### 加密

**1.对称密钥加密**（Symmetric-Key Encryption），加密和解密使用**同一密钥**。

- 优点：运算速度快；
- 缺点：无法安全地将密钥传输给通信方。

**2.非对称密钥加密**，又称公开密钥加密（Public-Key Encryption），加密和解密使用**不同的密钥**。

- 加密【公加私解】：公开密钥所有人都可以获得，通信发送方获得接收方的公钥之后，用公钥加密，接收方收到通信内容后使用私有密钥解密。

- 签名【私加公解】：还可用来签名，过程与加密相反。因为私钥无法被其他人获取，因此发送方使用其私钥签名，接收方使用发送方的公钥对签名解密，就能判断这个签名是否正确，即是否发送方发出的，其他人由于没有私钥不能伪造，此外发送方也无法抵赖。


- 优点：可以更安全地将公开密钥传输给通信发送方；
- 缺点：运算速度慢。

**3.HTTPS 采用的加密方式：混合加密**

- 先使用非对称密钥加密，传输对称密钥加密方式所需要的 Secret Key，从而保证安全性;
- 获取到 Secret Key 后，再使用对称密钥加密方式进行通信，从而保证效率。

### 认证

通过使用 **证书** 来对通信方进行认证。

数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。

服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后**绑定**在一起。

进行 HTTPS 通信时，服务器会把 **证书** 发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。

### 完整性保护

SSL 提供报文摘要功能来进行完整性保护。

HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。

HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。

### HTTPS 的缺点

- 因为需要加密解密等过程，因此速度会更慢；
- 需要支付证书授权的高额费用。

## HTTP2 

HTTP/1.x 实现简单是以牺牲性能为代价的：

- 客户端需要使用多个连接才能实现并发和缩短延迟；
- 报文为纯文本格式，体积大
- 不会压缩请求和响应首部，从而导致不必要的网络流量；
- 不支持有效的资源优先级，致使底层 TCP 连接的利用率低下。

Http2改进：

多路复用、二进制传输、压缩首部、服务端推送

### 二进制分帧层

HTTP1的报头是基于ASCII文本的，无法直接表示二进制（除非用base64转换）

HTTP/2.0 将报文分成 HEADERS 帧和 DATA 帧，它们都是二进制格式的。

<img src="images/计算机网络/86e6a91d-a285-447a-9345-c5484b8d0c47.png" alt="img" style="zoom:50%;" />

在通信过程中，只会有一个 TCP 连接存在，它承载了任意数量的双向数据流（Stream）。

- 一个数据流（Stream）都有一个唯一标识符和可选的优先级信息，用于承载双向信息。
- 消息（Message）是与逻辑请求或响应对应的完整的一系列帧。
- 帧（Frame）是**最小**的通信单位，来自不同数据流的帧可以交错发送，然后再根据每个**帧头**的数据流标识符重新组装。

<img src="images/计算机网络/af198da1-2480-4043-b07f-a3b91a88b815.png" alt="img" style="zoom: 67%;" />

### 服务端推送

HTTP/2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端。

<img src="images/计算机网络/e3f1657c-80fc-4dfa-9643-bf51abd201c6.png" alt="img" style="zoom:75%;" />

### 首部压缩

HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。

HTTP/2.0 要求客户端和服务器同时维护和更新一个包含之前见过的**首部字段表**，从而避免了重复传输。

此外HTTP/2.0 也使用 **Huffman 编码**对首部字段进行压缩。

<img src="images/计算机网络/_u4E0B_u8F7D.png" alt="img" style="zoom: 50%;" />

## HTTP3

底层使用QUIC协议，基于UDP

<img src="images\计算机网络\1612458489-HxhiPr-HTTP协议的发展变化.png" alt="HTTP协议的发展变化.png" style="zoom:33%;" />

## DNS

<img src="images\计算机网络\1632307681-keCKRT-image.png" alt="DNS.png" style="zoom: 33%;" />

- 递归查询：如果主机所询问的本地域名服务器不知道被查询域名的 IP 地址，那么本地域名服务器就以 DNS 客户端的身份，向其他根域名服务器继续发出查询请求报文，即替主机继续查询，而不是让主机自己进行下一步查询，如上图步骤（1）和（10）。

- 迭代查询：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地服务器下一步应该找哪个域名服务器进行查询，然后让本地服务器进行后续的查询，如上图步骤（2）~（9）。

## DNS劫持

即域名劫持，是通过将原域名对应的 IP 地址进行替换从而使得用户访问到错误的网站，或者使用户无法正常访问网站的一种攻击方式。

攻击者冒充原域名所属机构，修改电子邮件来修改机构的域名注册信息，或将域名转让给其他组织，并将新域名保存在指定DNS服务器，使用户无法通过对原域名解析来访问目的网址。

域名劫持往往只能在特定的网络范围内进行，范围外DNS解析正常。

预防手段：

直接通过ip地址访问，避开DNS



## Q：GET和POST区别？

| GET                                                         | POST                                   |
| ----------------------------------------------------------- | -------------------------------------- |
| get 提交的数据放在 URL 中（http包头），可能会存在安全问题。 | post 参数放在请求主体（http正文）中    |
| get请求参数会被缓存，会留在浏览器历史记录                   | post请求不会被缓存，也不会保留历史记录 |
| get 只支持 URL 编码（百分比编码，只能用ASCII字符）          | post 支持多种编码                      |
| get 提交的数据大小有限制（是浏览器的限制，与http无关）      | post 提交的数据大小没限制              |
| get产生一个TCP数据包                                        | post产生两个（视浏览器而定）           |

### 幂等性

幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。即，幂等方法不应该具有副作用（统计用途除外），是安全的。



在正确实现的条件下，GET，HEAD，PUT 和 DELETE等方法都是幂等的，而 **POST 方法不是**。

例如，DELETE删多次，最终结果都是删除一个URL资源而已：

```text
DELETE /idX/delete HTTP/1.1   -> Returns 200 if idX exists
DELETE /idX/delete HTTP/1.1   -> Returns 404 as it just got deleted
DELETE /idX/delete HTTP/1.1   -> Returns 404
```

### 可缓存

如果要对响应进行缓存，需要满足以下条件：

- 请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。
- 响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。
- 响应报文的 Cache-Control 首部字段没有指定不进行缓存。

### XMLHttpRequest

为了阐述 POST 和 GET 的另一个区别，需要先了解 XMLHttpRequest：

> XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。

- 在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。
- 而 GET 方法 Header 和 Data 会一起发送。

# wireshark抓包

SYN表示建立连接

FIN表示关闭连接

ACK表示响应

PSH表示有 data 数据传输

RST表示连接重置

![image-20230103102225757](images/计算机网络/image-20230103102225757.png)

如图表示一个已经建立的TCP连接，红框第一行表示A向B发送一个空包（LEN=0），表示确认（ACK）收到B的第2630字节以前的内容

第二行表示A向B传输数据（PSH），长度1460，因此发送第4402~5861（4402+1460-1，因为包括4402）个字节。

第三行表示B向A发送一个空确认包，ACK=5862 （A发送的最后一个字节号5861+1）

由上可知实际使用符合TCP传输规定



# Socket

Socket（套接字）是一个抽象概念，一个应用程序通过一个Socket来建立一个远程连接，而Socket内部通过TCP/IP协议传输数据。一个Socket就是由 **IP地址+端口号**（范围是0～65535）组成

使用Socket进行网络编程时，本质上就是两个进程之间的网络通信。其中一个进程必须充当服务器端，它会主动监听某个指定的端口，另一个进程必须充当客户端，它必须主动连接服务器的IP地址和指定端口，如果连接成功，服务器端和客户端就成功地建立了一个TCP连接，双方后续就可以随时发送和接收数据。

## Q：Socket和http的区别和应用场景

Socket连接就是所谓的长连接，理论上客户端和服务器端一旦建立起连接将不会主动断掉；Socket适用场景：网络游戏，银行持续交互，直播，在线视屏等。
http连接就是所谓的短连接，即客户端向服务器端发送一次请求，服务器端响应后连接即会断开等待下次连接。http适用场景：公司OA服务，互联网服务，电商，办公，网站等等等等

## 编写HTTP Server（1.0)

一个HTTP Server本质上是一个TCP服务器，先用[TCP编程](https://www.liaoxuefeng.com/wiki/1252599548343744/1305207629676577)的多线程实现的服务器端框架。

只需要在`handle()`方法中，用Reader读取HTTP请求，用Writer发送HTTP响应，即可实现一个最简单的HTTP服务器。

```java
public class Server {
    public static void main(String[] args) throws IOException {
        ServerSocket ss = new ServerSocket(8080); // 监听指定端口
        System.out.println("server is running...");
        for (;;) {
            Socket sock = ss.accept();
            System.out.println("connected from " + sock.getRemoteSocketAddress());
            Thread t = new Handler(sock);  // 传入Socket创建线程
            t.start();
        }
    }
}

class Handler extends Thread {
    Socket sock;

    public Handler(Socket sock) {
        this.sock = sock;
    }

    public void run() {
        try (InputStream input = this.sock.getInputStream()) {
            try (OutputStream output = this.sock.getOutputStream()) {
                handle(input, output);
            }
        } catch (Exception e) {
            try {
                this.sock.close();
            } catch (IOException ioe) {
            }
            System.out.println("client disconnected.");
        }
    }
    // 核心逻辑：处理http请求和发送响应
    private void handle(InputStream input, OutputStream output) throws IOException {
    	System.out.println("Process new http request...");
    	var reader = new BufferedReader(new InputStreamReader(input, StandardCharsets.UTF_8));
    	var writer = new BufferedWriter(new OutputStreamWriter(output, StandardCharsets.UTF_8));
    	// 读取HTTP请求:
    	boolean requestOk = false;
    	String first = reader.readLine();
    	if (first.startsWith("GET / HTTP/1.")) { // 不是以这个开头的，认为请求非法
        	requestOk = true;
   	 	}
    	for (;;) {
        	String header = reader.readLine();
        	if (header.isEmpty()) { // 读取到空行时, HTTP Header读取完毕
            	break;
        	}
        	System.out.println(header);
    	}
    	System.out.println(requestOk ? "Response OK" : "Response Error");
    	if (!requestOk) {
        	// 发送错误响应:
        	writer.write("HTTP/1.0 404 Not Found\r\n");
        	writer.write("Content-Length: 0\r\n");
        	writer.write("\r\n");
        	writer.flush();
    	} else {
        	// 发送成功响应:
        	String data = "<html><body><h1>Hello, world!</h1></body></html>";
        	int length = data.getBytes(StandardCharsets.UTF_8).length;
            // 首先发送响应代码，表示一个成功的200响应，使用HTTP/1.0协议
        	writer.write("HTTP/1.0 200 OK\r\n");
            // Header
        	writer.write("Connection: close\r\n");
        	writer.write("Content-Type: text/html\r\n");
        	writer.write("Content-Length: " + length + "\r\n");
             // 空行标识Header和Body的分隔
        	writer.write("\r\n");
            // Body
        	writer.write(data);
        	writer.flush();
    	}
	}
}
```



# Base64编码

目的是把二进制数据变成文本格式，这样在很多文本中就可以处理二进制数据（如电子邮件协议pop3、SMTP等）。一共用到`A~Z`、`a~z`、`+`和`/`，共64个ASCII字符

缺点：效率变低，因为长度增加1/3

编码举例：3个byte数据分别是`e4`、`b8`、`ad`，按**6bit分组**得到`39`、`0b`、`22`和`2d`：

```ascii
┌───────────────┬───────────────┬───────────────┐
│      e4       │      b8       │      ad       │
└───────────────┴───────────────┴───────────────┘
┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
│1│1│1│0│0│1│0│0│1│0│1│1│1│0│0│0│1│0│1│0│1│1│0│1│
└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
┌───────────┬───────────┬───────────┬───────────┐
│    39     │    0b     │    22     │    2d     │
└───────────┴───────────┴───────────┴───────────┘
```

因为6位整数的范围总是`0~63`，所以，能用**64个字符**表示：字符`A~Z`对应索引`0~25`，字符`a~z`对应索引`26~51`，字符`0~9`对应索引`52~61`，最后两个索引`62`、`63`分别用字符`+`和`/`表示。

