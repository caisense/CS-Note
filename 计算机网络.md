# 传输层-TCP

## TCP 首部格式

<img src="images/计算机网络/55dc4e84-573d-4c13-a765-52ed1dd251f9.png" alt="img" style="zoom:50%;" />

- **序号 seq** ：用于对**数据部分**字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。

  因为占32位，所以取值范围0~2^31-1。当序号到达最后一个时，下一个序号又回到0

- **确认号 ack** ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。

  取值范围也是0~2^31-1，到达最后一个回头

- **数据偏移** ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。

- **确认 ACK** ：当 ACK=1 时确认号字段ack有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1（除了FIN）。

- **同步 SYN** ：在**连接建立时**用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。

- **终止 FIN** ：用来**释放一个连接**，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。

- **窗口** ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。

## 三次握手（三报文握手）

<img src="images/计算机网络/e92d0ebc-7d46-413b-aec1-34a39602f787.png" alt="img" style="zoom:50%;" />

假设 A 为客户端，B 为服务器端。三次握手的报文**都不携带数据**。

- 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。

- A 向 B 发送连接请求报文，SYN=1，ACK=0（因为是**初始报文**，不需要对任何报文确认），选择一个初始的序号 x。

- B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1（因为A发来的报文不携带数据，所以期望收到下一个报文序号是x+1），同时也选择一个初始的序号 y。

- A 收到 B 的连接确认报文后，还要向 B 发出确认，ACK=1，确认号为 y+1，序号为 x+1。

  注意这是一个**普通报文**，可以携带数据。如果未携带数据则不消耗序号seq，即A发出的下一个报文seq仍为x+1。而前两个报文虽然不带数据，但都消耗一个序号。

- B 收到 A 的确认后，连接建立，双方都可以进行收发。

## 四次挥手（四报文挥手）

<img src="images/计算机网络/f87afe72-c2df-4c12-ac03-9b8d581a8af8.jpg" alt="img" style="zoom: 67%;" />

以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单（前两个报文：u为A上一个报文的序号+1，v为B的上一个报文序号+1。第三个报文：w为**半关闭状态**下B发送的上一个报文序号+1，u+1是对之前A发送释放连接报文的**重复确认**）。

并且不讨论 ACK（因为 ACK 在连接建立之后都为 1）。

- A 发送连接释放报文，FIN=1。
- B 收到之后发出确认，此时 TCP 属于**半关闭状态**，B 能向 A 发送数据但是 A 不能向 B 发送数据。
- 当 B 不再需要连接时，发送连接释放报文，FIN=1。
- A 收到后发出确认，进入 TIME-WAIT 状态，**等待 2 MSL**（最大报文存活时间）后释放连接。
- B 收到 A 的确认后**立刻**释放连接。

## Q：为什么三次握手不能简化为两次？

防止已失效的TCP连接请求报文段突然又传送到了TCP服务器进程，让服务器错误打开连接。

客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。

## Q：为什么要四次挥手？

客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。

**TIME_WAIT**

客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。两个理由：

- 确保A最后一个确认报文能够到达B。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文（超时重传），导致A一直无法关闭。
- 为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。

## Q：2MSL如何得出？

**类似问题：如何保证A发出最后一个连接释放报文，B一定能关闭？**

考虑最坏情况：A发出最后一个连接释放报文，最多1MSL到达B，如果该报文丢失，则B发起超时重传（B发出FIN也会等2MSL），最多1MSL到达A，总共经历2MSL。如果2MSL后没收到B的报文，则说明B没有超时重传，确认B已经关闭，因此A可以放心关闭。

# 传输层-UDP

## UDP 首部格式

<img src="images/计算机网络/d4c3a4a1-0846-46ec-9cc3-eaddfca71254.jpg" alt="img" style="zoom:50%;" />

首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。

## Q：TCP和UDP不同？

|          | TCP                                                          | UDP                                                          |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 面向     | 字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块） | 报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部） |
| 连接     | 面向连接                                                     | 无连接                                                       |
| 交付     | 可靠交付                                                     | 尽最大可能交付                                               |
| 拥塞控制 | 有                                                           | 无                                                           |
|          | 全双工                                                       |                                                              |
|          | 点对点（一对一）                                             | 一对一、一对多、多对一、多对多                               |

## TCP可靠传输

TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。

一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下：

# 应用层-HTTP

## HTTP头部

通用头：是客户端和服务器都可以使用的头部，可以在客户端、服务器和其他应用程序之间提供一些非常有用的通用功能，如Date头部。

请求头：是请求报文特有的，它们为服务器提供了一些额外信息，比如客户端希望接收什么类型的数据，如Accept头部。

响应头：便于客户端提供信息，比如，客服端在与哪种类型的服务器进行交互，如Server头部。
实体头：指的是用于应对实体主体部分的头部，比如，可以用实体头部来说明实体主体部分的数据类型，如Content-Type头部。

## HTTP方法

HTTP/1.0 定义了三种：GET, POST 和 HEAD 

HTTP/1.1 增加了六种：OPTIONS, PUT, PATCH, DELETE, TRACE 和 CONNECT

| 方法                         | 描述                                                         |
| :--------------------------- | ------------------------------------------------------------ |
| GET                          | 请求指定的页面信息，并返回具体内容，通常只用于读取数据。     |
| POST                         | 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立或已有资源的更改。 |
| HEAD                         | 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头。 |
| =================HTTP1.1新增 | =============================================                |
| PUT                          | 替换指定的资源，没有的话就新增。                             |
| DELETE                       | 请求服务器删除 URL 标识的资源数据。                          |
| CONNECT                      | 将服务器作为代理，让服务器代替用户进行访问。                 |
| OPTIONS                      | 向服务器发送该方法，会返回对指定资源所支持的 HTTP 请求方法。 |
| TRACE                        | 回显服务器收到的请求数据，即服务器返回自己收到的数据，主要用于测试和诊断。 |
| PATCH                        | 是对 PUT 方法的补充，用来对已知资源进行**局部更新**。        |

## HTTP1.0与HTTP1.1

| HTTP1.0                                                      | HTTP1.1                                                      |
| :----------------------------------------------------------- | ------------------------------------------------------------ |
| 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接 | 默认**长连接**，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟 |
| 定义三种方法：GET, POST 和 HEAD                              | 增加了六种：OPTIONS, PUT, PATCH, DELETE, TRACE 和 CONNECT    |
|                                                              |                                                              |
|                                                              |                                                              |

## HTTP2 

多路复用、二进制传输、压缩首部、服务端推送

## HTTP3

底层使用QUIC协议，基于UDP

<img src="images\计算机网络\1612458489-HxhiPr-HTTP协议的发展变化.png" alt="HTTP协议的发展变化.png" style="zoom:33%;" />

## DNS

<img src="images\计算机网络\1632307681-keCKRT-image.png" alt="DNS.png" style="zoom: 33%;" />

- 递归查询：如果主机所询问的本地域名服务器不知道被查询域名的 IP 地址，那么本地域名服务器就以 DNS 客户端的身份，向其他根域名服务器继续发出查询请求报文，即替主机继续查询，而不是让主机自己进行下一步查询，如上图步骤（1）和（10）。

- 迭代查询：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地服务器下一步应该找哪个域名服务器进行查询，然后让本地服务器进行后续的查询，如上图步骤（2）~（9）。

## DNS劫持

即域名劫持，是通过将原域名对应的 IP 地址进行替换从而使得用户访问到错误的网站，或者使用户无法正常访问网站的一种攻击方式。

攻击者冒充原域名所属机构，修改电子邮件来修改机构的域名注册信息，或将域名转让给其他组织，并将新域名保存在指定DNS服务器，使用户无法通过对原域名解析来访问目的网址。

域名劫持往往只能在特定的网络范围内进行，范围外DNS解析正常。

预防手段：

直接通过ip地址访问，避开DNS



## Q:GET和POST区别？

| GET                                                         | POST                                   |
| ----------------------------------------------------------- | -------------------------------------- |
| get 提交的数据放在 URL 中（http包头），可能会存在安全问题。 | post 参数放在请求主体（http正文）中    |
| get请求参数会被缓存，会留在浏览器历史记录                   | post请求不会被缓存，也不会保留历史记录 |
| get 只支持 URL 编码（百分比编码，只能用ASCII字符）          | post 支持多种编码                      |
| get 提交的数据大小有限制（是浏览器的限制，与http无关）      | post 提交的数据大小没限制              |
| get产生一个TCP数据包                                        | post产生两个（视浏览器而定）           |

## 套接字

套接字（Socket）是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象，网络进程通信的一端就是一个套接字，不同主机上的进程便是通过套接字发送报文来进行通信。例如 TCP 用主机的 IP 地址 + 端口号作为 TCP 连接的端点，这个端点就叫做套接字。

## 编写HTTP Server（1.0)

一个HTTP Server本质上是一个TCP服务器，先用[TCP编程](https://www.liaoxuefeng.com/wiki/1252599548343744/1305207629676577)的多线程实现的服务器端框架。

只需要在`handle()`方法中，用Reader读取HTTP请求，用Writer发送HTTP响应，即可实现一个最简单的HTTP服务器。

```java
public class Server {
    public static void main(String[] args) throws IOException {
        ServerSocket ss = new ServerSocket(8080); // 监听指定端口
        System.out.println("server is running...");
        for (;;) {
            Socket sock = ss.accept();
            System.out.println("connected from " + sock.getRemoteSocketAddress());
            Thread t = new Handler(sock);  // 传入Socket创建线程
            t.start();
        }
    }
}

class Handler extends Thread {
    Socket sock;

    public Handler(Socket sock) {
        this.sock = sock;
    }

    public void run() {
        try (InputStream input = this.sock.getInputStream()) {
            try (OutputStream output = this.sock.getOutputStream()) {
                handle(input, output);
            }
        } catch (Exception e) {
            try {
                this.sock.close();
            } catch (IOException ioe) {
            }
            System.out.println("client disconnected.");
        }
    }
    // 核心逻辑：处理http请求和发送响应
    private void handle(InputStream input, OutputStream output) throws IOException {
    	System.out.println("Process new http request...");
    	var reader = new BufferedReader(new InputStreamReader(input, StandardCharsets.UTF_8));
    	var writer = new BufferedWriter(new OutputStreamWriter(output, StandardCharsets.UTF_8));
    	// 读取HTTP请求:
    	boolean requestOk = false;
    	String first = reader.readLine();
    	if (first.startsWith("GET / HTTP/1.")) { // 不是以这个开头的，认为qin'qiu
        	requestOk = true;
   	 	}
    	for (;;) {
        	String header = reader.readLine();
        	if (header.isEmpty()) { // 读取到空行时, HTTP Header读取完毕
            	break;
        	}
        	System.out.println(header);
    	}
    	System.out.println(requestOk ? "Response OK" : "Response Error");
    	if (!requestOk) {
        	// 发送错误响应:
        	writer.write("HTTP/1.0 404 Not Found\r\n");
        	writer.write("Content-Length: 0\r\n");
        	writer.write("\r\n");
        	writer.flush();
    	} else {
        	// 发送成功响应:
        	String data = "<html><body><h1>Hello, world!</h1></body></html>";
        	int length = data.getBytes(StandardCharsets.UTF_8).length;
            // 首先发送响应代码，表示一个成功的200响应，使用HTTP/1.0协议
        	writer.write("HTTP/1.0 200 OK\r\n");
            // Header
        	writer.write("Connection: close\r\n");
        	writer.write("Content-Type: text/html\r\n");
        	writer.write("Content-Length: " + length + "\r\n");
             // 空行标识Header和Body的分隔
        	writer.write("\r\n");
            // Body
        	writer.write(data);
        	writer.flush();
    	}
	}
}
```
