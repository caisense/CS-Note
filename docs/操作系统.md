操作系统

# 进程和线程区别？

|          | 进程                                 | 线程                                                         |
| -------- | ------------------------------------ | ------------------------------------------------------------ |
| 概念     | 运行时的程序                         | 是进程的子任务                                               |
| 从属关系 | 一个进程可以有多个线程               | 一个线程只属于一个进程                                       |
| 调度粒度 | 是操作系统调度的最小单位             | 是CPU调度的最小单位                                          |
| 内存     | 有独立内存单元，进程之间互不影响     | 多个线程共享所在进程的内存，线程也有自己的内存空间           |
| 切换开销 | 大                                   | 小                                                           |
| 通信     | 共享内存、管道、信号量、套接字socket | 1. 共享内存（临界区）; 2. 事件（信号），如java的wait() notify()；3. 互斥量，如Synchronized、Lock |



# 父进程和子进程的关系

fork()会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，Linux中引入了写时复制（COW）技术，也就是只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。在fork之后exec之前两个进程用的是相同的物理空间（内存区），子进程的代码段、数据段、堆栈都是指向父进程的物理空间，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间，如果不是因为exec，内核会给子进程的数据段、堆栈段分配相应的物理空间（至此两者有各自的进程空间，互不影响），而代码段继续共享父进程的物理空间（两者的代码完全相同）。而如果是因为exec，由于两者执行的代码不同，子进程的代码段也会分配单独的物理空间。



# IO多路复用

> I/O multiplexing，翻译成IO多路复用有歧义，其实并不是多路IO复用一个物理链路，而是：**单个线程，通过记录跟踪每个I/O流(sock)的状态，来同时管理多个I/O流 。**

select, poll, 和 epoll 都是 Linux 中常见的 I/O 多路复用技术，它们可以用于同时监听多个**文件描述符**（file descriptor，后文简称fd），当任意一个文件描述符就绪时，就能够非阻塞的读写数据。

- select 是最原始的 I/O 多路复用技术，它的缺点是最多只能监听 1024 个文件描述符。
- poll在 select 的基础上，取消了监听文件描述符个数的限制，但是复杂度增加，并且线程不安全。
- epoll 在 poll 的基础上进一步优化了复杂度，并且线程安全。

## **阻塞 IO** 

服务端为了处理客户端的连接和请求的数据，写了如下伪代码。

```java
listenfd = socket();   // 打开一个网络通信端口
bind(listenfd);        // 绑定
listen(listenfd);      // 监听
while(1) {
  connfd = accept(listenfd);  // 阻塞建立连接
  int n = read(connfd, buf);  // 阻塞读数据
  doSomeThing(buf);  // 利用读到的数据做些什么
  close(connfd);     // 关闭连接，循环等待下一个连接
}
```

这段代码与客户端的交互流程：

<img src="images/操作系统/阻塞io.gif" alt="未命名图片" style="zoom: 67%;" />

可以看到，服务端的线程阻塞在了两个地方，一个是 accept 函数，一个是 read 函数。

如果再把 read 函数的细节展开，我们会发现其阻塞在**网卡--内核缓冲区**、**内核缓冲区--用户缓冲区buf** 两个阶段

<img src="images/操作系统/read.png" alt="图片" style="zoom: 67%;" />

所以，如果这个连接的客户端一直不发数据，那么服务端线程将会一直阻塞在 read 函数上不返回，也无法接受其他客户端连接。

## **非阻塞 IO**

为了解决上面的问题，其关键在于改造这个 read 函数。

## select

是操作系统提供的系统调用函数，传入一个fd的数组发给操作系统， 让操作系统去遍历，确定哪个文件描述符可以读写。方法定义：

```c
int select(
    int nfds,  // nfds:监控的文件描述符集里最大文件描述符加1
    fd_set *readfds,  // readfds：监控有读数据到达文件描述符集合，指针
    fd_set *writefds,  // writefds：监控写数据到达文件描述符集合，指针
    fd_set *exceptfds,  // exceptfds：监控异常发生达文件描述符集合, 指针
    struct timeval *timeout);  // timeout：定时阻塞监控时间，3种情况：1.NULL，永远等下去 2.设置timeval，等待固定时间                                                                // 3.设置timeval里时间均为0，检查描述字后立即返回，轮询
```

服务端代码：

一个线程不断接受客户端连接，并把 socket 文件描述符放到一个 list 里。

```java
while(1) {
    connfd = accept(listenfd);
    fcntl(connfd, F_SETFL, O_NONBLOCK);
    fdlist.add(connfd);
}
```

另一个线程不再自己遍历，而是调用 select，将这批文件描述符 list 交给操作系统去遍历。

```java
while(1) {
    // 把一堆文件描述符 list 传给 select 函数
    // 有已就绪的文件描述符就返回，nready 表示就绪的个数
    nready = select(list);
    ...
}
```

不过，当 select 函数返回后，用户依然需要遍历刚刚提交给操作系统的 list，但是少了很多无效的系统调用

```java
while(1) {
    nready = select(list);
    // 用户层依然要遍历
    for(fd <-- fdlist) {
        // 只读已就绪的fd
        if(fd != -1) {
            read(fd, buf);
            // 总共只有 nready 个已就绪fd，不用过多遍历
            if(--nready == 0) break;
        }
    }
}
```



## epoll

第一步，创建一个 epoll 句柄，size告诉内核监听的fd数量：

```c
int epoll_create(int size);
```

第二步，向内核添加、修改或删除要监控的文件描述符。该方法将所有fd拷贝到内核，保证epoll只拷贝一次

```c
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
```

第三步，类似发起了 select() 调用，查看是否有就绪的fd，若有则直接使用O(1)，而不像poll和select需要手动O(n)遍历

```c
int epoll_wait(int epfd, struct epoll_event *events, int max events, int timeout);
```



## 比较

|                          | select | poll    | epoll   |
| ------------------------ | ------ | ------- | ------- |
| fd长度（个数）           | 1024   | 无限制* | 无限制* |
| 遍历所有fd               | 是     | 是      | 否      |
| 把fd从用户态copy到内核态 | 是     | 是      | 否      |

*注：上限是系统可以打开的最大文件数，远大于1024，具体可以用命令`cat /proc/sys/fs/file-max`查看。在1GB内存的机器上，大于10万。

# Swap交换分区

Linux中的一个区域，类似于Windows的虚拟内存，当内存不足时，把一部分硬盘空间虚拟成内存，解决内存容量不足的问题。

合理取值一般是内存的2倍



# 程序编译

- 程序功能的实现通常可以分为两个阶段：

- 静态处理阶段（static），在程序本身开始执行前的处理。通常包括：

- - 翻译阶段（编译）：对源程序做各种检查（语法检查，类型检查等）和变换，将其转变为某种适宜动态执行的形式
  - 连接阶段（可能）：构造出可动态运行的程序形式
  - 装载阶段（可能）：把可运行程序装入运行环境，必要的处理

- 动态执行阶段（run-time），指程序的实际运行期间

- 例：若变量x 的（绝对或相对）位置可静态确定，运行中就可以直接访问。若不能静态确定，运行中每次访问都要查表，效率就比较低

- 语言的“编译实现”：在静态阶段完成尽可能多的处理工作，对源程序做深入的分析和变换，生成的目标形式通常与源程序差异巨大

# Amdahl定律

加快某部件执行速度所获得的系统性能加速比，受限于该部件在系统中所占的比例。

Amdahl定律既可以用来确定系统中对性能限制最大的部件，也可以用来计算通过改进某些部件所获得的系统性能的提高。

- Amdahl定律：加快某部件执行速度所获得的系统性能加速比，受限于该部件在系统中所占的比例。
- Amdahl定律既可以用来确定系统中对性能限制最大的部件，也可以用来计算通过改进某些部件所获得的系统性能的提高。

<img src="images/操作系统/未命名图片.jpg" alt="未命名图片" style="zoom:50%;" />

<img src="images/操作系统/1png.jpg" alt="1png" style="zoom: 33%;" />