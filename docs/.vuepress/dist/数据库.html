<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>关系数据库理论 | 个人主页</title>
    <meta name="generator" content="VuePress 1.9.9">
    
    <meta name="description" content="CZT的博客">
    
    <link rel="preload" href="/assets/css/0.styles.e8e4f3a3.css" as="style"><link rel="preload" href="/assets/js/app.c780e1b6.js" as="script"><link rel="preload" href="/assets/js/2.f44a4f26.js" as="script"><link rel="preload" href="/assets/js/24.45adeb21.js" as="script"><link rel="prefetch" href="/assets/js/10.207c4431.js"><link rel="prefetch" href="/assets/js/11.747359fa.js"><link rel="prefetch" href="/assets/js/12.6c286f4f.js"><link rel="prefetch" href="/assets/js/13.c0822fad.js"><link rel="prefetch" href="/assets/js/14.75e13154.js"><link rel="prefetch" href="/assets/js/15.cf4291c4.js"><link rel="prefetch" href="/assets/js/16.babfb68b.js"><link rel="prefetch" href="/assets/js/17.600473bc.js"><link rel="prefetch" href="/assets/js/18.0b6e0252.js"><link rel="prefetch" href="/assets/js/19.cfc57187.js"><link rel="prefetch" href="/assets/js/20.dec901f2.js"><link rel="prefetch" href="/assets/js/21.bfa49832.js"><link rel="prefetch" href="/assets/js/22.a31f4be5.js"><link rel="prefetch" href="/assets/js/23.7019856d.js"><link rel="prefetch" href="/assets/js/25.43428e77.js"><link rel="prefetch" href="/assets/js/26.f37e9ddb.js"><link rel="prefetch" href="/assets/js/27.241fb6ed.js"><link rel="prefetch" href="/assets/js/28.1bf839c4.js"><link rel="prefetch" href="/assets/js/29.bbb07d62.js"><link rel="prefetch" href="/assets/js/3.1aa3be4a.js"><link rel="prefetch" href="/assets/js/30.7ca7bc7e.js"><link rel="prefetch" href="/assets/js/4.7ac2b204.js"><link rel="prefetch" href="/assets/js/5.f702624b.js"><link rel="prefetch" href="/assets/js/6.c76c0e1e.js"><link rel="prefetch" href="/assets/js/7.414750dc.js"><link rel="prefetch" href="/assets/js/8.bc490d6c.js"><link rel="prefetch" href="/assets/js/9.0cb2026c.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e8e4f3a3.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">个人主页</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java" class="dropdown-title"><span class="title">Java</span> <span class="arrow down"></span></button> <button type="button" aria-label="Java" class="mobile-dropdown-title"><span class="title">Java</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Java基础.html" class="nav-link">
  Java基础
</a></li><li class="dropdown-item"><!----> <a href="/Java高级.html" class="nav-link">
  Java高级
</a></li><li class="dropdown-item"><!----> <a href="/Java并发.html" class="nav-link">
  Java并发
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据库" class="dropdown-title"><span class="title">数据库</span> <span class="arrow down"></span></button> <button type="button" aria-label="数据库" class="mobile-dropdown-title"><span class="title">数据库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/MySQL.html" class="nav-link">
  MySQL
</a></li><li class="dropdown-item"><!----> <a href="/数据库.html" class="nav-link">
  数据库
</a></li><li class="dropdown-item"><!----> <a href="/Redis.html" class="nav-link">
  Redis
</a></li><li class="dropdown-item"><!----> <a href="/存储.html" class="nav-link">
  存储
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java" class="dropdown-title"><span class="title">Java</span> <span class="arrow down"></span></button> <button type="button" aria-label="Java" class="mobile-dropdown-title"><span class="title">Java</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Java基础.html" class="nav-link">
  Java基础
</a></li><li class="dropdown-item"><!----> <a href="/Java高级.html" class="nav-link">
  Java高级
</a></li><li class="dropdown-item"><!----> <a href="/Java并发.html" class="nav-link">
  Java并发
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据库" class="dropdown-title"><span class="title">数据库</span> <span class="arrow down"></span></button> <button type="button" aria-label="数据库" class="mobile-dropdown-title"><span class="title">数据库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/MySQL.html" class="nav-link">
  MySQL
</a></li><li class="dropdown-item"><!----> <a href="/数据库.html" class="nav-link">
  数据库
</a></li><li class="dropdown-item"><!----> <a href="/Redis.html" class="nav-link">
  Redis
</a></li><li class="dropdown-item"><!----> <a href="/存储.html" class="nav-link">
  存储
</a></li></ul></div></div> <!----></nav>  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="关系数据库理论"><a href="#关系数据库理论" class="header-anchor">#</a> 关系数据库理论</h1> <h2 id="键"><a href="#键" class="header-anchor">#</a> 键</h2> <p>超键：能唯一标识元组的属性集，包含候选键和主键。可以是一个或多个属性</p> <p>候选键：<strong>最小</strong>超键，即没有冗余元素的超键</p> <p>主键：数据库表 中每行数据的<strong>唯一标识</strong>，每行有且只有唯一主键。可以是一个或多个属性，不能为空NULL</p> <p>外键：一个表中存在的另一个表的主键，与其他表建立约束，可以为NULL</p> <h2 id="三大范式"><a href="#三大范式" class="header-anchor">#</a> 三大范式</h2> <p>第一范式（1NF）：属性不可分。
第二范式（2NF）：在第一范式的基础上，一个表必须有一个主键，非主键列 <strong>完全依赖</strong> 于主键，而不能是依赖于主键的一部分。
第三范式（3NF）：在第二范式的基础上，非主键列只依赖（直接依赖）于主键，不依赖于其他非主键。</p> <h2 id="er图"><a href="#er图" class="header-anchor">#</a> ER图</h2> <p>Entity-Relationship，有三个组成部分：实体、属性、联系。</p> <p>用来进行关系型数据库系统的概念设计。</p> <h3 id="实体的三种联系"><a href="#实体的三种联系" class="header-anchor">#</a> 实体的三种联系</h3> <p>包含一对一，一对多，多对多三种。</p> <ul><li>如果 A 到 B 是一对多关系，那么画个带箭头的线段指向 B；</li> <li>如果是一对一，画两个带箭头的线段；</li> <li>如果是多对多，画两个不带箭头的线段。</li></ul> <p>下图的 Course 和 Student 是一对多的关系。</p> <img src="images/数据库/1d28ad05-39e5-49a2-a6a1-a6f496adba6a.png" alt="img" style="zoom:50%;"> <h3 id="表示出现多次的关系"><a href="#表示出现多次的关系" class="header-anchor">#</a> 表示出现多次的关系</h3> <p>一个实体在联系出现几次，就要用几条线连接。</p> <p>下图表示一个课程的先修关系，先修关系出现两个 Course 实体，第一个是先修课程，后一个是后修课程，因此需要用两条线来表示这种关系。</p> <img src="images/数据库/ac929ea3-daca-40ec-9e95-4b2fa6678243.png" alt="img" style="zoom:50%;"> <h3 id="联系的多向性"><a href="#联系的多向性" class="header-anchor">#</a> 联系的多向性</h3> <p>虽然老师可以开设多门课，并且可以教授多名学生，但是对于特定的学生和课程，只有一个老师教授，这就构成了一个三元联系。</p> <img src="images/数据库/5bb1b38a-527e-4802-a385-267dadbd30ba.png" alt="img" style="zoom:50%;"> <h3 id="表示子类"><a href="#表示子类" class="header-anchor">#</a> 表示子类</h3> <p>用一个三角形和两条线来连接类和子类，与子类有关的属性和联系都连到子类上，而与父类和子类都有关的连到父类上。</p> <img src="images/数据库/14389ea4-8d96-4e96-9f76-564ca3324c1e.png" alt="img" style="zoom:50%;"> <h1 id="触发器"><a href="#触发器" class="header-anchor">#</a> 触发器</h1> <p>触发器（trigger）是与表相关的数据库对象，是用户定义在关系表上的一类由<strong>事件驱动</strong>的特殊的存储过程，在满足定义条件时触发，并执行触发器中定义的 语句集合。触发器的这种特性可以协助应用在数据库端确保 数据库的完整性。</p> <p>使用场景</p> <ul><li><p>可以通过数据库中的相关表实现 <strong>级联更改</strong>；</p></li> <li><p>实时监控某张表中的某个字段的更改，并需要做出相应的处理。</p></li></ul> <h1 id="事务"><a href="#事务" class="header-anchor">#</a> 事务</h1> <p>作为一个整体，要么都执行，要么都不</p> <p>作用：保持数据一致性、可恢复性</p> <h2 id="acid原则"><a href="#acid原则" class="header-anchor">#</a> ACID原则</h2> <ul><li><p>A原子性：事务是最小的执行单位，不可分割。</p></li> <li><p>C一致性：数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。</p></li> <li><p>I隔离性：一个事务所做的修改在提交前，对其它事务是不可见。</p></li> <li><p>D持久性：一旦事务提交，则其所做的修改永远保存到数据库中。即使系统崩溃，事务执行的结果也不能丢失。</p></li></ul> <p>事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种<strong>平级关系</strong>：</p> <ul><li>只有满足一致性，事务的执行结果才是正确的。</li> <li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li> <li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li> <li>事务满足持久化是为了能应对系统崩溃的情况。</li></ul> <h3 id="如何实现acid特性"><a href="#如何实现acid特性" class="header-anchor">#</a> 如何实现ACID特性</h3> <ul><li>原子性：由<strong>undo log</strong>日志保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql</li> <li>一致性：一般由<strong>代码层面</strong>来保证</li> <li>持久性：由<strong>内存+redo log</strong>来保证，mysql修改数据同时在内存和redo log记录这次操作，事务提交的时候通过redo log刷盘，宕机的时候可以从redo log恢复</li> <li>隔离性：由<strong>MVCC</strong>来保证</li></ul> <h3 id="autocommit"><a href="#autocommit" class="header-anchor">#</a> AUTOCOMMIT</h3> <p>MySQL 默认采用自动提交模式。也就是说，如果不显式使用<code>START TRANSACTION</code>语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。</p> <h2 id="事务并发问题"><a href="#事务并发问题" class="header-anchor">#</a> 事务并发问题</h2> <h3 id="脏读"><a href="#脏读" class="header-anchor">#</a> 脏读</h3> <p>（Dirty Read）事务a读取了事务b<strong>未提交</strong>的数据。</p> <h3 id="不可重复读"><a href="#不可重复读" class="header-anchor">#</a> 不可重复读</h3> <p>（Non-repeatable Read）同一事务内，多次读同一数据结果不一样（因为在此过程中有其他事务对数据进行了修改）。例如事务T2读A，T1修改了A，T2再读A和上一次读到的不同</p> <img src="images/数据库/image-20191207222102010.png" alt="img" style="zoom:50%;"> <h3 id="幻读"><a href="#幻读" class="header-anchor">#</a> 幻读</h3> <p>（Phantom Read）本质也是不可重复读。区别在于不是某条，而是某个范围</p> <p>例如有事务a对表中的数据进行了修改，这种修改涉及到表中的全部数据行，同时另一个事务b也向表中 插入一行。那么，事务a的用户会发现表中<strong>还有一行</strong>数据没有修改，就好像发生了幻觉一样。</p> <h3 id="丢失更新"><a href="#丢失更新" class="header-anchor">#</a> 丢失更新</h3> <p>（Lost Update）两个事务同时写同一条记录。事务 A 先写，事务 B 后写（B 不知道 A 写），当 B 提交数据后， 其写结果覆盖了 A 的写结果，导致事务 A 更新丢失。</p> <h2 id="隔离级别"><a href="#隔离级别" class="header-anchor">#</a> 隔离级别</h2> <p>表示并发事务对同一资源读取的隔离程度，<strong>由低到高</strong>依次是：</p> <h3 id="未提交读-read-uncommitted"><a href="#未提交读-read-uncommitted" class="header-anchor">#</a> 未提交读（READ UNCOMMITTED）</h3> <p>事务中的修改，即使没有提交，对其它事务也是可见的。</p> <ul><li>实现：无需特殊控制，不加锁即可。</li></ul> <h3 id="提交读-read-committed"><a href="#提交读-read-committed" class="header-anchor">#</a> 提交读（READ COMMITTED）</h3> <p><strong>Oracle 默认</strong>的隔离级别。一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的</p> <ul><li>实现：MVCC，<strong>每次读取</strong>数据前都生成一个 ReadView，即事务的每条sql都创建一个快照</li></ul> <h3 id="可重复读-repeatable-read"><a href="#可重复读-repeatable-read" class="header-anchor">#</a> 可重复读（REPEATABLE READ）</h3> <p><strong>MySQL 默认</strong>的隔离级别。保证在同一个事务中多次读取同一数据的结果是一样的，也就是说，其他事务的更新在这个事务中不可见。</p> <ul><li>实现：MVCC，<strong>第一次读取</strong>数据前生成一个 ReadView，即只在事务开始时创建一个快照</li></ul> <h3 id="可串行化-serializable"><a href="#可串行化-serializable" class="header-anchor">#</a> 可串行化（SERIALIZABLE）</h3> <p>强制事务串行执行，这样多个事务互不干扰，完全不会出现并发一致性问题。</p> <ul><li>实现：<strong>加锁</strong>，保证同一时间只有一个事务执行，也就是保证事务串行执行。</li></ul> <h3 id="q-各种级别能否解决一致性问题"><a href="#q-各种级别能否解决一致性问题" class="header-anchor">#</a> Q：各种级别能否解决一致性问题？</h3> <table><thead><tr><th>隔离级别</th> <th>脏读</th> <th>不可重复读</th> <th>幻读</th> <th>丢失更新</th></tr></thead> <tbody><tr><td>未提交读</td> <td>否</td> <td>否</td> <td>否</td> <td>否</td></tr> <tr><td>提交读</td> <td>能</td> <td>否</td> <td>否</td> <td>否</td></tr> <tr><td>可重复读（mysql默认）</td> <td>能</td> <td>能</td> <td>否</td> <td>能</td></tr> <tr><td>可串行化</td> <td>能</td> <td>能</td> <td>能</td> <td>能</td></tr></tbody></table> <h1 id="锁"><a href="#锁" class="header-anchor">#</a> 锁</h1> <h2 id="锁粒度"><a href="#锁粒度" class="header-anchor">#</a> 锁粒度</h2> <p>MySQL 中只有两种：<strong>行级锁</strong>、<strong>表级锁</strong></p> <p>加锁需要资源，锁操作增加系统开销。应该尽量只锁定需要修改的那部分数据，锁定的数据量越少，系统的并发程度就越高。</p> <p>选择封锁粒度时，需要在锁开销和并发程度之间做权衡</p> <h2 id="锁类型"><a href="#锁类型" class="header-anchor">#</a> 锁类型</h2> <h3 id="读写锁"><a href="#读写锁" class="header-anchor">#</a> 读写锁</h3> <ul><li>互斥锁（Exclusive），简写为 X 锁，又称写锁。</li> <li>共享锁（Shared），简写为 S 锁，又称读锁。</li></ul> <p>限制：</p> <ol><li>事务对数据A加了X锁，就能<strong>读和写</strong>A，加锁期间其他事务不能对A加<strong>任何锁</strong></li> <li>事务对A加了S锁，<strong>可以读但不能写</strong>A，加锁期间其他事务还能对A加S锁，但不能加X锁</li></ol> <p>兼容关系：</p> <table><thead><tr><th style="text-align:center;"></th> <th style="text-align:center;">X</th> <th style="text-align:center;">S</th></tr></thead> <tbody><tr><td style="text-align:center;">X</td> <td style="text-align:center;">不能</td> <td style="text-align:center;">不能</td></tr> <tr><td style="text-align:center;">S</td> <td style="text-align:center;">不能</td> <td style="text-align:center;">能</td></tr></tbody></table> <h3 id="意向锁"><a href="#意向锁" class="header-anchor">#</a> 意向锁</h3> <p>使用意向锁（Intention Locks）更容易地支持多粒度封锁。</p> <p>背景：在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，非常耗时。</p> <p>意向锁在原来的 X/S 锁之上引入了 IX/IS， 都是<strong>表锁</strong>，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。遵守两个规定：</p> <ul><li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</li> <li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</li></ul> <p>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用整个表或者表中某一行的锁（不用遍历每行），因此事务 T 加 X 锁失败。</p> <p>兼容关系：</p> <table><thead><tr><th style="text-align:center;"></th> <th style="text-align:center;">X</th> <th style="text-align:center;">IX</th> <th style="text-align:center;">S</th> <th style="text-align:center;">IS</th></tr></thead> <tbody><tr><td style="text-align:center;">X</td> <td style="text-align:center;">×</td> <td style="text-align:center;">×</td> <td style="text-align:center;">×</td> <td style="text-align:center;">×</td></tr> <tr><td style="text-align:center;">IX</td> <td style="text-align:center;">×</td> <td style="text-align:center;"></td> <td style="text-align:center;">×</td> <td style="text-align:center;"></td></tr> <tr><td style="text-align:center;">S</td> <td style="text-align:center;">×</td> <td style="text-align:center;">×</td> <td style="text-align:center;"></td> <td style="text-align:center;"></td></tr> <tr><td style="text-align:center;">IS</td> <td style="text-align:center;">×</td> <td style="text-align:center;"></td> <td style="text-align:center;"></td> <td style="text-align:center;"></td></tr></tbody></table> <ul><li>任意 IS/IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁；</li> <li>X锁与所有锁不兼容</li> <li>这里兼容关系针对的是<strong>表级锁</strong>，而表级的 IX 锁和行级的 X 锁兼容</li></ul> <p>从读写角度又可分为悲观锁和乐观锁：</p> <h3 id="悲观锁"><a href="#悲观锁" class="header-anchor">#</a> 悲观锁</h3> <p>使用DB锁机制，读/写完就锁，直到提交事务。长事务来说可能导致系统性能差</p> <h3 id="乐观锁"><a href="#乐观锁" class="header-anchor">#</a> 乐观锁</h3> <p>假设不会并发冲突，只在提交时检查。实现：版本号机制或CAS算法</p> <h2 id="封锁协议"><a href="#封锁协议" class="header-anchor">#</a> 封锁协议</h2> <h3 id="_1-三级封锁协议"><a href="#_1-三级封锁协议" class="header-anchor">#</a> 1.三级封锁协议</h3> <p>其实就是制定加锁规则来控制并发</p> <table><thead><tr><th></th> <th>一级封锁协议</th> <th>二级封锁协议</th> <th>三级封锁协议</th></tr></thead> <tbody><tr><td></td> <td>事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。</td> <td>在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完<strong>马上</strong>释放 S 锁。</td> <td>在二级的基础上，要求读取数据 A 时必须加 S 锁，直到<strong>事务结束</strong>了才能释放 S 锁。</td></tr> <tr><td>解决并发问题</td> <td>解决丢失修改</td> <td>解决读脏数据</td> <td>解决不可重复读</td></tr> <tr><td>解释</td> <td>因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。</td> <td>因为如果事务T1在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么另一个事务T2就不能再加 S 锁了，也就是不会读入数据。</td> <td>因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。</td></tr></tbody></table> <img src="images/数据库/image-20191207220440451.png" alt="img" style="zoom:50%;"> <img src="images/数据库/154389714-e4ad5d38-5b1d-48df-b8f6-ea010da9e60b.png" alt="image" style="zoom:50%;"> <img src="images/数据库/image-20191207221313819.png" alt="img" style="zoom:50%;"> <h3 id="_2-两段锁协议"><a href="#_2-两段锁协议" class="header-anchor">#</a> 2.两段锁协议</h3> <p>加锁和解锁分为两个阶段进行。也就是说，事务的<strong>行锁是在需要的时候才加上，但并不会立即释放，而是等到事务结束才全部释放</strong></p> <p>事务遵循两段锁协议是保证可串行化调度的<strong>充分不必要</strong>条件。</p> <blockquote><p>可串行化调度：通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。</p></blockquote> <p>例如以下操作满足两段锁协议，它是可串行化调度。</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code>lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>以下操作不满足两段锁协议，但它还是可串行化调度</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code>lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="mysql-隐式与显式锁定"><a href="#mysql-隐式与显式锁定" class="header-anchor">#</a> MySQL 隐式与显式锁定</h2> <p>MySQL 的存储引擎 <strong>InnoDB 采用两段锁协议</strong>，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为<strong>隐式锁定</strong>。</p> <p>InnoDB 也可以使用特定的语句进行<strong>显式锁定</strong>：</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token comment"># ?为查询条件</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token keyword">table</span> <span class="token keyword">WHERE</span> ? <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share</span> <span class="token keyword">mode</span><span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token keyword">table</span> <span class="token keyword">WHERE</span> ? <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h1 id="多版本并发控制-mvcc"><a href="#多版本并发控制-mvcc" class="header-anchor">#</a> 多版本并发控制（MVCC）</h1> <p>是 MySQL 的 存储引擎 <strong>InnoDB</strong>实现隔离级别的一种<strong>具体方式</strong>，用于实现提交读和可重复读</p> <h2 id="基本思想"><a href="#基本思想" class="header-anchor">#</a> 基本思想</h2> <p>读写锁中读和写操作仍然是互斥的，而 MVCC 利用了多版本的思想，写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系（类似CopyOnWrite）</p> <h2 id="版本号"><a href="#版本号" class="header-anchor">#</a> 版本号</h2> <ul><li>TRX_ID：每个事务的唯一id，在事务开始时向 InnoDB 的事务系统申请的，<strong>严格递增</strong></li></ul> <h2 id="undo-日志链"><a href="#undo-日志链" class="header-anchor">#</a> Undo 日志链</h2> <p>MVCC 的多版本指的是多个版本的<strong>快照</strong>，存储在 <strong>Undo 日志链</strong>中，该日志通过回滚指针<strong>ROLL_PTR</strong> 把一个数据行的所有快照连接起来。</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token comment"># 例如在 MySQL 创建一个表 t，包含主键 id 和一个字段 x。我们先插入一个数据行，然后对该数据行执行两次更新操作。</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> t<span class="token punctuation">(</span>id<span class="token punctuation">,</span> x<span class="token punctuation">)</span> <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">&quot;a&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">UPDATE</span> t <span class="token keyword">SET</span> x<span class="token operator">=</span><span class="token string">&quot;b&quot;</span> <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">UPDATE</span> t <span class="token keyword">SET</span> x<span class="token operator">=</span><span class="token string">&quot;c&quot;</span> <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>根据 MySQL 的 AUTOCOMMIT 机制，每个操作都会被当成一个事务来执行，所以上面的操作总共涉及到三个事务。</p> <p><img src="images%5C%E6%95%B0%E6%8D%AE%E5%BA%93%5Cimage-20191208164808217.png" alt="img"></p> <p>快照中除了记录事务版本号 TRX_ID 和操作之外，还记录了一个 bit 的 DEL 字段，用于标记是否被删除。</p> <p>INSERT、UPDATE、DELETE 操作会创建一个快照，并将事务版本号 TRX_ID 写入。DELETE 可以看成是一个特殊的 UPDATE，还会额外将 DEL 字段设置为 1。</p> <h2 id="readview"><a href="#readview" class="header-anchor">#</a> ReadView</h2> <p>InnoDB为<strong>每行数据</strong>维护了一个 ReadView 的undo日志链结构（图中右侧）。</p> <p>同时为<strong>每个事务</strong>维护了一个<strong>未提交的事务id列表</strong> TRX_IDs 和 <strong>两个指针</strong>：TRX_ID_MIN（数组头，表示最早的未提交事务） 和 TRX_ID_MAX（数组尾，表示最晚的未提交事务）。</p> <img src="images/数据库/9416c310e406519b7460437cb0c5c149.png" alt="img" style="zoom:50%;"> <p>当前事务在进行 <strong>SELECT</strong> 操作时，对选中的每个ReadView ，从当前版本开始（<strong>链头</strong>，假设为TRX_ID），比较 TRX_ID 与 TRX_ID_MIN 和 TRX_ID_MAX 之间的关系，判断当前事务是否可以使用该数据行快照：</p> <ul><li><p>TRX_ID &lt; TRX_ID_MIN：表示该版本是已提交事务或当前事务自己生成（在当前所有未提交事务之前进行更改的），因此当前事务可以使用这个版本。</p></li> <li><p>TRX_ID &gt; TRX_ID_MAX：表示该版本是在某些事务启动之后被更改的，而这些事务还没提交，因此当前事务不可使用。</p></li> <li><p><code>TRX_ID_MIN &lt;= TRX_ID &lt;= TRX_ID_MAX</code>：需要根据<strong>隔离级别</strong>再进行判断：</p> <ul><li><p>提交读：如果 TRX_ID 在 <strong>TRX_IDs 列表</strong> 中，则该快照不可使用（因为该数据行快照对应的事务还未提交）。否则可以使用（说明快照已经提交）。</p> <blockquote><p>注意：TRX_ID落在<code>[TRX_ID_MIN,TRX_ID_MAX]</code>区间，并不意味着TRX_ID一定存在于TRX_IDs列表。例如数组=[1,2,3,5]，4在<code>[1,5]</code>区间，却不在这个数组中。</p></blockquote></li> <li><p>可重复读：都不可以使用。</p> <blockquote><p>根据可重复读的规定：“我只读我之前提交的”</p> <p>因为如果可以使用的话，那么其它事务也可以读到这个数据行快照并进行修改，那么当前事务再去读这个数据行得到的值就会发生改变，也就是出现了不可重复读问题。</p></blockquote></li></ul></li></ul> <p>在数据行快照不可使用的情况下，需要沿着 Undo Log 的回滚指针 ROLL_PTR 找到前一个快照（TRX_ID更小的），再进行上面的判断。如果所有快照都不可见，则该数据行对当前事务不可见，查询结果不包含该行。</p> <p><a href="https://time.geekbang.org/column/article/70562" target="_blank" rel="noopener noreferrer">参考例子：https://time.geekbang.org/column/article/70562 图4<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="快照读与当前读"><a href="#快照读与当前读" class="header-anchor">#</a> 快照读与当前读</h2> <h3 id="_1-快照读"><a href="#_1-快照读" class="header-anchor">#</a> 1. 快照读</h3> <p>MVCC 的 SELECT 操作是快照中的数据，不需要进行加锁操作。</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token keyword">table</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="_2-当前读"><a href="#_2-当前读" class="header-anchor">#</a> 2. 当前读</h3> <p>隐式锁定：MVCC 其它对数据库修改的操作（INSERT、UPDATE、DELETE）需要进行加锁操作，从而读取最新的数据。</p> <blockquote><p>可以看到 MVCC 并不是完全不用加锁，而只是避免了 SELECT 的加锁操作。</p></blockquote> <p>显式锁定：在进行 SELECT 操作时，也可以强制指定进行加锁操作。数据库对以下第一个语句选中的行加 S 锁，第二个加 X 锁。</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token comment"># ?为查询条件</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token keyword">table</span> <span class="token keyword">WHERE</span> ? <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share</span> <span class="token keyword">mode</span><span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token keyword">table</span> <span class="token keyword">WHERE</span> ? <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h1 id="next-key-locks"><a href="#next-key-locks" class="header-anchor">#</a> Next-Key Locks</h1> <p>Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。</p> <blockquote><p>MVCC 不能解决幻读问题</p> <p>**即使把所有现存的记录都加上锁，还是阻止不了新插入的记录，**这也是为什么“幻读”会被单独拿出来解决的原因。</p> <p>因此需要引入Next-Key Locks 解决。</p></blockquote> <p>在可重复读级别下，使用<strong>MVCC + Next-Key Locks</strong>可以解决幻读问题。</p> <h2 id="record-locks"><a href="#record-locks" class="header-anchor">#</a> Record Locks</h2> <p>行锁。注意【锁某行】只是一种简称，本质上<strong>锁定的是某行数据的索引</strong>，而不是这行数据本身。</p> <p>行锁与行锁之间<strong>互斥</strong>。</p> <p>如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。</p> <p>例如：精确匹配时，锁某行</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">SELECT</span> c <span class="token keyword">FROM</span> t <span class="token keyword">WHERE</span> c<span class="token operator">=</span><span class="token number">10</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="gap-locks"><a href="#gap-locks" class="header-anchor">#</a> Gap Locks</h2> <p>间隙锁。执行范围查询时，若没有命中任何索引，则锁定索引之间的<strong>间隙</strong>，是一个开区间，不包含索引本身。</p> <p>间隙锁与间隙锁之间<strong>不互斥</strong>。间隙锁冲突的只是**【往间隙中插入记录】**这个操作。</p> <p>例如当一个事务执行以下语句，就锁定<code>(11,20)</code>，其它事务就不能在 t.c 中插入 15。</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">SELECT</span> c <span class="token keyword">FROM</span> t <span class="token keyword">WHERE</span> c <span class="token operator">BETWEEN</span> <span class="token number">10</span> <span class="token operator">and</span> <span class="token number">20</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这个例子中，事务B不会不会被事务A阻塞，因为他们都加的是间隙锁(5,10)（具体见<a href="###%E5%8A%A0%E9%94%81%E8%A7%84%E5%88%99">加锁规则</a>）</p> <p><img src="images/%E6%95%B0%E6%8D%AE%E5%BA%93/7c37732d936650f1cda7dbf27daf7498.png" alt="img"></p> <h2 id="next-key-locks-2"><a href="#next-key-locks-2" class="header-anchor">#</a> Next-Key Locks</h2> <p>Record Locks + Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。</p> <p>注意是<strong>先加间隙锁</strong>，再加行锁。</p> <p>它锁定一个<strong>前开后闭</strong>区间。</p> <p>例如一个索引包含以下6个值：0、5、10、15 、20、25，那么索引就划分为以下7个区间，即Next-Key Locks分为如下七个区间：</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token punctuation">(</span><span class="token operator">-</span>∞<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span>
<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span>
<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span>
<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">]</span>
<span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">]</span>
<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">]</span>
<span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">,</span> <span class="token operator">+</span>∞<span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="加锁规则"><a href="#加锁规则" class="header-anchor">#</a> 加锁规则</h2> <p>3个原则、两个优化</p> <ul><li><p>原则1：加锁的基本单位是next-key lock。</p></li> <li><p>原则2：查找过程中访问到的对象才会加锁。</p></li> <li><p>优化1：索引上的等值查询，给唯一索引加锁（主键索引命中）时，next-key lock退化为行锁。</p></li> <li><p>优化2：索引上的等值查询，普通索引无论是否命中，或唯一索引未命中，都向右寻找区间的右端点加<strong>左闭右闭</strong>锁，即next-key lock退化为间隙锁。</p></li> <li><p>原则3：对范围查询，无论是否唯一索引，都会<strong>向右搜索</strong>（对默认升序而言）到超出范围的第一个区间端点为止。</p> <blockquote><p>如果是降序desc，则向左搜。</p> <p>这也是“next-key lock”的字面含义：找下一个key值，然后将这段区间上锁</p></blockquote></li></ul> <p>例如表t创建和初始化：</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>t<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>
  <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">`</span>c<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">`</span>d<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">`</span>c<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>c<span class="token punctuation">`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span><span class="token punctuation">;</span>

<span class="token keyword">insert</span> <span class="token keyword">into</span> t <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">,</span><span class="token number">25</span><span class="token punctuation">,</span><span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="例一-等值查询间隙锁"><a href="#例一-等值查询间隙锁" class="header-anchor">#</a> 例一：等值查询间隙锁</h3> <p><img src="images/%E6%95%B0%E6%8D%AE%E5%BA%93/585dfa8d0dd71171a6fa16bed4ba816c.png" alt="img"></p> <p>由于表t中没有id=7的记录，所以用我们上面提到的加锁规则判断一下的话：</p> <ul><li><p>根据原则1，加锁单位是next-key lock，session A加锁范围就是(5,10]；</p></li> <li><p>同时根据优化2，这是一个等值查询(id=7)，而id=10不满足查询条件，next-key lock退化成间隙锁，因此最终加锁的范围是**(5,10)**。</p></li></ul> <p>所以，session B要往这个间隙里面插入id=8的记录会被锁住，但是session C修改id=10这行是可以的。</p> <h3 id="例二-非唯一索引等值锁"><a href="#例二-非唯一索引等值锁" class="header-anchor">#</a> 例二：非唯一索引等值锁</h3> <p><img src="images/%E6%95%B0%E6%8D%AE%E5%BA%93/465990fe8f6b418ca3f9992bd1bb5465.png" alt="img"></p> <ul><li><p>session A先要给索引c上c=5的这一行加上读锁。根据【原则1】，加锁单位是next-key lock，因此会给**(0,5]**加上next-key lock。由于只是普通索引，不适用【优化1】，因此(0,5]锁不会退化为行锁。</p></li> <li><p>要注意c是普通索引（非主键索引），根据【优化2】，需要向右遍历，查到c=10才停止。加间隙锁**(5,10)**。</p></li> <li><p>session B的update语句可以执行完成。因为根据原则2 【只有访问到的对象才会加锁】，这个查询使用覆盖索引，并不需要访问主键索引，所以【主键索引上没有加任何锁】</p></li> <li><p>但session C要插入一个(7,7,7)的记录，就会被session A的间隙锁(5,10)锁住。</p></li></ul> <p>需要注意，在这个例子中，S锁<code>lock in share mode</code>只锁覆盖索引，但如果是X锁<code>for update</code>就会锁主键索引。因为 执行 for update时，系统会认为你接下来要更新数据。</p> <p>这个例子说明，<strong>锁是加在索引上的</strong>；同时，它给我们的指导是，如果你要用lock in share mode来给行加读锁避免数据被更新的话，就必须得绕过覆盖索引的优化，在查询字段中加入索引中不存在的字段。比如，将session A的查询语句改成</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token comment"># d没有索引</span>
<span class="token keyword">select</span> d <span class="token keyword">from</span> t <span class="token keyword">where</span> c<span class="token operator">=</span><span class="token number">5</span> <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share</span> <span class="token keyword">mode</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="例三-主键索引范围锁"><a href="#例三-主键索引范围锁" class="header-anchor">#</a> 例三：主键索引范围锁</h3> <p>举例之前先思考，下面两条sql，加锁范围相同吗</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">10</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t <span class="token keyword">where</span> id<span class="token operator">&gt;=</span><span class="token number">10</span> <span class="token operator">and</span> id<span class="token operator">&lt;</span><span class="token number">11</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>虽然他们逻辑上等价，但是加锁规则不同。第一句加id=10的行锁，第二句加id=10的行锁，以及(10,15]间隙锁。</p> <p><img src="images/%E6%95%B0%E6%8D%AE%E5%BA%93/30b839bf941f109b04f1a36c302aea80.png" alt="img"></p> <ul><li><p>开始执行的时候，要找到第一个id=10的行，因此本该是next-key lock(5,10]。 根据优化1， 主键id上的等值条件，退化成行锁，只加了id=10这一行的行锁。</p></li> <li><p>范围查找id&gt;10 and id&lt;11，就往右继续找，找到id=15这一行停下来，因此需要加next-key lock(10,15]。</p></li></ul> <p>所以，session A这时候锁的范围就是主键索引上，行锁id=10和next-key lock(10,15]</p> <h3 id="例四-非唯一索引范围锁"><a href="#例四-非唯一索引范围锁" class="header-anchor">#</a> 例四：非唯一索引范围锁</h3> <p>与案例三不同，where用字段c</p> <p><img src="images/%E6%95%B0%E6%8D%AE%E5%BA%93/7381475e9e951628c9fc907f5a57697a.png" alt="img"></p> <p>对范围查找c&gt;=10 and c&lt;11，先找到c=10</p> <ul><li>对c=10，由于c是普通索引，不适用【优化1】的锁退化，因此加锁next-key lock(5,10]。又由于【优化2】，加锁(10,15)</li> <li>继续向右搜索，直到c=15停止，于是加锁next-key lock(10,15]</li></ul> <p>综上加锁next-key lock范围为(5,10]和(10,15]，因此B和C失败</p> <h3 id="例五-死锁"><a href="#例五-死锁" class="header-anchor">#</a> 例五：死锁</h3> <p><img src="images/%E6%95%B0%E6%8D%AE%E5%BA%93/7b911a4c995706e8aa2dd96ff0f36506.png" alt="img"></p> <p>A在索引c上加了next-key lock(5,10] 和间隙锁(10,15)；</p> <p>B在索引c上加next-key lock(5,10]，注意next-key lock实际上<strong>分为两步</strong>：</p> <ol><li>先加间隙锁(5,10)成功（因为<strong>间隙锁之间不互斥</strong>）</li> <li>再加c=10的行锁，此时被A的next-key lock锁阻塞</li></ol> <p>A再执行插入，被B的间隙锁(5,10)阻塞，此时形成死锁。</p> <h3 id="思考题-为什么b事务会堵住"><a href="#思考题-为什么b事务会堵住" class="header-anchor">#</a> 思考题：为什么B事务会堵住？</h3> <p><img src="images/%E6%95%B0%E6%8D%AE%E5%BA%93/3a7578e104612a188a2d574eaa3bd81e.png" alt="img"></p> <p>因为是desc降序，因此向左搜索。</p> <ul><li>首先对c=20，根据【优化1】，加锁next-key lock(15,20]。根据【优化2】，锁(20,25)。</li> <li>然后对范围c&gt;15 and c&lt;20，由于是desc，查找过程在数轴上<strong>向左遍历</strong>，c从20到15，再到10才停止。根据【原则1】，遍历到c=20时锁(15,20]，c=15时锁(10,15]，c=10时锁(5,10]</li> <li>最后对c=15，根据【优化1】，加锁next-key lock(10,15]。根据【优化2】，锁(15,20)。</li></ul> <p>综上，对索引c，锁(5,25)，因此B被堵住。对于主键id，锁行id=10，15，20。</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.c780e1b6.js" defer></script><script src="/assets/js/2.f44a4f26.js" defer></script><script src="/assets/js/24.45adeb21.js" defer></script>
  </body>
</html>
