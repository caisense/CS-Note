(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{293:function(t,v,_){"use strict";_.r(v);var a=_(14),r=Object(a.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"进程和线程区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#进程和线程区别"}},[t._v("#")]),t._v(" 进程和线程区别？")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th"),t._v(" "),v("th",[t._v("进程")]),t._v(" "),v("th",[t._v("线程")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("概念")]),t._v(" "),v("td",[t._v("运行时的程序")]),t._v(" "),v("td",[t._v("是进程的子任务")])]),t._v(" "),v("tr",[v("td",[t._v("从属关系")]),t._v(" "),v("td",[t._v("一个进程可以有多个线程")]),t._v(" "),v("td",[t._v("一个线程只属于一个进程")])]),t._v(" "),v("tr",[v("td",[t._v("调度粒度")]),t._v(" "),v("td",[t._v("是操作系统调度的最小单位")]),t._v(" "),v("td",[t._v("是CPU调度的最小单位")])]),t._v(" "),v("tr",[v("td",[t._v("内存")]),t._v(" "),v("td",[t._v("有独立内存单元，进程之间互不影响")]),t._v(" "),v("td",[t._v("多个线程共享所在进程的内存，线程也有自己的内存空间")])]),t._v(" "),v("tr",[v("td",[t._v("切换开销")]),t._v(" "),v("td",[t._v("大")]),t._v(" "),v("td",[t._v("小")])]),t._v(" "),v("tr",[v("td",[t._v("通信")]),t._v(" "),v("td",[t._v("共享内存、管道、信号量、套接字socket")]),t._v(" "),v("td",[t._v("1. 共享内存（临界区）; 2. 事件（信号），如java的wait() notify()；3. 互斥量，如Synchronized、Lock")])])])]),t._v(" "),v("h1",{attrs:{id:"父进程和子进程的关系"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#父进程和子进程的关系"}},[t._v("#")]),t._v(" 父进程和子进程的关系")]),t._v(" "),v("p",[t._v("fork()会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，Linux中引入了写时复制（COW）技术，也就是只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。在fork之后exec之前两个进程用的是相同的物理空间（内存区），子进程的代码段、数据段、堆栈都是指向父进程的物理空间，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间，如果不是因为exec，内核会给子进程的数据段、堆栈段分配相应的物理空间（至此两者有各自的进程空间，互不影响），而代码段继续共享父进程的物理空间（两者的代码完全相同）。而如果是因为exec，由于两者执行的代码不同，子进程的代码段也会分配单独的物理空间。")]),t._v(" "),v("h1",{attrs:{id:"swap交换分区"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#swap交换分区"}},[t._v("#")]),t._v(" Swap交换分区")]),t._v(" "),v("p",[t._v("Linux中的一个区域，类似于Windows的虚拟内存，当内存不足时，把一部分硬盘空间虚拟成内存，解决内存容量不足的问题。")]),t._v(" "),v("p",[t._v("合理取值一般是内存的2倍")]),t._v(" "),v("h1",{attrs:{id:"程序编译"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#程序编译"}},[t._v("#")]),t._v(" 程序编译")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("程序功能的实现通常可以分为两个阶段：")])]),t._v(" "),v("li",[v("p",[t._v("静态处理阶段（static），在程序本身开始执行前的处理。通常包括：")])]),t._v(" "),v("li",[v("ul",[v("li",[t._v("翻译阶段（编译）：对源程序做各种检查（语法检查，类型检查等）和变换，将其转变为某种适宜动态执行的形式")]),t._v(" "),v("li",[t._v("连接阶段（可能）：构造出可动态运行的程序形式")]),t._v(" "),v("li",[t._v("装载阶段（可能）：把可运行程序装入运行环境，必要的处理")])])]),t._v(" "),v("li",[v("p",[t._v("动态执行阶段（run-time），指程序的实际运行期间")])]),t._v(" "),v("li",[v("p",[t._v("例：若变量x 的（绝对或相对）位置可静态确定，运行中就可以直接访问。若不能静态确定，运行中每次访问都要查表，效率就比较低")])]),t._v(" "),v("li",[v("p",[t._v("语言的“编译实现”：在静态阶段完成尽可能多的处理工作，对源程序做深入的分析和变换，生成的目标形式通常与源程序差异巨大")])])]),t._v(" "),v("h1",{attrs:{id:"amdahl定律"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#amdahl定律"}},[t._v("#")]),t._v(" Amdahl定律")]),t._v(" "),v("p",[t._v("加快某部件执行速度所获得的系统性能加速比，受限于该部件在系统中所占的比例。")]),t._v(" "),v("p",[t._v("Amdahl定律既可以用来确定系统中对性能限制最大的部件，也可以用来计算通过改进某些部件所获得的系统性能的提高。")]),t._v(" "),v("ul",[v("li",[t._v("Amdahl定律：加快某部件执行速度所获得的系统性能加速比，受限于该部件在系统中所占的比例。")]),t._v(" "),v("li",[t._v("Amdahl定律既可以用来确定系统中对性能限制最大的部件，也可以用来计算通过改进某些部件所获得的系统性能的提高。")])]),t._v(" "),v("img",{staticStyle:{zoom:"50%"},attrs:{src:"images/操作系统/未命名图片.jpg",alt:"未命名图片"}}),t._v(" "),v("img",{staticStyle:{zoom:"33%"},attrs:{src:"images/操作系统/1png.jpg",alt:"1png"}})])}),[],!1,null,null,null);v.default=r.exports}}]);