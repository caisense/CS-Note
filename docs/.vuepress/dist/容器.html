<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Docker | 个人主页</title>
    <meta name="generator" content="VuePress 1.9.9">
    
    <meta name="description" content="CZT的博客">
    
    <link rel="preload" href="/assets/css/0.styles.e8e4f3a3.css" as="style"><link rel="preload" href="/assets/js/app.c780e1b6.js" as="script"><link rel="preload" href="/assets/js/2.f44a4f26.js" as="script"><link rel="preload" href="/assets/js/22.a31f4be5.js" as="script"><link rel="prefetch" href="/assets/js/10.207c4431.js"><link rel="prefetch" href="/assets/js/11.747359fa.js"><link rel="prefetch" href="/assets/js/12.6c286f4f.js"><link rel="prefetch" href="/assets/js/13.c0822fad.js"><link rel="prefetch" href="/assets/js/14.75e13154.js"><link rel="prefetch" href="/assets/js/15.cf4291c4.js"><link rel="prefetch" href="/assets/js/16.babfb68b.js"><link rel="prefetch" href="/assets/js/17.600473bc.js"><link rel="prefetch" href="/assets/js/18.0b6e0252.js"><link rel="prefetch" href="/assets/js/19.cfc57187.js"><link rel="prefetch" href="/assets/js/20.dec901f2.js"><link rel="prefetch" href="/assets/js/21.bfa49832.js"><link rel="prefetch" href="/assets/js/23.7019856d.js"><link rel="prefetch" href="/assets/js/24.45adeb21.js"><link rel="prefetch" href="/assets/js/25.43428e77.js"><link rel="prefetch" href="/assets/js/26.f37e9ddb.js"><link rel="prefetch" href="/assets/js/27.241fb6ed.js"><link rel="prefetch" href="/assets/js/28.1bf839c4.js"><link rel="prefetch" href="/assets/js/29.bbb07d62.js"><link rel="prefetch" href="/assets/js/3.1aa3be4a.js"><link rel="prefetch" href="/assets/js/30.7ca7bc7e.js"><link rel="prefetch" href="/assets/js/4.7ac2b204.js"><link rel="prefetch" href="/assets/js/5.f702624b.js"><link rel="prefetch" href="/assets/js/6.c76c0e1e.js"><link rel="prefetch" href="/assets/js/7.414750dc.js"><link rel="prefetch" href="/assets/js/8.bc490d6c.js"><link rel="prefetch" href="/assets/js/9.0cb2026c.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e8e4f3a3.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">个人主页</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java" class="dropdown-title"><span class="title">Java</span> <span class="arrow down"></span></button> <button type="button" aria-label="Java" class="mobile-dropdown-title"><span class="title">Java</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Java基础.html" class="nav-link">
  Java基础
</a></li><li class="dropdown-item"><!----> <a href="/Java高级.html" class="nav-link">
  Java高级
</a></li><li class="dropdown-item"><!----> <a href="/Java并发.html" class="nav-link">
  Java并发
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据库" class="dropdown-title"><span class="title">数据库</span> <span class="arrow down"></span></button> <button type="button" aria-label="数据库" class="mobile-dropdown-title"><span class="title">数据库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/MySQL.html" class="nav-link">
  MySQL
</a></li><li class="dropdown-item"><!----> <a href="/数据库.html" class="nav-link">
  数据库
</a></li><li class="dropdown-item"><!----> <a href="/Redis.html" class="nav-link">
  Redis
</a></li><li class="dropdown-item"><!----> <a href="/存储.html" class="nav-link">
  存储
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java" class="dropdown-title"><span class="title">Java</span> <span class="arrow down"></span></button> <button type="button" aria-label="Java" class="mobile-dropdown-title"><span class="title">Java</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Java基础.html" class="nav-link">
  Java基础
</a></li><li class="dropdown-item"><!----> <a href="/Java高级.html" class="nav-link">
  Java高级
</a></li><li class="dropdown-item"><!----> <a href="/Java并发.html" class="nav-link">
  Java并发
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据库" class="dropdown-title"><span class="title">数据库</span> <span class="arrow down"></span></button> <button type="button" aria-label="数据库" class="mobile-dropdown-title"><span class="title">数据库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/MySQL.html" class="nav-link">
  MySQL
</a></li><li class="dropdown-item"><!----> <a href="/数据库.html" class="nav-link">
  数据库
</a></li><li class="dropdown-item"><!----> <a href="/Redis.html" class="nav-link">
  Redis
</a></li><li class="dropdown-item"><!----> <a href="/存储.html" class="nav-link">
  存储
</a></li></ul></div></div> <!----></nav>  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="docker"><a href="#docker" class="header-anchor">#</a> Docker</h1> <p>Docker是一个高效的轻量级容器化解决方案，可以让应用程序快速部署，安全运行，并且使其更容易跨环境迁移和管理。</p> <p>Docker 可以为应用程序提供一个可复用的容器，从而可以在同一操作系统中和不同操作系统中部署应用，实现跨平台应用开发。它可以简化应用的部署，提高性能，确保应用程序的完整性和可靠性，降低运维成本。</p> <p>优点：</p> <ol><li>节约资源：通过分割物理机的硬件资源，将其抽象出来，在需要的时候为不同的容器提供资源，这样就能减小磁盘和内存的开销；</li> <li>轻量级：Docker容器本身只有几百兆的大小，而且不需要安装宿主操作系统，能够极大地缩小应用程序启动时间；</li> <li>灵活性：支持跨平台的部署，可以更灵活的部署应用程序和微服务；</li> <li>弹性：可以更加简单的增加节点，并能够实现服务的弹性扩容和缩容；</li> <li>安全性：根据容器隔离，可以避免恶意攻击，提高应用程序的安全性；</li> <li>可重复性：可以在任何地方重复利用，从而大大减少了管理时间和成本；</li> <li>可移植性：可以在开发环境和生产环境之间更加容易的移植。</li></ol> <h2 id="原理"><a href="#原理" class="header-anchor">#</a> 原理</h2> <p>说起Docker，基本上就是指容器。容器被称为轻量级的虚拟化技术，实际上是不准确的。确切地说，容器是一种对进程进行隔离的运行环境。</p> <blockquote><p>本文提到的进程、Docker等概念或软件均以Linux平台为准。</p> <p>我们知道进程是Linux操作系统执行任务的最小单元，一个时间同步服务是一个进程，一个Java服务是一个进程，一个Nginx服务是一个主进程+若干工作进程，总之，把一个系统比作一个办公室，进程就是一个个打工人：正常情况下，一个进程是能<strong>感知到其他进程</strong>的存在的，正如一个打工人放眼望去，办公室里还坐着一群其他打工人。进程的唯一标识是进程ID，用数字1、2、3……表示，好比打工人的工牌号，大家都各不一样。</p> <p>而容器技术首先要解决的就是进程的<strong>隔离</strong>，即一个进程在运行的时候看不到其他进程。如何让一个打工人在工作时看不到其他打工人呢？方法是给这个打工人带一个VR眼镜，于是他看到的不是一个真实的办公室，而是一个虚拟的办公室。在这个虚拟办公室中，只有他一个打工人，没有别人。在Linux系统中，对一个进程进行隔离，主要是通过<strong>Namespace</strong>和<strong>Cgroup</strong>两大机制实现的。一个被隔离的进程，操作系统也会正常分配进程ID，比如12345，但是隔离进程自己看到的ID总是1，好比打工人的工牌是12345，但他自己通过VR眼镜看到的工牌号却是1，感觉自己是1号员工似的。</p> <p>例如：制作一个Docker镜像，然后以Docker模式启动这个Python服务程序，再看看进程ID，从进程自己的视角看，它看到的进程ID总是<code>1</code>，并且，用<code>/ps</code>看不到其他进程，只能看到自己。再用<code>/ls</code>看一下磁盘，看到的也不是系统的根目录，而是Docker给挂载的一个虚拟的文件系统。但其实从操作系统看，这个Docker进程和其他进程一样，也有一个唯一的进程ID为<code>10475</code>。</p></blockquote> <p>一个容器进程本质上是一个运行在沙盒中的<strong>隔离进程</strong>，由Linux系统本身负责隔离，Docker只是提供了一系列工具，帮助我们设置好隔离环境后，启动这个进程。</p> <p>1、最基本的隔离就是进程之间看不到彼此，这是由Linux的<strong>Namespace</strong>机制实现的。进程隔离的结果就是以隔离方式启动的进程看到的自身进程ID总是1，且看不到系统的其他进程。</p> <p>2、第二种隔离就是隔离系统真实的文件系统。Docker利用Linux的<strong>mount</strong>机制，给每个隔离进程挂载了一个虚拟的文件系统，使得一个隔离进程只能访问这个虚拟的文件系统，无法看到系统真实的文件系统。至于这个虚拟的文件系统应该长什么样，这就是制作Docker镜像要考虑的问题。比如我们的Python程序要正常运行，需要一个Python3解释器，需要把用到的第三方库如<code>psutil</code>引入进来，这些复杂的工作被简化为一个<code>Dockerfile</code>，再由Docker把这些运行时的依赖打包，就形成了Docker镜像。我们可以把一个Docker镜像看作一个zip包，每启动一个进程，Docker都会自动解压zip包，把它变成一个虚拟的文件系统。</p> <p>3、第三种隔离就是网络协议栈的隔离，这个最不容易理解。</p> <p>我们举个例子：在Docker中运行<code>docker run redis:latest</code>，然后在宿主机上写个程序连接<code>127.0.0.1:6379</code>，是无法连接到Redis的，因为Redis虽然监听<code>127.0.0.1:6379</code>这个端口，但Linux可以为进程隔离网络，Docker默认启动的Redis进程拥有自己的网络名字空间，与宿主机不同：</p> <div class="language-ascii line-numbers-mode"><pre class="language-text"><code>┌──────────────┐ ┌─────────────────────────┐
│redis:        │ │app:                     │
│  listen: 6379│ │  connect: 127.0.0.1:6379│
├──────────────┤ ├─────────────────────────┤
│127.0.0.1:6379│ │        127.0.0.1        │
└──────────────┘ └─────────────────────────┘
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>要让宿主机访问到Redis，可以用<code>-p 6379:6379</code>把Redis进程的端口号映射到宿主机，从而在宿主机上访问Redis：</p> <div class="language-ascii line-numbers-mode"><pre class="language-text"><code>┌──────────────┐ ┌─────────────────────────┐
│redis:        │ │app:                     │
│  listen: 6379│ │  connect: 127.0.0.1:6379│
├──────────────┤ ├─────────────────────────┤
│127.0.0.1:6379│ │     127.0.0.1:6379      │
└──────────────┘ └─────────────────────────┘
            │                     ▲
            │                     │
            └─────────────────────┘
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>因此，在Linux的网络名字空间隔离下，Redis进程和宿主机进程看到的IP地址<code>127.0.0.1</code>表面上一样，但实际上是不同的网络接口。</p> <p>我们再看一个更复杂的例子。如果我们要运行ZooKeeper和Kafka，先启动ZooKeeper：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>docker run -p 2181:2181 zookeeper:latest
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>再启动Kafka，发现Kafka是无法连接ZooKeeper的，原因是，Kafka试图连接的<code>127.0.0.1:2181</code>在它自己的网络接口上并不存在：</p> <div class="language-ascii line-numbers-mode"><pre class="language-text"><code>┌──────────────┐ ┌──────────────┐ ┌─────────────────────────────┐
│zookeeper:    │ │kafka:        │ │Host                         │
│  listen: 2181│ │  listen: 9092│ │                             │
├──────────────┤ ├──────────────┤ ├──────────────┬──────────────┤
│127.0.0.1:2181│ │127.0.0.1:9092│ │127.0.0.1:9092│127.0.0.1:2181│
└──────────────┘ └──────────────┘ └──────────────┴──────────────┘
            │                │                ▲              ▲
            │                └────────────────┘              │
            └────────────────────────────────────────────────┘
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>必须连接到ZooKeeper的<code>IP:2181</code>或者宿主机的<code>IP:2181</code>。直接指定IP并不是一个好的方式，我们应该利用Docker Compose，把ZooKeeper和Kafka运行在同一个网络名字空间里（例如上图，host可以是主机，或者某个容器），并通过<code>{hostname}:{端口号}</code>来访问ZooKeeper端口，让Docker自动把zookeeper名字解析为动态分配的IP地址。<code>docker-compose.yml</code>参考配置如下：</p> <div class="language-yaml line-numbers-mode"><pre class="language-yaml"><code><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">&quot;3&quot;</span>
<span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">zookeeper</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> confluentinc/cp<span class="token punctuation">-</span>zookeeper<span class="token punctuation">:</span>7.3.0
    <span class="token key atrule">hostname</span><span class="token punctuation">:</span> zookeeper
    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> zookeeper
    <span class="token key atrule">environment</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> ALLOW_ANONYMOUS_LOGIN=yes
      <span class="token punctuation">-</span> ZOOKEEPER_CLIENT_PORT=2181  <span class="token comment"># 端口2181</span>
      <span class="token punctuation">-</span> ZOOKEEPER_TICK_TIME=2000

  <span class="token key atrule">kafka</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> confluentinc/cp<span class="token punctuation">-</span>kafka<span class="token punctuation">:</span>7.3.0
    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> kafka
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">&quot;9092:9092&quot;</span>  <span class="token comment"># 绑定容器的9092端口到主机的9092端口</span>
    <span class="token key atrule">depends_on</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> zookeeper
    <span class="token key atrule">environment</span><span class="token punctuation">:</span>
      <span class="token key atrule">KAFKA_BROKER_ID</span><span class="token punctuation">:</span> <span class="token number">1</span>
      <span class="token key atrule">KAFKA_ZOOKEEPER_CONNECT</span><span class="token punctuation">:</span> <span class="token string">'zookeeper:2181'</span>  <span class="token comment"># zk连接使用'{hostname}:{端口号}'</span>
      <span class="token key atrule">KAFKA_LISTENER_SECURITY_PROTOCOL_MAP</span><span class="token punctuation">:</span> PLAINTEXT<span class="token punctuation">:</span>PLAINTEXT<span class="token punctuation">,</span>PLAINTEXT_INTERNAL<span class="token punctuation">:</span>PLAINTEXT
      <span class="token key atrule">KAFKA_ADVERTISED_LISTENERS</span><span class="token punctuation">:</span> PLAINTEXT<span class="token punctuation">:</span>//localhost<span class="token punctuation">:</span><span class="token number">9092</span><span class="token punctuation">,</span>PLAINTEXT_INTERNAL<span class="token punctuation">:</span>//kafka<span class="token punctuation">:</span><span class="token number">29092</span>
      <span class="token key atrule">KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR</span><span class="token punctuation">:</span> <span class="token number">1</span>
      <span class="token key atrule">KAFKA_TRANSACTION_STATE_LOG_MIN_ISR</span><span class="token punctuation">:</span> <span class="token number">1</span>
      <span class="token key atrule">KAFKA_TRANSACTION_STATE_LOG_REPLICATION_FACTOR</span><span class="token punctuation">:</span> <span class="token number">1</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><h2 id="docker-compose"><a href="#docker-compose" class="header-anchor">#</a> docker-compose</h2> <p>两种方式可以暴露容器的端口：ports和expose。</p> <p>ports暴露容器端口到主机的任意端口或指定端口，不管是否指定主机端口，使用ports都会将端口暴露给主机。</p> <div class="language-yaml line-numbers-mode"><pre class="language-yaml"><code><span class="token key atrule">ports</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token string">&quot;80:80&quot;</span> <span class="token comment"># 绑定容器的80端口到主机的80端口</span>
  <span class="token punctuation">-</span> <span class="token string">&quot;9000:8080&quot;</span> <span class="token comment"># 绑定容器的8080端口到主机的9000端口</span>
  <span class="token punctuation">-</span> <span class="token string">&quot;443&quot;</span> <span class="token comment"># 绑定容器的443端口到主机的任意端口，容器启动时随机分配绑定的主机端口号</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>expose暴露容器给link到当前容器的容器，和ports的区别是，expose不会将端口暴露给主机。</p> <div class="language-yaml line-numbers-mode"><pre class="language-yaml"><code><span class="token key atrule">expose</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token string">&quot;3000&quot;</span>
  <span class="token punctuation">-</span> <span class="token string">&quot;8000&quot;</span>  <span class="token comment">#将当前容器的端口3000和8000暴露给link到本容器的容器</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="虚拟机和容器比较"><a href="#虚拟机和容器比较" class="header-anchor">#</a> 虚拟机和容器比较</h2> <table><thead><tr><th>对比项</th> <th>容器技术</th> <th>虚拟机技术</th></tr></thead> <tbody><tr><td>隔离级别</td> <td>进程级</td> <td>操作系统级</td></tr> <tr><td>隔离策略</td> <td>Cgroups</td> <td>Hypervisor</td></tr> <tr><td>系统资源</td> <td>0~5%</td> <td>5~15%</td></tr> <tr><td>启动速度</td> <td>秒级</td> <td>分钟级</td></tr> <tr><td>镜像存储</td> <td>KB-MB</td> <td>GB-TB</td></tr> <tr><td>性能</td> <td>接近宿主机本地进程</td> <td>低于宿主机</td></tr> <tr><td>集群规模</td> <td>一台宿主机可启动上千量级个容 器</td> <td>一台宿主机只能运行几十 个虚拟机</td></tr> <tr><td>高可用策略</td> <td>弹性、负载、动态</td> <td>备份、容灾、迁移</td></tr></tbody></table> <h1 id="kubernetes"><a href="#kubernetes" class="header-anchor">#</a> Kubernetes</h1> <table><thead><tr><th>概念</th> <th>描述</th></tr></thead> <tbody><tr><td>集群</td> <td>一个集群指容器运行所需要的资源组合，关联了若干服务器节点、负载均衡、网络、存储等资源。</td></tr> <tr><td>容器</td> <td>一个通过 Docker 镜像创建的运行实例，一个节点可运行多个容器。</td></tr> <tr><td>镜像</td> <td>是容器应用打包的标准格式，在部署容器化应用时可以指定镜像，镜像可以来自于 Docker Hub或者用户的私有 Registry。</td></tr> <tr><td>管理节点 （Master Node）</td> <td>是 Kubernetes 集群的<strong>管理者</strong>，运行着的服务包括 kube-apiserver、kube-scheduler、kube-controller-manager、etcd 和容器网络 等组件。一般3个管理节点组成 HA 的架构。</td></tr> <tr><td>工作节点 （Worker Node）</td> <td>是 Kubernetes 集群中承担<strong>工作负载</strong>的节点，可以是虚拟机也可以是物理机。工作节点承担实际的 Pod 调度以及与管理节点的通信等。 一个工作节点上的服务包括 Docker 运行时环境、kubelet、Kube-Proxy 以及其它一些可选的 Addon 组件。</td></tr> <tr><td>命名空间 （Namespace）</td> <td>为 Kubernetes 集群提供虚拟的<strong>隔离</strong>作用。Kubernetes 集群初始有 3 个命名空间，分别是默认命名空间 default、系统命名空间 kube-system 和 kube-public ，除此以外，管理员可以创建新的命名空间以满足需求。</td></tr> <tr><td>Pod</td> <td>是 Kubernetes 部署应用或服务的最小的<strong>基本单位</strong>。一个 Pod 封装多个应用容器（也可以只有一个容器）、存储资源、一个独立的网络 IP 以及管理控制容器运行方式的策略选项。</td></tr> <tr><td>服务（Service）</td> <td>是真实应用服务的抽象，每一个服务后面都有很多对应的容器来提供支持，通过 Kube-Proxy 的 port 和服务 selector 决定服务请求传递给后端 的容器，对外表现为一个单一访问接口，外部不需要了解后端如何运行，这给扩展或维护后端带来很大的好处。</td></tr> <tr><td>标签（labels）</td> <td>实质是附着在资源对象上的一系列 Key/Value 键值对，用于指定对用户有意义的对象的属性，标签对内核系统是没有直接意义的。标 签可以在创建一个对象的时候直接赋予，也可以在后期随时修改，每一个对象可以拥有多个标签，但 key 值必须唯一。</td></tr> <tr><td>存储卷（Volume）</td> <td>k8s 集群中的存储卷跟 Docker 的存储卷有些类似，只不过 Docker 的存储卷作用范围为一个容器，而 Kubernetes的存储卷的生命 周期和作用范围是一个 Pod。每个 Pod 中声明的存储卷由 Pod 中的所有容器共享。支持使用Persistent Volume Claim 即 PVC 这种逻辑 存储，使用者可以忽略后台的实际存储技术，具体关于 Persistent Volumn（pv）的配置由存储管理员来配置。</td></tr> <tr><td>持久存储卷</td> <td>（Persistent Volume， PV）和持久存储卷声 明（Persistent Volume Claim，PVC） PV 和 PVC 使得 Kubernetes集群具备了存储的逻辑抽象能力，使得在配置 Pod 的逻辑里可以忽略对实际后台存储技术的配置，而把这项配 置的工作交给 PV 的配置者。存储的 PV 和 PVC 的这种关系，跟计算的 Node 和 Pod 的关系是非常类似的；PV 和Node 是资源的提供者， 根据集群的基础设施变化而变化，由 Kubernetes 集群管理员配置；而 PVC 和 Pod是资源的使用者，根据业务服务的需求变化而变化，由 Kubernetes 集群的使用者即服务的管理员来配置。</td></tr> <tr><td>Ingress</td> <td>授权入站连接到达集群服务的规则集合。你可以通过 Ingress 配置提供外部可访问的 URL、负载均衡、SSL、基于名称的虚拟主机 等。用户通过 POST Ingress 资源到 API server 的方式来请求 Ingress。 Ingress controller 责实现 Ingress，通常使用负载均衡器，它还 可以配置边界路由和其他前端，这有助于以 HA 方式处理流量。</td></tr> <tr><td>镜像仓库（Registry）</td> <td>Docker 的镜像存储中心通常被称为 Registry。需要获取私有镜像时，首先需要登录 Registry，然后拉取镜像。修改过镜像后，可以再次将 镜像推送回 Registry 中去。或者通过本地构建Docker镜像再推送到Registry 中。</td></tr> <tr><td>Deployment</td> <td>部署表示用户对 Kubernetes 集群的一次更新操作。可以是创建一个新的服务，更新一个新的服务，也可以是滚动升级一个服务。 Deployment 为 Pod 和 ReplicaSet 提供了一个声明式定义 (declarative) 方法，用来替代以前的ReplicationController 更方便的管理工作 负载。</td></tr></tbody></table> <h2 id="q-有了docker为啥还需要k8s"><a href="#q-有了docker为啥还需要k8s" class="header-anchor">#</a> Q：有了Docker为啥还需要k8s？</h2> <p>Docker是一个容器编排工具，可以帮助我们管理应用程序。但如果想要管理大量的容器，就需要更为强大的编排工具，而 K8s 就是这样一个工具。</p> <p>相比于Docker，K8S有以下优势：</p> <ol><li>高可用性：可以设置Pod的副本数，保证服务的良好运行。</li> <li>自动伸缩：可根据实际情况自动伸缩，自动添加或减少节点；可以有效地根据负载情况调整Pod实例数。</li> <li>容易管理：提供了一个完整的系统来管理Docker容器，可以使DevOps开发更加高效。</li> <li>安全性：可以提供完善的安全性，包括限制访问，配置安全策略等。</li> <li>更好的传输：使用Service和Ingress提供了一个容器化的感知和管理层来实现对网络的透明性。</li></ol> <h2 id="逻辑关系"><a href="#逻辑关系" class="header-anchor">#</a> 逻辑关系</h2> <img src="images/容器/image-20230712161347196.png" alt="image-20230712161347196" style="zoom:50%;"> <ul><li>CCSE与租户一对多</li> <li>租户与集群一对多</li> <li>集群和命名空间一对多</li> <li>命名空间与应用一对多</li> <li>应用与工作负载一对多</li> <li>工作负载与容器实例一对多</li></ul> <blockquote><p>应用不是必须的，单个namespace需要部署多个应用时通过应用进行逻辑隔离</p></blockquote> <p>权限控制：</p> <ul><li>租户创建者拥有租户的最高权限</li> <li>租户创建者按组件角色给成员授权</li> <li>成员数据权限可细化到命名空间级别</li></ul> <p>资源隔离：</p> <ul><li>多个租户的数据相互隔离，互不干扰</li> <li>多个应用通过namespace隔离</li></ul> <h2 id="工作负载"><a href="#工作负载" class="header-anchor">#</a> 工作负载</h2> <h3 id="故障迁移"><a href="#故障迁移" class="header-anchor">#</a> 故障迁移</h3> <p>工作负载A设定的实例（Pod）数为四个，分布在不同的主机上。某一时刻某台主机（包含两个Pod）突然挂掉，系统自动在其他健康的节点上生成两个新实例，故障迁移保证了工作负载的实例数永远与设置的一样，保证了工作负载的高可用</p> <h3 id="弹性伸缩"><a href="#弹性伸缩" class="header-anchor">#</a> 弹性伸缩</h3> <p>垂直伸缩与水平伸缩：</p> <ul><li>垂直(Vertical)伸缩：调整节点或服务的资源配额。</li> <li>水平(Horizontal)伸缩：调整节点或服务的数量。</li></ul> <p>CCSE支持Pod<strong>自动水平伸缩</strong>，监测的指标包括<strong>CPU使用率</strong>和<strong>内存使用率</strong>。如CPU使用率超80%时，自动扩容到5个Pod，低于80%时缩容到3个。</p> <p>扩缩容性能为<strong>秒级</strong>。</p> <p><strong>局限</strong>：水平伸缩只适用于无状态服务，具有状态的服务（如MySQL具有数据状态）不适合制作容器镜像。</p> <h2 id="路由-service"><a href="#路由-service" class="header-anchor">#</a> 路由-Service</h2> <p>Service是一个抽象概念，定义了多个Pod的逻辑合集和访问Pod的策略。Service 有自己的 IP 和端口，Service 为 Pod 提供了负载均衡能力。</p> <ul><li>网络代理模式：iptables</li> <li>工作负载需要对外开放访问端口时，可以创建一个或多个Service</li> <li>访问方式：支持NodePort 和 ClusterIP，支持Headless Service</li> <li>支持四层负载的TCP/UDP协议</li> <li>集群部署时设定NodePort端口范围， NodePort端口在集群中唯一</li></ul> <p>使用：</p> <ul><li>创建工作负载时可同时创建Service，也可以单独创建Service</li> <li>删除工作负载时同时删除工作负载相关的Service</li> <li>容器端口和服务端口建议设置成一样</li></ul> <h2 id="负载均衡"><a href="#负载均衡" class="header-anchor">#</a> 负载均衡</h2> <p>Kubernetes内置服务注册、服务发现与负载均衡插件。一个工作负载会暴露两个访问地址：</p> <ul><li>内部访问：服务名 + 容器端口</li> <li>外部访问：主机ip + 主机端口</li></ul> <p><strong>Nginx-ingress</strong> 是 K8s 集群默认的负载均衡器，主要负责向外暴露服务，同时提供负载均衡等附加功能；支持 七层（HTTP）/四层（TCP/UDP）的代理功能。</p> <ul><li>K8S集群部署时会默认部署一个Nginx-ingress到kubesystem命名空间，作为集群默认的负载均衡器</li> <li>支持在一个集群的多个命名空间部署多个Nginx-ingress，支持为命名空间指定Nginx-ingress</li> <li>部署Nginx-ingress时指定对外开放的端口范围</li> <li>应用创建的ingress对象存放在应用所属命名空间指定的Nginx-ingress的命名空间中</li></ul> <h3 id="集群内访问"><a href="#集群内访问" class="header-anchor">#</a> 集群内访问</h3> <p>集群内应用的相互访问采用固定域名（应用名）的方式</p> <ul><li><p>如果两个应用在同一个命名空间，则直接使用“应用名:容器端口”；</p> <img src="images/容器/image-20230712104509673.png" alt="image-20230712104509673" style="zoom:50%;"></li> <li><p>如果两个应用跨了命名空间，则使用“应用名.命名空间:容器端口”</p> <img src="images/容器/image-20230712104526014.png" alt="image-20230712104526014" style="zoom:50%;"></li></ul> <p>当nginx容器访问tomcat应用时，是由nginx容器所在主机的iptables做负载均衡，主机的iptables由k8s的组件kube-proxy动态更新</p> <img src="images/容器/image-20230712104539607.png" alt="image-20230712104539607" style="zoom:50%;"> <h3 id="集群外访问"><a href="#集群外访问" class="header-anchor">#</a> 集群外访问</h3> <ul><li><p>应用的访问量小且不需要做HTTPS
这种情况下，可以直接使用VIP加NodePort的形式。为应用创建一个NodePort类型的Service，这样每台K8S主机上都会暴露一个主机端口（比如30000），通过主机IP加这个主机端口就可以转发到后端的Pod。K8S的Master主机上已经安装了Keepalived，VIP保证了高可用。</p> <img src="images/容器/image-20230712110347134.png" alt="image-20230712110347134" style="zoom:50%;"></li> <li><p>应用的访问量大或者需要配置HTTPS
在K8S集群外的主机上搭建一套LVS加Nginx，在Nginx上为每个应用配置SSL证书，Nginx转发到若干台K8S主机的NodePort上。</p> <p><img src="images/%E5%AE%B9%E5%99%A8/image-20230712110402403.png" alt="image-20230712110402403"></p></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.c780e1b6.js" defer></script><script src="/assets/js/2.f44a4f26.js" defer></script><script src="/assets/js/22.a31f4be5.js" defer></script>
  </body>
</html>
