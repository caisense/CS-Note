编码

# Unicode

Unicode是世界通用的长度字符集，几乎包含了目前世界上已知的所有字符，也是Java的char和String使用的编码。

unicode是定长的，每个2字节。

# Unicode 和 UTF-8 有什么区别？

utf8在unicode基础上进行了修改，是一种变长编码，用于将固定长度的unicode编码为1~4字节变长编码。

其中一个好处是**容错能力强**，经常用来作为传输编码。如果传输过程中某些字符出错，不会影响后续字符，因为`UTF-8`编码依靠高字节位来确定一个字符究竟是几个字节。

编码举例：字符串：It's 知乎日报

你看到的unicode字符集是这样的编码表

```text
I 0049
t 0074
' 0027
s 0073
  0020
知 77e5
乎 4e4e
日 65e5
报 62a5
```

每一个字符对应十六进制数字。

计算机只懂二进制，因此，严格按照unicode的方式(UCS-2)，应该这样存储：

```text
I 00000000 01001001
t 00000000 01110100
' 00000000 00100111
s 00000000 01110011
  00000000 00100000
知 01110111 11100101
乎 01001110 01001110
日 01100101 11100101
报 01100010 10100101
```

这个字符串总共占用了18个字节，但是对比中英文的二进制码，可以发现，英文前9位都是0！浪费啊，浪费硬盘，浪费流量。

怎么办？

UTF。

UTF-8是这样做的：

1. 单字节的字符，字节的第一位设为0，对于英语文本，UTF-8码只占用一个字节，和ASCII码完全相同；
2. 2. n个字节的字符(n>1)，第一个字节的前n位设为1，第n+1位设为0，后面字节的前两位都设为10，这n个字节的其余空位填充该字符unicode码，高位用0补足。这样就形成了如下的UTF-8标记位：

0xxxxxxx

110xxxxx 10xxxxxx

1110xxxx 10xxxxxx 10xxxxxx

11110xxx 10xxxxxx 10xxxxxx 10xxxxxx

111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx

1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx

... ...

于是，”It's 知乎日报“就变成了：

```text
I 01001001
t 01110100
' 00100111
s 01110011
  00100000
知 11100111 10011111 10100101
乎 11100100 10111001 10001110
日 11100110 10010111 10100101
报 11100110 10001010 10100101
```

和上边的方案对比一下，英文短了，每个中文字符却多用了一个字节。但是整个字符串只用了17个字节，比上边的18个短了一点点。

## Q：什么是零宽空格（ZWSP）？

就是完全没有宽度的字符，特点就是肉眼不可见，Unicode为`\u200B`，URLEncode结果为`%e2%80%8b` 或 `\xe2\x80\x8b`

解决方式是代码中替换掉：

```java
String str = "abc" + "\u200B";
System.out.println(str);
System.out.println(str.length()); // 4
String replace = str.replace("\u200B", "");  // 替换为空字符
System.out.println(replace);
System.out.println(replace.length());  // 3
```

打印看不出任何区别：

![image-20230909215525624](images/编码/image-20230909215525624.png)

## Q：Java的空白字符有哪些？

四种：空格，`\t`，`\r`，`\n`。

使用String的`isBlank`方法可以判断是否**只包含空白符**：

```java
" \n".isBlank(); // true，因为只包含空白字符
" Hello ".isBlank(); // false，因为包含非空白字符
```

使用`trim()`方法可以移除字符串首尾空白字符：

```java
" \tHello\r\n ".trim(); // "Hello"
```



# GB2312和GBK

GB2312 是中国规定的汉字编码，即**简体中文**的字符集编码。

GBK 是 GB2312 的扩展，它还能显示繁体中文，还有日文的假名。即**简体+繁体+日文假名**。

编码长度都是**2字节**。

> 对许多汉字而言，UTF-8编码比GBK占用空间大，这也是GBK现在还在中文网络流行的原因之一。

# Java编码转换

始终牢记：Java的`String`和`char`在内存中总是以Unicode编码表示（例如，char就是长度为2的byte数组）。

如果要转换编码格式，先转为**byte数组**作为中介，再转为其他格式的字符串：

```java
byte[] b1 = "Hello".getBytes(); // 按系统默认编码转换，不推荐
byte[] b2 = "Hello".getBytes("UTF-8"); // 按UTF-8编码转换
byte[] b2 = "Hello".getBytes("GBK"); // 按GBK编码转换
byte[] b3 = "Hello".getBytes(StandardCharsets.UTF_8); // 按UTF-8编码转换
```

再将已知编码的byte数组转为String：

```java
byte[] b = ...
String s1 = new String(b, "GBK"); // 按GBK转换
String s2 = new String(b, StandardCharsets.UTF_8); // 按UTF-8转换
```



char转byte：

```java
public static  byte[] charToBytes(char c) {
    byte[] b = new byte[2];  // 一个char占2字节
    b[0] = (byte) ((c & 0xFF00) >> 8);  // 高8位，用8个1与运算截取，再右移至低八位
    b[1] = (byte) (c & 0xFF);  // 低8位，用8个1与运算截取
    return b;
}
```

int转byte同理：

```java
public static byte[] intToByteArray(int i) {
    byte[] result = new byte[4]; // 一个int占4字节
    // 由高位到低位，分别放入byte数组0~3号
    result[0] = (byte) ((i >> 24) & 0xFF);
    result[1] = (byte) ((i >> 16) & 0xFF);
    result[2] = (byte) ((i >> 8) & 0xFF);
    result[3] = (byte) (i & 0xFF);
    return result;
}
```



# Base64编码

目的是把二进制数据变成文本格式，这样在很多文本中就可以处理二进制数据（如电子邮件协议pop3、SMTP等）。一共用到`A~Z`、`a~z`、`+`和`/`，共64个ASCII字符

缺点：效率变低，因为长度增加1/3

编码举例：3个byte数据分别是`e4`、`b8`、`ad`，按**6bit分组**得到`39`、`0b`、`22`和`2d`：

```ascii
┌───────────────┬───────────────┬───────────────┐
│      e4       │      b8       │      ad       │
└───────────────┴───────────────┴───────────────┘
┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
│1│1│1│0│0│1│0│0│1│0│1│1│1│0│0│0│1│0│1│0│1│1│0│1│
└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
┌───────────┬───────────┬───────────┬───────────┐
│    39     │    0b     │    22     │    2d     │
└───────────┴───────────┴───────────┴───────────┘
```

因为6位整数的范围总是`0~63`，所以，能用**64个字符**表示：字符`A~Z`对应索引`0~25`，字符`a~z`对应索引`26~51`，字符`0~9`对应索引`52~61`，最后两个索引`62`、`63`分别用字符`+`和`/`表示。

如果byte数组长度不是3的整数倍（因为要保证总bit数是6的整数倍），就在末尾补一个或两个`0x00`，转成字符是`=`。

## 计算编码前大小

要计算原byte数组长度，就先去掉末尾的`=`。

编码后字符数为A，则编码前Byte数=A*0.75，因为如上图所示，用4个字符表示3个Byte。

