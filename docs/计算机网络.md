TCP/IP体系协议栈

<img src="images/计算机网络/image-20230201111800003.png" alt="image-20230201111800003" />

TCP/IP体系报文结构

<img src="images/计算机网络/image-20230201111819317.png" alt="image-20230201111819317" />

# 物理层

## 通信方式

根据信息在传输线上的传送方向，分为以下三种通信方式：

- 单工通信：单向传输
- 半双工通信：双向交替传输
- 全双工通信：双向同时传输

## 带通调制

模拟信号是连续的信号，数字信号是离散的信号。带通调制把数字信号转换为模拟信号。

<img src="images/计算机网络/c34f4503-f62c-4043-9dc6-3e03288657df.jpg" alt="img" style="zoom: 50%;" />

# 数据链路层

链路（Link）：从一个节点到相邻节点的一段**物理线路**（有线或无线），而中间没有任何其他的交换节点。

数据链路（Data Link）是基于链路的。当在一条链路上传送数据时，除需要链路本身，还需要一些必要的**通信协议**来控制这些数据的传输，把实现这些协议的硬件和软件加到链路上，就构成了数据链路。

> 计算机中的网络适配器（俗称网卡）和其相应的软件驱动程序就实现了这些协议。一般的网络适配器都包含了物理层和数据链路层这两层的功能。

帧（Frame）是数据链路层对等实体之间在水平方向进行逻辑通信的**协议数据单元**（PDU）。

数据链路层的三个重要问题：封装成帧和透明传输、差错检测、可靠传输

## 三个重要问题

### 1.封装成帧和透明传输

**封装成帧**

将网络层传下来的分组添加**首部和尾部**，就成为**帧**。

首部和尾部包含有一些重要的控制信息。还用于**帧定界**，即标记帧的开始和结束，但不是每一种数据链路层协议都包含帧定界标志，如PPP协议有，而以太网V2没有：

<img src="images/计算机网络/image-20230926112548924.png" alt="image-20230926112548924"  />

以太网在帧头加上前导码（属于物理层）来做帧定界：

<img src="images/计算机网络/image-20230926113034035.png" alt="image-20230926113034035" />

> 歧义问题：帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。

为了提高数据链路层传输帧的效率，应当使帧的数据载荷的长度尽可能地大于首部和尾部的长度。

考虑到对缓存空间的需求以及差错控制等诸多因素，每一种数据链路层协议都规定了帧的数据载荷的长度上限，即最大传送单元（Maximum Transfer Unit，MTU）。例如，以太网的MTU为1500个字节。

**透明传输**

透明表示一个实际存在的事物看起来好像不存在一样。如果能够采取措施，使得数据链路层对上层交付的PDU的内容没有任何限制，就好像数据链路层不存在一样，就称其为透明传输。

### 2.差错检测

误码：实际的通信链路都不是理想的，比特在传输过程中可能会产生差错（称为**比特差错**），即比特1可能变成比特0，反之亦可能。

接收方根据发送方添加在**帧尾部**中的检错码，可以检测出帧是否出现了误码。

广泛使用**循环冗余检验**（CRC）来检查比特差错。此外还有奇偶校验。



### 3.可靠传输

不可靠传输服务：收到有误码的帧，直接丢弃，其他什么也不做；未收到发送方发送的帧，也不进行任何处理。

可靠传输服务：实现发送方发送什么，接收方最终都能正确收到。

传输过程可能出现的差错有：分组重复、分组失序、分组丢失（都出现在数据链路层的上层）和误码（出现在数据链路层和物理层）。

数据链路层保证可靠传输的协议：

- 停止等待协议
- 回退N帧协议
- 选择重传协议

## 信道分类

### 1.广播信道

一对多通信，一个节点发送的数据能够被广播信道上所有的节点接收到。

所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。

主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用 CSMA/CD 协议。

### 2.点对点信道

一对一通信。

因为不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制。



## 信道复用技术

### 1. 频分复用

频分复用的所有主机在相同的时间占用不同的频率带宽资源。

<img src="images/计算机网络/4aa5e057-bc57-4719-ab57-c6fbc861c505.png" alt="img" style="zoom:50%;" />

###  2. 时分复用

时分复用的所有主机在不同的时间占用相同的频率带宽资源。

<img src="images/计算机网络/67582ade-d44a-46a6-8757-3c1296cc1ef9.png" alt="img" style="zoom:50%;" />

### 3. 统计时分复用

是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送。

<img src="images/计算机网络/6283be2a-814a-4a10-84bf-9592533fe6bc.png" alt="img" style="zoom:50%;" />

### 4. 波分复用

光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。

### 5. 码分复用

为每个用户分配 m bit 的码片，并且所有的码片正交，对于任意两个码片 ![img](images/计算机网络/vec{S}.gif) 和 ![img](images/计算机网络/vec{T}.gif) 有

<img src="images/计算机网络/308a02e9-3346-4251-8c41-bd5536dab491.png" alt="img" style="zoom:50%;" />

为了讨论方便，取 m=8，设码片 ![img](images/计算机网络/vec{S}.gif) 为 00011011。在拥有该码片的用户发送比特 1 时就发送该码片，发送比特 0 时就发送该码片的反码 11100100。

在计算时将 00011011 记作 (-1 -1 -1 +1 +1 -1 +1 +1)，可以得到

<img src="images/计算机网络/6fda1dc7-5c74-49c1-bb79-237a77e43a43.png" alt="img" style="zoom:50%;" />

<img src="images/计算机网络/e325a903-f0b1-4fbd-82bf-88913dc2f290.png" alt="img" style="zoom:50%;" />

其中 ![img](images/计算机网络/vec{S'}.gif) 为 ![img](images/计算机网络/vec{S}.gif) 的反码。

利用上面的式子我们知道，当接收端使用码片 ![img](images/计算机网络/vec{S}.gif) 对接收到的数据进行内积运算时，结果为 0 的是其它用户发送的数据，结果为 1 的是用户发送的比特 1，结果为 -1 的是用户发送的比特 0。

码分复用需要发送的数据量为原先的 m 倍。

<img src="images/计算机网络/99b6060e-099d-4201-8e86-f8ab3768a7cf.png" alt="img" style="zoom:50%;" />

## CSMA/CD 协议

CSMA/CD 是英文缩写，表示载波监听多点接入 / 碰撞检测。

- **多点接入** ：说明这是总线型网络，许多主机以多点的方式连接到总线上。
- **载波监听** ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。
- **碰撞检测** ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。

记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，称 2τ 为 **争用期** 。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。

当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用 **截断二进制指数退避算法** 来确定。从离散的整数集合 {0, 1, .., (2k-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。

<img src="images/计算机网络/19d423e9-74f7-4c2b-9b97-55890e0d5193.png" alt="img" style="zoom:50%;" />



## PPP 协议

互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。

![img](images/计算机网络/e1ab9f28-cb15-4178-84b2-98aad87f9bc8.jpg)

PPP 的帧格式：

- F（Flag） 字段为帧的定界符，取值为：0x7E（字节角度）、01111110（比特角度）
- A 和 C 字段暂时没有意义
- FCS 字段是使用 CRC 的检验序列，计算范围是A+C+P+PDU（不包括F）
- 信息部分的长度不超过 1500

<img src="images/计算机网络/image-20230926152633733.png" alt="image-20230926152633733"  />

PPP帧的透明传输：

- 面向字节的异步链路使用字节填充来实现透明传输<img src="images/计算机网络/image-20230926153253278.png" alt="image-20230926153253278" />

  发送方填充：

  1. 将数据载荷中出现的每一个0x7E减去0x20（相当于异或0x20），然后在其前面插入转义字符0x7D
  2. 若数据载荷中原来就含有0x7D，则把每一个0x7D减去0x20，然后在其前面插入转义字符0x7D。
  3. 将数据载荷中出现的每一个ASCII码控制字符（即数值小于0x20的字符），加上0x20（相当于异或0x20，将其转换成非控制字符），然后在其前面插入转义字符0x7D。

  接收方进行与发送方相反的变换，就可以正确地恢复出未经过字节填充的原始数据载荷。

- 面向比特的同步链路使用零比特填充来实现透明传输

  <img src="images/计算机网络/image-20230926153433063.png" alt="image-20230926153433063" />

  1. 发送方：对帧的数据载荷进行扫描（一般由硬件完成），每出现5个连续的比特1，则在其后填充一个比特0。
  2. 接收方：对帧的数据载荷进行扫描，每出现5个连续的比特1时，就把其后的一个比特0删除。

## 网络适配器

要将计算机连接到以太网，需要使用相应的网络适配器（Adapter），一般简称为“网卡”。

在计算机内部，网卡与CPU之间的通信，一般是通过计算机主板上的I/O总线以**并行**传输方式进行。

网卡与外部以太网（局域网）之间的通信，一般是通过传输媒体（同轴电缆、双绞线电缆、光纤）以**串行**方式进行的。

网卡的功能：

1. 实现物理层和数据链路层功能
2. 进行并行传输和串行传输的转换

在确保网卡硬件正确的情况下，还要在操作系统中为网卡安装相应的软件（设备驱动程序），负责驱动网卡发送和接收帧。

## MAC地址

MAC 地址是链路层地址，用于**唯一标识**网络适配器（网卡）。从出厂开始，就一直不会变化。一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。交换机和路由器有更多的网络接口，所以会有多个MAC地址。

长度为**48bit**=6B，通常表示为12个16进制数，如：`00-16-EA-AE-3C-40`，其中前3个字节00-16-EA代表网络硬件制造商的编号，由IEEE分配。后3个字节AE-3C-40代表该制造商所制造的某个网络产品（如网卡）的序列号。

**风险**

如果设备在所有网络上始终使用同一个无线局域网MAC地址，久而久之网络运营商和其他网络观察者可以更轻松地将该地址与其网络活动及位置联系起来，从而进行某种用户跟踪或分析，存在安全和隐私泄露的风险。

因此，为了完善设备安全机制，这些年无线终端设备慢慢都支持了**MAC地址随机化**功能（如安卓的随机 MAC 地址、苹果的私有 WiFi 地址等），并在每个无线局域网中使用不同的MAC地址。原理是提供了一个**假 MAC 地址**替换真实的 MAC 地址。如何区分？真实MAC地址中的第二个字符是0 、4 、8 、C。

## 局域网

局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限。

主要有以太网、令牌环网、FDDI 和 ATM 等局域网技术，目前以太网占领着有线局域网市场。

可以按照网络拓扑结构对局域网进行分类：

![img](images/计算机网络/807f4258-dba8-4c54-9c3c-a707c7ccffa2.jpg)

## 以太网

以太网是一种星型拓扑结构局域网。

早期使用集线器进行连接，集线器是一种物理层设备， 作用于比特而不是帧，当一个比特到达接口时，集线器重新生成这个比特，并将其能量强度放大，从而扩大网络的传输距离，之后再将这个比特发送到其它所有接口。如果集线器同时收到两个不同接口的帧，那么就发生了碰撞。

目前以太网使用**交换机**替代了集线器，交换机是一种链路层设备，它不会发生碰撞，能根据 MAC 地址进行存储转发。

以太网帧格式：

- **类型** ：标记上层使用的协议；

- **数据** ：长度在 46-1500 之间，如果太小则需要填充；

- **FCS** ：帧检验序列，使用的是 CRC 检验方法；

  ![img](images/计算机网络/164944d3-bbd2-4bb2-924b-e62199c51b90.png)

## 交换机

交换机具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射。

正是由于这种自学习能力，因此交换机是一种即插即用设备，不需要网络管理员手动配置交换表内容。

下图中，交换机有 4 个接口，主机 A 向主机 B 发送数据帧时，交换机把主机 A 到接口 1 的映射写入交换表中。为了发送数据帧到 B，先查交换表，此时没有主机 B 的表项，那么主机 A 就发送广播帧，主机 C 和主机 D 会丢弃该帧，主机 B 回应该帧向主机 A 发送数据包时，交换机查找交换表得到主机 A 映射的接口为 1，就发送数据帧到接口 1，同时交换机添加主机 B 到接口 2 的映射。

<img src="images/计算机网络/a4444545-0d68-4015-9a3d-19209dc436b3.png" alt="img" style="zoom: 67%;" />

## 虚拟局域网

虚拟局域网可以建立与物理位置无关的逻辑组，只有在同一个虚拟局域网中的成员才会收到链路层广播信息。

例如下图中 (A1, A2, A3, A4) 属于一个虚拟局域网，A1 发送的广播会被 A2、A3、A4 收到，而其它站点收不到。

使用 VLAN 干线连接来建立虚拟局域网，每台交换机上的一个特殊接口被设置为干线接口，以互连 VLAN 交换机。IEEE 定义了一种扩展的以太网帧格式 802.1Q，它在标准以太网帧上加进了 4 字节首部 VLAN 标签，用于表示该帧属于哪一个虚拟局域网。

<img src="images/计算机网络/e98e9d20-206b-4533-bacf-3448d0096f38.png" alt="img" style="zoom: 67%;" />

# 网络层-IP

网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上只提供简单灵活的、无连接的、**尽最大努力交付**的数据报服务。

使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。

## IPV4

有 32 位，4字节。用于给IP网中每个主机（或路由器）的灭每个接口分配一个唯一的标识符。

### IPV4编址方式

IP 地址的编址方式经历了三个历史阶段：

- ABCDE分类
- 子网划分
- 无分类

**1.ABCDE分类**

两级地址，分为网络号和主机号：

```
<网络号>, <主机号>
```

<img src="images/计算机网络/cbf50eb8-22b4-4528-a2e7-d187143d57f7.png" alt="img" style="zoom:50%;" />

**2.子网划分**

主机号中拿一段作为子网号，两级 变成三级 IP 地址：

```
<网络号>, <子网号>, <主机号>
```

**子网掩码**

要使用子网，必须配置子网掩码：将网络号和子网号全置1，主机号全置0。

例如：一个 B 类地址的**默认子网掩码**为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。

> 默认子网掩码：ABC类地址，不划分子网时的子网掩码。
>
> A类：255.0.0.0；B类：255.255.0.0；C类：255.255.255.0

子网掩码的意义：告诉路由器如何划分子网，仅需要一个子网掩码就能得出子网划分的全部细节：对某个ip，将其和子网掩码**按位与**运算，结果就是子网的**网段号**（主机号全0，只剩网络号和子网号）

> 注意：外部网络看不到子网的存在。

**主机个数**

有两个地址不使用：

- 全0是该子网的**网段号**
- 全1是该子网的**广播地址**

因此可分配的主机数为`2^(m-1)-2`（主机号的位数记为m）

例题：

```
一、已知某个网络的地址为218.75.230.0，使用子网掩码255.255.255.192对其进行子网划分，请给出划分细节。
218.75.230.0    ->   218.75.230.00000000
255.255.255.192  -> 255.255.255.11000000
首先根据上图判断该地址属于C类，因此有两位用来划分子网，划分出来的子网数量是 2 ** 2 = 4 个
每个子网可分配的地址数量是 2 ** (8-2) - 2 = 62 个

二、某主机的IP地址为 180.80.77.55，子网掩码为 255.255.252.0，如该主机向其所在子网发送广播分组，则目的地址可以是
A 180.80.76.0 B 180.80.76.255 C 180.80.77.255 D 180.80.79.255
答案： D
255.255.252.0 = 11111111.11111111.11111100.00000000
180.80.77.55  = xxxxxxxx.xxxxxxxx.00111101.xxxxxxxx
因此网络位22位，主机位10位。广播则主机位全1，即:
                xxxxxxxx.xxxxxxxx.00111111.11111111 = 180.80.79.255
```



**3.无分类（1993年提出，取代前面两种）**

无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用不定长的**网络前缀**和**主机号**来对 IP 地址进行编码。记法： 

```java
{IP 地址} / {网络前缀长度}
```

例如： `128.14.35.7/20` 表示前 20 位为网络前缀。

**地址掩码**（因为没有子网的概念了，所以不叫子网掩码）：网络前缀全1，其他位全0。

主机号中，全0和全1依然不用。

无分类编址的优点：

1、**路由聚合**：一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为 **构成超网** 。

在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用**最长前缀匹配**来确定应该匹配哪一个（原因是对同一个地址，前缀越长，划分的网更小，路由更精确）。

例如，路由器R1下有5个子网，要将怎样的路由信息传给R2？

<img src="images/计算机网络/image-20230918014103351.png" alt="image-20230918014103351" />

2、可以根据客户的需要分配**适当大小**的CIDR地址块，相比于ABC类固定的空间大小，更加有效地分配IPv4的地址空间。

### IPV4数据报格式

<img src="images/计算机网络/85c05fb1-5546-4c50-9221-21f231cdc8c5.jpg" alt="img" style="zoom:67%;" />

固定长度：**20字节**。

可变长度：0~40字节（可选+填充），但要**4字节对齐**。（如上图这样画每行4字节，就是为了对齐

- **版本** : 有 4（IPv4）和 6（IPv6）两个值；

- **首部长度** : 单位是4字节，取值5~15（4bit，最大能表示15，但头部最少20字节）

- **区分服务** : 用来获得更好的服务，一般情况下不使用。

- **总长度** : 【首部 + 数据】的长度，单位字节。16bit最大65535

- **生存时间** ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器**跳数**为单位，当 TTL 为 0 时就丢弃数据报。

  <img src="images/计算机网络/image-20230920005405027.png" alt="image-20230920005405027" style="zoom:50%;" />

- **协议** ：指出携带的数据应该上交给哪个协议进行处理。

  | 协议名称 | ICMP | IGMP | TCP  | UDP  | IPV6 | OSPF |
  | -------- | ---- | ---- | ---- | ---- | ---- | ---- |
  | 字段值   | 1    | 2    | 6    | 17   | 41   | 89   |

- **首部检验和** ：检验和不包含数据部分，可以减少计算的工作量。

  数据报每经过一个**路由器**，都要重新计算检验和，因为首部中的某些字段的值（例如生存时间TTL、标志以及片偏移等）都可能发生变化

- **标识** : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。

- **片偏移** : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。

  <img src="images/计算机网络/23ba890e-e11c-45e2-a20c-64d217f83430.png" alt="img" />

### Q：什么是MTU和MSS？

- **MTU**（Maximum Transfer Unit，最大传送单元）：IP层一个网络包的最大长度，以太网中一般为 **1500** 字节；

  然而 Internet 上的路由器可能会将 MTU 设为不同的值，则整个网络需要使用一系列机制调整每个路由器的MTU以保证数据报顺利到达目的地。IPV4标准建议MTU为 **576** 字节。

- **MSS**：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 **TCP 数据载荷** 部分 的最大长度：1500-20-20=**1460字节**（ip头定长，tcp头最少20）；

### Q：什么是127.0.0.1？为什么断网了还能 ping 通 ？

**127 开头的都属于回环地址**。`127.0.0.1`是众多回环地址中的一个，是人为定义的。

断网了还能ping通？一句话概括：发送到回环地址和其他地址，走的是不一样的链路。之所以127.0.0.1叫本地回环地址，可以理解为：消息发出到这个地址上的话，就不会出外网，在本机打个转就又回来了。

**首先了解TCP发数据和ping的区别**

<img src="images/计算机网络/ping和普通发消息的关系.webp" alt="ping和普通发消息的关系" style="zoom: 33%;" />

ping基于网络层ICMP协议，因此属于应用层。linux里万物皆文件，发消息的目的地，也是个文件（文件描述符，简称fd），一个socket（即tcp连接）对应一个fd，这里就引出了socket 的概念。

使用socket前要创建，TCP 传输中创建的方式是  `socket(AF_INET, SOCK_STREAM, 0);`，其中 **AF_INET** 表示将使用 IPV4 里 host:port 的方式去解析待会你输入的网络地址。**SOCK_STREAM** 是指使用面向字节流的 TCP 协议，工作在传输层。

创建好了 socket 之后，就可以把要传输的数据写到这个文件里。调用 socket 的sendto接口的过程中进程会从用户态进入到内核态，最后会调用到 **sock_sendmsg** 方法。

然后进入传输层，带上TCP头。网络层带上IP头，数据链路层带上 MAC头等一系列操作后。进入网卡的发送队列 **ring buffer** ，顺着网卡就发出去了。这就是上图右侧的执行路径。

回到ping，过程与TCP类似，不同在于创建socket 的时候用的是 `socket(AF_INET,SOCK_RAW,IPPROTO_ICMP);`，**SOCK_RAW** 是原始套接字 ，工作在网络层， 所以构建ICMP（网络层协议）的数据，是再合适不过了。ping 在进入内核态后最后也是调用的  **sock_sendmsg** 方法，进入到网络层后加上ICMP和IP头后，数据链路层加上MAC头，也是顺着网卡发出，如上图左侧所示。

因此 本质上ping 跟 普通应用通过TCP协议发消息 在程序流程上没太大差别。这也是ping用来检测网络是否通的原因。

**然后解释为什么断网了还能ping通127.0.0.1**

前面提到，有网的情况下，ping 最后是**通过网卡**将数据发送出去的。

那么断网的情况下，网卡已经不工作了，ping 回环地址却一切正常，如下图所示：

<img src="images/计算机网络/ping回环地址.webp" alt="ping回环地址" style="zoom:33%;" />

从应用层到传输层再到网络层，路径跟ping外网的时候是几乎是一样的。到了网络层后，系统会根据目的IP，在路由表中获取对应的**路由信息**，而这其中就包含选择**哪个网卡**把消息发出。

- 当发现**目标IP是外网IP**时，会从**"真网卡"** 发出。（上上图《ping和普通发消息的关系》）
- 当发现**目标IP是回环地址**时，就会选择**本地网卡**。（上图《ping回环地址》）

> 本地网卡，其实就是个**"假网卡"**，它不像"真网卡"那样有个`ring buffer`，而是把数据推到一个叫 ` input_pkt_queue` 的 **链表** 中。这个链表，其实是所有网卡共享的，上面挂着发给本机的各种消息。消息被发送到这个链表后，会再触发一个**软中断**。
>
> 专门处理软中断的**内核线程"ksoftirqd"** ，它在收到软中断后就会立马去链表里把消息取出，然后顺着数据链路层、网络层等层层往上传递最后给到应用程序。总之就是**不走外网**。

ping 回环地址，以及通过TCP等各种协议发送数据到回环地址，都是走这条路径。整条路径从发到收，都没有经过"真网卡"。所以断网，依然能 ping 通 127.0.0.1。

### Q：ping回环地址和ping本机地址有什么区别？

没有，都是走的“假网卡”。

我们在mac里执行 `ifconfig` 。

```shell
$ ifconfig
lo0: flags=8049<UP,LOOPBACK,RUNNING,MULTICAST> mtu 16384
	inet 127.0.0.1 netmask 0xff000000
	...
en0: flags=8863<UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST> mtu 1500
	inet 192.168.31.6 netmask 0xffffff00 broadcast 192.168.31.255
    ...
```

能看到 **lo0**，表示本地回环接口，对应的地址，就是我们前面提到的 **127.0.0.1** ，也就是**回环地址**。

和 **eth0**，表示本机第一块网卡，对应的IP地址是**192.168.31.6**，管它叫**本机IP**。

为了验证，可以抓包观察，发现 ping 本机IP 跟 ping 回环地址一样，相关的网络数据，都是走的 **lo0**。

### Q：127.0.0.1 和 localhost 以及 0.0.0.0 有区别吗？

使用 nginx 时，发现用这几个 IP，都能正常访问到 nginx 的欢迎网页。但本质上还是有些区别的。

首先 localhost 并不是ip地址，而是**域名**（例如 "baidu.com"也只是域名），只不过默认会把它解析为 127.0.0.1 ，这可以在 hosts 文件中修改。所以默认情况下，使用 localhost  跟使用  127.0.0.1  确实是没区别的。

其次就是 `0.0.0.0`，执行 ping 0.0.0.0 会失败，因为它在IPV4中表示的是**无效的目标地址**，这个地址不能直接用于寻址。但在服务器的配置中listen 0.0.0.0 这个地址，就表示监听本机所有IPV4地址，因此nginx配置监听了这个地址后，访问0.0.0.0也能进入nginx服务。

## IPV6

如果没有网络地址转换NAT技术的广泛应用，IPv4早已停止发展。然而，NAT仅仅是为了延长IPv4使用寿命而采取的权宜之计，2011年所有IPV4地址就已用尽，因此需要更长的编址。

### IPV6编址方式

IPV6地址长**128**位，以16位为一组用冒号划分为8组，每组以16进制表示：

```
2001:0DB8:0000:0023:0008:0800:200C:417A
```

再使用“左侧零”省略和“连续零”压缩，可使IPv6地址的表示更加简洁：

- “左侧零”省略：两个冒号间的十六进制数中最前面的一串0可以省略不写。只能使用一次，否则导致歧义。
- “连续零”压缩：一连串连续的0可以用一对冒号取代。

<img src="images/计算机网络/image-20230925231210422.png" alt="image-20230925231210422" style="zoom:80%;" />

CIDR的斜线表示法在IPv6中仍然可用。

<img src="images/计算机网络/image-20230925231253324.png" alt="image-20230925231253324" style="zoom:80%;" />

**IPV6地址分类**

根据目的地址分类，有三种类型：

1. 单播（unicast）：传统的点对点通信

2. 多播（multicast）：一对多通信。数据报发送到一组计算机中的每一个。

   > IPv6没有采用广播的术语，而将广播看作多播的一个特例。

3. 任播（anycast）：**IPv6新增**类型。任播的终点是一组计算机，但数据报**只交付其中的一个**，通常是按照路由算法得出的距离最近的一个。

[RFC 4291]分类：

- 未指明地址：128个比特为“全0”的地址，可缩写为两个冒号“::”。不能用作目的地址，只能用于还没有配置到一个标准IPv6地址的主机用作源地址。

- 环回地址：最低比特为1，其余127个比特为“全0”，即0:0:0:0:0:0:0:1，可缩写为::1。作用与IPv4的回环地址相同。

- 多播地址：最高8比特为“全1”的地址，可记为FF00::/8。功能与IPv4多播地址相同。

- 本地链路单播地址：最高10比特为1111111010的地址，可记为FE80::/10。即使用户网络没有连接到因特网，但仍然可以使用TCP/IP协议。连接在这种网络上的主机都可以使用本地链路单播地址进行通信，但不能和因特网上的其他主机通信。

- 全球单播地址：使用得最多的一类地址。采用三级结构，为了使路由器可以更快地查找路由。

  <img src="images/计算机网络/image-20230925232921321.png" alt="image-20230925232921321" style="zoom:80%;" />



### IPV6数据报格式

<img src="images/计算机网络/image-20230925085158746.png" alt="image-20230925085158746" style="zoom: 67%;" />

基本首部：

- 版本：4bit，用来表示IP协议的版本。对于IPv6该字段固定是0110=6。

- 通信量类：8bit，该字段用来区分不同的IPv6数据报的类别或优先级。目前正在进行不同的通信量类性能的实验。

- 流标号：20bit。所有属于同一个流的IPv6数据报都具有同样的流标号。即，流标号用于资源分配。

  > **“流”**是IPV6提出的抽象概念，就是因特网上从特定源点到特定终点（单播或多播）的一系列IPv6数据报（如实时音视频数据的传送），而在这个“流”所经过的路径上的所有路由器都保证指明的服务质量。
  >
  > 流标号对于**实时音视频**数据的传送特别有用，但对于传统的非实时数据，流标号则没有用处，把流标号字段的值置为0即可。

- 有效载荷长度：16bit，它指明IPv6数据报基本首部后面的**有效载荷**（包括扩展首部和数据部分）的**字节数量**。最大取值为2^16=65535，即IPv6数据报基本首部后面的有效载荷的最大长度为**65535**字节。

- 下一个首部：8bit，该字段相当于IPv4数据报首部中的协议字段或可选字段。

  > 当IPv6数据报没有扩展首部时，该字段的作用与IPv4的协议字段一样，它的值指出了IPv6数据报基本首部后面的数据是何种协议数据单元PDU。当基本首部后面带有扩展首部时，该字段的值就标识后面第一个扩展首部的类型。

- 跳数限制：8bit，用来防止IPv6数据报在因特网中永久兜圈。最大255，经过一个路由器转发后跳数减1，跳数限制为0时丢弃。

- 源地址和目的地址：都为128bit。分别记录IPv6数据报的发送端的IPv6地址和接收端的IPv6地址。

扩展首部：

> IPv4数据报如果在其首部中使用了**选项**（即可变部分）字段，则在数据报的整个传送路径中的全部路由器，都要对选项字段进行检查，这就降低了路由器处理数据报的速度。
>
> 实际上，在路径中的路由器对很多选项是不需要检查的。因此，为了提高路由器对数据包的处理效率，IPv6把原来IPv4首部中的选项字段都放在了扩展首部中，由路径两端的**源点和终点**的主机来处理，而数据报**传送路径中的所有路由器都不处理**这些扩展首部（除逐跳选项扩展首部）。

在[RFC 2460]中定义了以下六种扩展首部：（1）逐跳选项；（2）路由选择；（3）分片；（4）鉴别；（5）封装安全有效载荷；（6）目的站选项。

每一个扩展首部都由若干个字段组成，它们的长度也各不相同。

所有扩展首部中的**第一个字段**都是**8bit的下一个首部字段**。该字段的值指出在该扩展首部后面是何种扩展首部。

当使用多个扩展首部时，应按以上的先后顺序出现。

### IPV6首部 VS IPV4首部

IPv6将IPv4数据报首部中不必要的功能取消了，使IPv6数据报基本首部中的字段数量减少到只有**8个**。但由于IPv6地址的长度扩展，使得IPv6数据报基本首部的长度增大到**40字节**。

- 取消了区分服务（服务类型）字段，因为IPv6数据报首部中的通信量类和流标号字段实现了区分服务字段的功能。
- 取消了总长度字段，改用有效载荷长度字段。这是因为IPv6数据报的首部长度是固定的40字节，只有其后面的有效载荷长度是可变的。
- 取消了标识、标志和片偏移字段，因为这些功能已包含在IPv6数据报的分片扩展首部中。
- 取消了协议字段，改用下一个首部字段。
- 取消了首部检验和字段，这样可以加快路由器处理IPv6数据报的速度。
- 取消了选项字段（可变部分），改用扩展首部来实现选项功能。
- 把生存时间TTL字段改称为跳数限制字段，这样名称与作用更加一致。

### 从IPv4向IPv6过渡

因特网上使用IPv4的路由器的数量太大，只能采用逐步演进的办法。另外，新部署的IPv6系统必须能够向后兼容，也就是IPv6系统必须能够接收和转发IPv4数据报，并且能够为IPv4数据报选择路由。

两种策略：双协议栈和隧道技术

- 双协议栈：完全过渡到IPv6之前，使一部分主机或路由器装有IPv4和IPv6两套协议栈，既可以和IPv6系统通信（采用IPv6地址），又可以和IPv4系统通信（采用IPv4地址）。双协议栈主机或路由器记为**IPv6/IPv4**，表明它具有一个IPv6地址和一个IPv4地址。通过域名系统**DNS**查询目的主机，判断对方使用哪种协议栈。
- 隧道技术：当IPv6数据报要进入IPv4网络时，将IPv6数据报**重新封装**成IPv4数据报，即整个IPv6数据报成为IPv4数据报的数据载荷，封装后在IPV4网络传输。当IPv4数据报要离开IPv4网络时，再将其数据载荷（即原IPv6数据报）取出并转发到IPv6网络。

## IP数据报发送和转发

> 因为IPV6还是草案，所以下面的IP特指IPV4。

### 主机发送IP数据报

<img src="images/计算机网络/image-20230920000901494.png" alt="image-20230920000901494" style="zoom:80%;" />

- 直接交付：同一网络中的主机可以直接通信（例如上图A和C），源主机（A）只需通过ARP协议获取目的主机（C）的MAC地址，就可将IP数据报封装成帧发送给目的主机。
- 间接交付：不同网络中的主机需要通过默认网关（路由器）来中转（例如上图A和D），源主机（A）需通过ARP协议获取到同一网络中的默认网关（S1）的MAC地址，将IP数据报封装成帧后发送给默认网关，由默认网关替主机转发。

这就引出问题，源主机如何知道目的主机是否在同一网络？通过网络前缀号：

```
A的ip为：192.168.0.0/0000001  // 只展开后8位，用/号分隔前缀和主机号
C的ip为：192.168.0.0/0000011
D的ip为：192.168.0.1/0000001
```

可以看到A和C前缀相同，因此是同一网络；A和D前缀不同，因此是不同网络。

### 路由器转发IP数据报

路由器收到数据报后：

1. 首先检查收到的IP数据报是否正确（生存时间是否结束；首部是否误码），不正确则丢弃，并向源主机发送差错报告。

2. 基于IP数据报首部中的目的IP地址在**路由表**中进行查找。若找到匹配的路由条目，则按该路由条目的指示进行转发，否则丢弃该IP数据报，并向发送该IP数据报的源主机发送差错报告。

   > 查找过程：
   >
   > <img src="images/计算机网络/image-20230920002018498.png" alt="image-20230920002018498" style="zoom:80%;" />
   >
   > 上图路由器R的路由表中第一条，给接口0配置了IP地址192.168.0.0和地址掩码255.255.255.128（网络前缀/25得出）后，路由器R就会将其按位与，得出自己的接口0与网络192.168.0.0直连。同理根据第二条得出接口1与网络192.168.0.128直连。
   >
   > 遍历路由表。用数据报**目的地址**192.168.0.129 和 路由表第一条的**地址掩码** 255.255.255.128 按位与，结果192.168.0.128，与目的网络192.168.0.0 不匹配。同理，路由表第二条匹配，因此数据报下一条为接口1。
   >
   > 本质上就是看目的地址在路由表的哪个大网里。

注意：如果目的地址是**广播地址**，则路由器不会将其转发，而是隔离在子网，子网内的所有机器都会收到该广播数据报。

> 广播地址包括受限的广播地址255.255.255.255，或者某个子网的广播地址（例如A所在子网，广播地址为192.168.0.127）
>
> 如果路由器不隔离广播数据报，整个因特网中大量的路由器都会进行广播转发，造成广播风暴。

## 路由器的结构

路由器是一种具有多个输入端口和输出端口的专用计算机，其任务是转发分组。从功能上可以划分为：路由选择和分组转发。

分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口。

交换结构的速率对于路由器的性能是至关重要，实现交换结构的三种基本方式是：通过存储器、通过总线以及通过互连网络。这三种交换结构可实现的路由器转发速率依次提高。

<img src="images/计算机网络/image-20230921013620396.png" alt="image-20230921013620396" style="zoom:80%;" />

- 如果输入的是数据分组，则根据分组首部中的目的地址进行查表转发，按照匹配条目所指示的输出端口转发；若查不到则丢弃分组。
- 如果输入的是路由报文，则把这种分组送交路由选择处理机，根据分组的内容更新路由表。

**路由表**一般仅包含从目的网络到下一跳的映射，需要对网络拓扑变化的计算最优化。

**转发表**是从路由表得出的，结构应当使查找过程最优化。（为简化，本文不区分路由表和转发表）

## 静态路由配置

指用户或网络运维人员使用路由器的相关命令给路由器**人工配置路由表**，简单、开销小、但不能及时适应网络状态（流量、拓扑等）的变化，一般只在小规模网络中采用。

![image-20230920230548028](images/计算机网络/image-20230920230548028.png)

默认路由：路由表第4条的目的网络0.0.0.0/0，其中0.0.0.0表示任意网络，而网络前缀“/0”（相应的地址掩码为0.0.0.0）是最短的网络前缀。

特定主机路由：路由表第3条中的目的网络192.168.2.1/32，其中192.168.2.1是特定主机的IP地址（最精确），而网络前缀“/32”（相应地址掩码为255.255.255.255）是最长的网络前缀。

路由器在查找转发表转发IP数据报时，遵循“最长前缀匹配”的原则，因此默认路由条目的匹配优先级最低，特定主机路由条目的匹配优先级最高。

**注意**：静态路由配置可能产生的问题：

- 路由条目配置错误，可能导致出现**路由环路**。
- **聚合路由**条目时可能引入不存在的网络，产生路由环路。

## 路由选择协议

路由选择分为静态和动态。

- 静态路由选择：即上一节的静态路由配置，一般只在小规模网络使用。
- 动态路由选择：通过路由选择协议自动获取路由信息；比较复杂、开销较大，但能较好的适应网络状态变化，适用于大规模网络。

因特网是全球最大的互联网，它所采取的路由选择协议具有三个特点：

1. 自适应：采用动态路由选择，能较好地适应网络状态的变化。
2. 分布式：各路由器通过相互间的信息交互，共同完成路由信息的获取和更新。
3. 分层次：将整个因特网划分为许多较小的**自治系统**（Autonomous System，AS）。在自治系统内部和外部采用不同类别的路由选择协议，分别进行路由选择。

路由协议可分为内部网关协议和外部网关协议，只是路由选择协议的分类名称，而不是具体的协议：

- 内部网关协议（IGP）：RIP、OSPF
- 外部网关协议（EGP）：BGP

> 网关（gateway）是RFC早期称法，现在叫做路由器（router）。

### 1.路由信息协议 RIP

RIP（Routing Information Protocol） 是一种基于**距离向量**的路由选择协议。距离用**跳数**来度量，直接相连的路由器跳数为 1，到非直连的路由器跳数为经过的路由器个数加1。跳数最多为 **15**，超过 15 表示不可达。

RIP 按**固定的时间间隔**，仅和**相邻路由器**交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址，称为收敛。

从RIP报文封装的角度看，RIP属于TCP/IP体系结构的应用层。但RIP的核心功能是路由选择，这属于网际层。

距离向量算法：

- 对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1；

- 对修改后的 RIP 报文中的每一个项目，进行以下步骤：

- 若原来的路由表中没有目的网络 N，则把该项目添加到路由表中；

- 否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新；否则什么也不做。

  > 例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新。
  >
  > 因为RIP认为跳数少的路由就是距离短的路由。

- 若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。

优点：实现简单，开销小。

缺点：最大距离为 15，限制了网络的规模。坏消息传得慢：当网络故障时，要经过比较长的时间才能将此消息传送到所有路由器。

### 2.开放最短路径优先协议 OSPF

 OSPF（Open Shortest Path First，开放最短路径优先）是为了克服 RIP 的缺点而开发出来的。开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF。由于发送IP数据报，OSPF属于**网际层**协议。

OSPF 具有以下特点：

- 向本自治系统中的所有路由器发送IP数据报，采用可靠的洪泛法）。

  > 洪泛法的要点是路由器向自己所有的邻居路由器发送链路状态更新分组，收到该分组的各路由器又将该分组转发给自己所有的邻居路由器（但其上游路由器除外），以此类推。
  >
  > 可靠是指收到链路状态更新分组后要发送确认，收到重复的更新分组无需再次转发，但要发送一次确认。

- 发送的信息就是与相邻路由器的**链路状态**：本路由器与哪些路由器相连，以及链路的**代价**（cost）。

  > 代价用费用、距离、时延、带宽等来表示。
  >
  > 例如思科路由器中OSPF计算代价的方式：100Mb/s除以链路带宽。

- 只有当链路状态发生变化时，路由器才会发送信息。

所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。

OSPF基本工作过程：

<img src="images/计算机网络/image-20230921011341636.png" alt="image-20230921011341636" style="zoom:80%;" />

为了减少洪泛发送问候分组和链路状态更新分组的数量，OSPF采用以下措施：

- 选举指定路由器（Designated Router，DR）和备用的指定路由器（Backup Designated Router，BDR）
- 所有的非DR/BDR只与DR/BDR建立邻居关系
- 非DR/BDR之间通过DR/BDR交换信息

![image-20230921012450945](images/计算机网络/image-20230921012450945.png)

OSPF划分区域：

为了使OSPF协议能够用于规模很大的网络，OSPF把一个自治系统AS再划分为若干个更小的范围，称为**区域**（area）。每个区域的规模不应太大，一般所包含的路由器不应超过**200**个。划分区域的好处就是把利用洪泛法交换链路状态信息的范围局限于每一个区域，而不是整个自治系统AS，这样就减少了整个网络上的通信量。

<img src="images/计算机网络/image-20230921012516455.png" alt="image-20230921012516455" style="zoom:80%;" />

主干路由器（Backbone Router，BBR）：R3、R4、R5、R6和R7

区域内路由器（Internal Router，IR）：区域1内的R1和R2，区域2内的R8，区域3内的R9

### 3.边界网关协议BGP

BGP（Border Gateway Protocol，边界网关协议）

AS 之间的路由选择很困难，主要是由于：

- 互联网规模很大； 
- 各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量；
- AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。

BGP 只能寻找一条比较好的路由，而不是最佳路由。

每个 AS 都必须配置 **BGP 发言人**，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。

<img src="images/计算机网络/9cd0ae20-4fb5-4017-a000-f7d3a0eb3529.png" alt="img" style="zoom:80%;" />

## 虚拟专用网 VPN

不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用**专用地址**：仅在本机构有效的 IP 地址。

> 专用地址在公网不能使用，所以不需要向因特网的管理机构申请。路由器对目的地址是专用地址的IP数据报一律不进行转发

有三个专用地址块：

- 10.0.0.0 ~ 10.255.255.255（CIDR地址块10/8）
- 172.16.0.0 ~ 172.31.255.255（CIDR地址块172.16/12）
- 192.168.0.0 ~ 192.168.255.255（CIDR地址块192.168/16）

**VPN**（Virtual Private Network，虚拟专用网）使用**公用的互联网**作为本机构各专用网之间的通信载体。VPN由VPN服务器、VPN连接（internet公共网络）、协议隧道、VPN客户机组成。

> 虚拟指的是机构内的主机仿佛在用专线通信，但实际上走的还是公网。
>
> IP数据报在因特网中可能要经过多个网络和路由器，但从逻辑上看，路由器R1和R2之间好像是一条直通的点对点链路，因此也被称为IP隧道技术。

VPN的隧道协议主要有三种：PPTP、L2TP和IPSec。其中PPTP和L2TP协议工作在OSI模型的第二层，又称为二层隧道协议。IPSec是第三层隧道协议。

举例：下图中，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 10.1.0.1，目的地址是 10.2.0.3。

1. 数据报先发送到与互联网相连的路由器 R1，R1 对内部数据进行**加密**，然后重新加上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址 194.4.5.6。
2. 路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y。

<img src="images/计算机网络/1556770b-8c01-4681-af10-46f1df69202c.jpg" alt="img" style="zoom: 50%;" />

按VPN的应用分类，可分为

1. 远程接入VPN：客户端到网关，使用公网作为骨干网在设备之间传输VPN数据流量。

2. 
   内联网VPN：网关到网关，通过公司的网络架构连接来自公司的资源。

3. 
   外联网VPN：与合作伙伴企业网构成Extranet，将一个公司与另一个公司的资源进行连接。

## 网络地址转换 NAT

用来缓解IPv4地址空间即将耗尽的问题。NAT（Network Address Translation，网络地址转换）能使大量使用内部专用地址的专用网络用户共享少量外部全球地址来访问因特网上的主机和资源。

专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来**将本地 IP 转换为全球 IP**。

**缺点：**NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。若专用网内的主机数量大于𝒏，则需要轮流使用。

**解决：**为了更有效地利用全球 IP 地址，提出了使用端口号的 NAT （也叫做网络地址与端口转换 **NAPT**）。现在常用的 NAT 转换表把**传输层的端口号**也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。

<img src="images/计算机网络/2719067e-b299-4639-9065-bed6729dbf0b.png" alt="img" style="zoom:80%;" />

上表中，内网不同的ip+端口出访，映射到同一个外网ip的不同端口。外网不同的ip+端口入访，映射到不同ip的30000端口（也可以映射到其他端口）。本质上是将ip到ip的映射，扩展到ip+端口到ip+端口的映射。

## IP多播

多播（Multicast，也称为组播）是一种实现“一对多”通信的技术。与传统单播“一对一”通信相比，多播可以极大地节省网络资源。在因特网上进行的多播，称为IP多播。

多播地址：IPV4地址分类中的**D类**地址，**只能用作目的地址**。

<img src="images/计算机网络/image-20230925001844449.png" alt="image-20230925001844449" style="zoom: 67%;" />

- 最小多播地址（低28位全0）：224.0.0.0；
- 最大多播地址（低28位全1）：239.255.255.255

用每一个D类地址来标识一个**多播组**，使用同一个IP多播地址接收IP多播数据报的所有主机就构成了一个多播组。

> 每个多播组的成员是可以随时变动的，一台主机可以随时加入或离开多播组。
>
> 多播组成员的数量和所在的地理位置也不受限制，一台主机可以属于几个多播组。

非多播组成员也可以向多播组发送IP多播数据报。与IP数据报相同，IP多播数据报也是“尽最大努力交付”。

**硬件多播**

IP多播最终还是要在局域网中进行硬件多播，需要把IPv4多播地址映射成多播MAC地址。

因特网号码指派管理局IANA，将自己从IEEE注册管理机构申请到的以太网MAC地址块中从`01-00-5E-00-00-00`到`01-00-5E-7F-FF-FF`的多播MAC地址，用于映射IPv4多播地址。这些多播MAC地址的左起前25个比特都是相同的，剩余23个比特可以任意变化，因此共有𝟐^𝟐𝟑个。

注意，由于IP多播地址（D类地址）变化位有28位，而MAC多播地址的变化位只有23位，因此有5位无法映射，即IP多播地址与多播MAC地址的映射关系**并不是一一对应**的。

<img src="images/计算机网络/image-20230925003443113.png" alt="image-20230925003443113" style="zoom: 33%;" />

因此收到IP多播数据报的主机还要**在网际层利用软件进行过滤**，具体做法是IP地址和MAC地址共同匹配，把不是主机要接收的IP多播数据报丢弃。例如下图，有三组主机，在网际层角度看有3个不同的IP多播组，而左边两组映射的MAC多播地址相同，因此在数据链路层角度看有2个不同的硬件多播组。多播数据报的目的IP地址和目的MAC地址只匹配中间的一组主机；而左边组主机多播IP不匹配，右边组多播MAC不匹配，他们都会丢弃这个多播数据报。

<img src="images/计算机网络/image-20230925004236794.png" alt="image-20230925004236794" style="zoom:80%;" />

在因特网上进行IP多播需要的两种协议

要在因特网上进行IP多播，就必须要考虑IP多播数据报经过多个多播路由器进行转发的问题。多播路由器必须根据IP多播数据报首部中的IP多播地址，将其转发到有该多播组成员的局域网。

## 移动IP

每个移动主机都有一个默认连接的网络或初始申请接入的网络，称为归属网络（Home Network）。

- 归属地址：移动主机在归属网络中的IP地址在其整个移动通信过程中是始终不变的，也称为永久地址（Permanent Address）
- 归属代理（Home Agent）：归属网络中，代表移动主机执行移动管理功能的实体。归属代理通常就是连接在归属网络上的路由器，然而它作为代理的特定功能则是在网络层完成的。

移动主机当前漫游所在的网络称为外地网络（Foreign Network），也称被访网络（Visited Network）。

- 外地代理（Foreign Agent）：在外地网络中，帮助移动主机执行移动管理功能的实体
- 转交地址：外地代理通常就是连接在外地网络上的路由器。外地代理会为移动主机提供一个临时使用的属于外地网络的转交地址（Care-of Address）。

一言蔽之，由于IP路由只关心目的地址，因此移动IP通信的问题主要在于如何找到移动主机。

<img src="images/计算机网络/image-20230925013649235.png" alt="image-20230925013649235" style="zoom: 33%;" />

1.代理发现与注册

- 移动主机A通过自己的**代理发现协议**，与外地代理建立联系，并从外地代理获得一个属于该外地网络的转交地址（例如175.1.1.1/16），同时向外地代理注册自己的永久地址和归属代理地址。
- 外地代理将移动主机A的永久地址记录在自己的**注册表**中，并向移动主机的归属代理注册该移动主机的转交地址（也可由移动主机直接进行注册）。
- 归属代理会将移动主机A的转交地址记录下来，此后归属代理会代替移动主机接收所有发送给该移动主机的IP数据报，并利用IP隧道技术将这些数据报转发给外地网络中的移动主机。
- 当移动主机不在归属网络时，归属代理会以自己的MAC地址应答所有对该移动主机的ARP请求，即归属代理采用**ARP代理**技术。为了使归属网络中其他各主机和路由器能够尽快更新各自的ARP高速缓存，归属代理还会主动发送ARP广播，并声称自己是该移动主机。这样，所有发送给该移动主机的IP数据报都会发送给归属代理。

<img src="images/计算机网络/image-20230925014806738.png" alt="image-20230925014806738" style="zoom: 80%;" />

2.固定主机向移动主机发送IP数据报

- 该数据报被路由到归属网络，归属网络代替移动主机A接收该数据报，该数据报源地址为固定主机B的IP地址，目的地址为移动主机A的永久地址 218.75.230.16/24。
- 归属代理将该数据报封装到新的数据报中，目的地址为移动主机A的转交地址175.1.1.1/16，通过IP隧道发送给外地代理。
- 外地代理从IP隧道中接收封装的IP数据报，将数据载荷（原IP数据报）解析出来，转发给移动主机A。**注意**，是在**自己的代理注册表**中查找移动主机A的永久地址对应的MAC地址，然后封装成帧发送给A。这与IP数据报正常的转发流程不同（一看A的永久地址不属于本网络，就给它转走了），否则会造成该数据报又发回A的归属网络，无限循环。

> 当外地代理和移动主机不是同一台设备时，转交地址实际上是外地代理的地址而不是移动主机的地址，转交地址既不会作为移动主机发送IP数据报的源地址，也不会作为移动主机所接收的IP数据报的目的地址。
>
> 转交地址仅仅是归属代理到外地代理的**IP隧道的出口地址**。所有使用同一外地代理的移动主机都可以共享同一个转交地址。

3.移动主机向固定主机发送IP数据报

源地址为A的永久地址218.75.230.16/24，目的地址为B的IP，按正常流程发送，由于路由器并不关心IP数据报的源地址，因此该IP数据报直接被路由到B。无需再通过归属代理转发。

移动主机可以将外地代理作为自己的**默认路由器**；也可通过**代理发现协议**从外地代理获取外地网络中其他路由器的地址，将其设为自己的默认路由器。

4.同址转交地址

移动主机需要运行额外的代理软件。外地网络也需要提供相应机制，使移动主机能够自动获取一个外地网络中的地址作为自己的IP地址和外地代理的地址，被称为同址转交地址（Co-Located Care-of Address）。

三角路由问题

即使在固定主机与移动主机之间存在一条更有效的路径，发往移动主机的IP数据报也要先发送给归属代理，造成IP数据报转发的低效。

<img src="images/计算机网络/image-20230925020608893.png" alt="image-20230925020608893" style="zoom: 67%;" />

解决：给固定主机配置一个通信代理，固定主机发送给移动主机的IP数据报，都要通过该通信代理转发。通信代理先从归属代理获取移动主机的转交地址，之后所有发送给移动主机的IP数据报，都利用转交地址直接通过IP隧道发送给移动主机的外地代理，而无须再通过移动主机的归属代理进行转发。

这种方法以增加复杂性为代价，并要求固定主机也要配置通信代理，也就是对固定主机不再透明。

# 网络层其他协议

与 IP 协议配套使用的还有三个协议

## 地址解析协议 ARP

ARP（Address Resolution Protocol）：实现由 IP 地址得到 MAC 地址。

网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在数据包的传输过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。

<img src="images/计算机网络/image-20230919005315420.png" alt="image-20230919005315420"  />

上图还需关注的是，网络层封装IP数据报时，首部填入的是源IP地址和目的IP地址。而数据链路层封装帧时，首部填入的是源MAC地址和目的MAC地址。可以想象成网络中各设备在每一层进行水平的逻辑通信，即数据链路层之间通信，网络层之间也在通信。

### Q：仅用MAC地址通信有什么问题？为什么还需要IP地址？

1）因特网中的每台路由器的路由表中就必须记录因特网上所有主机和路由器各接口的MAC地址。

手工给各路由器配置路由表几乎是不可能完成的任务，即使使用路由协议让路由器通过相互交换路由信息来自动构建路由表，也会因为路由信息需要包含海量的MAC地址信息而严重占用通信资源。

包含海量MAC地址的路由信息需要路由器具备极大的存储空间，并且会给分组的查表转发带来非常大的时延。

2）因特网的网络层使用IP地址进行寻址，就可使因特网中各路由器的路由表中的路由记录的数量大大减少，因为只需记录**部分网络**的网络地址，而不是记录每个网络中各通信设备的各接口的MAC地址。路由器收到IP数据报后，根据其首部中的目的IP地址的网络号部分，基于自己的路由表进行查表转发。

这又引出一个问题：查表转发的结果可以指明IP数据报的下一跳路由器的IP地址，但无法指明该IP地址所对应的MAC地址。因此，在数据链路层封装该IP数据报成为帧时，帧首部中的目的MAC地址字段就无法填写，该问题需要使用网际层中的地址解析协议ARP来解决。

<img src="images/计算机网络/8006a450-6c2f-498c-a928-c927f758b1d0.png" alt="img" style="zoom:80%;" />

每个主机都有一个 **ARP 高速缓存**，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过**广播**的方式发送 ARP 请求分组（封装在MAC帧中，目的地址为广播地址FF:FF:FF:FF:FF:FF），主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。

**注意**

- ARP不能跨网络使用，只用于解决**同一局域网**内的IP和MAC地址映射问题

  <img src="images/计算机网络/image-20230919013503126.png" alt="image-20230919013503126" style="zoom: 50%;" />

- ARP提出的很早，没有安全验证机制，存在**ARP欺骗和攻击**问题。



## 网际控制报文协议 ICMP

（Internet Control Message Protocol，ICMP） 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。

ICMP报文格式：

<img src="images/计算机网络/e3124763-f75e-46c3-ba82-341e6c98d862.jpg" alt="img" style="zoom:50%;" />

ICMP 报文分为差错报告报文和询问报文：

<img src="images/计算机网络/aa29cc88-7256-4399-8c7f-3cf4a6489559.png" alt="img" style="zoom:50%;" />

###  1. Ping

Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的**连通性**。

原理：通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包**往返时间**以及**丢包率**。

### 2. Traceroute

Traceroute 是 ICMP 的另一个应用，用来**跟踪**一个分组从源点到终点的路径。

由源主机向目的主机发送一连串的 IP 数据报，其中封装的是无法交付的 **UDP** 用户数据报，再由目的主机向源主机发送终点不可达差错报告报文。具体过程：

- 第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文**（值为11）**；
- 源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文**（值为11）**。
- 不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文**（值为3）**。
- 之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。

## 网际组管理协议 IGMP

IGMP（Internet Group Management Protocol）是TCP/IP体系结构网际层中的协议，其作用是让连接在本地局域网上的多播路由器知道本局域网上**是否有主机**（实际上是主机中的某个进程）**加入或退出**了某个多播组。

IGMP仅在本网络有效，使用IGMP并不能知道多播组所包含的成员数量，也不能知道多播组的成员都分布在哪些网络中。

IGMP有三种报文类型：成员报告报文、成员查询报文、离开组报文。

IGMP报文被封装在IP数据报中，协议字段=2；目的地址字段根据类型决定，但都属于IP多播地址；TTL=1，避免报文被转发到其他网络。

> 仅使用IGMP并不能在因特网上进行IP多播。连接在局域网上的多播路由器还必须和因特网上的其他多播路由器协同工作，以便把IP多播数据报用最小的代价传送给所有的多播组成员，这就需要使用多播路由选择协议。

**多播路由选择协议**的主要任务是：在多播路由器之间为每个多播组建立一个多播转发树。

- 多播转发树连接多播源和所有拥有该多播组成员的路由器。
- IP多播数据报只要沿着多播转发树进行洪泛，就能被传送到所有拥有该多播组成员的多播路由器。
- 之后，在多播路由器所直连的局域网内，多播路由器通过硬件多播，将IP多播数据报发送给该多播组的所有成员。

# 传输层-TCP

## TCP 首部格式

<img src="images/计算机网络/55dc4e84-573d-4c13-a765-52ed1dd251f9.png" alt="img" style="zoom:50%;" />

固定长度：**20字节**。

可变长度：0~40字节（选项+填充），但要**4字节对齐**。（如上图这样画每行4字节，就是为了对齐

- **源端口**：16bit，表示0~65535号端口

- **目的端口**：16bit，表示0~65535号端口

- **序号 seq** ：用于对**数据部分**字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。

  因为占32位，所以取值范围0~2^31-1。当序号到达最后一个时，下一个序号又回到0

- **确认号 ack** ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。

  取值范围也是0~2^31-1，到达最后一个回头

- **数据偏移** ：数据部分距离报文段起始处的偏移量，实际上指的是**首部的长度**（单位是4字节），取值5~15（4bit，最大能表示15，但头部最少20字节）

- **确认 ACK** ：当 ACK=1 时确认号字段ack有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1（除了FIN）。

- **同步 SYN** ：在**连接建立时**用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。

- **终止 FIN** ：用来**释放一个连接**，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。

- **窗口** ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。

- **校验和**：接收时用于判断是否误码，发送时计算填入。在下图介绍计算方法

- **选项**：长度可变，0~40字节。

  - 最大报文段长度（MSS，指TCP**数据载荷**部分长度）选项：一般认为应尽可能大，但不能超过IP分片的长度限制。TCP建立时双方将自己支持的MSS写入该字段，数据传输阶段取较小的那个MSS值。默认536，即TCP报文总长度最小为536+20=556


## 伪首部

<img src="images/计算机网络/image-20230201001326478.png" alt="image-20230201001326478" />

**发送时**

会添加伪首部，用于计算校验和

1. 将TCP首部中检验和字段的值置为0。
2. 将伪首部、TCP首部以及数据载荷这三部分划分成若干个**2字节**的字。若伪首部、TCP首部以及数据载荷这三部分的总长度不是偶数个字节，则在最后添加1个“全0”字节。
3. 对划分出的全部2字节的字进行反码算数运算求和，并将求和结果取反码。
4. 将步骤③得到的结果写入TCP首部中的检验和字段。

**接收时**

1. 给接收到的TCP报文段前面添加一个12字节的伪首部。
2. 将伪首部、TCP首部以及数据载荷这三部分划分成若干个2字节的字。
3. 对划分出的全部2字节的字进行反码算数运算求和，并将求和结果取反码。
4. 若步骤③得到的**结果为0**，则表示TCP报文段在传输过程中没有误码。否则，表示出现了误码。



## 三次握手（三报文握手）

<img src="images/计算机网络/e92d0ebc-7d46-413b-aec1-34a39602f787.png" alt="img" style="zoom:50%;" />

假设 A 为客户端，B 为服务器端。三次握手的报文**都不携带数据**。

- 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。

- A 向 B 发送连接请求报文，SYN=1，**ACK=0**（因为是**初始报文**，不需要对任何报文确认），选择一个初始的序号 x。

- B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1（因为A发来的报文不携带数据，所以期望收到下一个报文序号是x+1），同时也选择一个初始的序号 y。

- A 收到 B 的连接确认报文后，还要向 B 发出确认，ACK=1，确认号为 y+1，序号为 x+1。

  注意这是一个**普通报文**，可以携带数据。如果未携带数据则不消耗序号seq，即A发出的下一个报文seq仍为x+1。而前两个报文虽然不带数据，但都消耗一个序号。

- B 收到 A 的确认后，连接建立，双方都可以进行收发。

- 数据传送时，**ack=发送方的seq+发送方的len**。（具体见wireshark抓包一节）

  注意：带SYN、FIN的报文不同，ack=发送方的seq+发送方的len**+1**。

## 四次挥手（四报文挥手）

<img src="images/计算机网络/f87afe72-c2df-4c12-ac03-9b8d581a8af8.jpg" alt="img" style="zoom: 67%;" />

以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单（前两个报文：u为A上一个报文的序号+1，v为B的上一个报文序号+1。第三个报文：w为**半关闭状态**下B发送的上一个报文序号+1，u+1是对之前A发送释放连接报文的**重复确认**）。

并且不讨论 ACK（因为 ACK 在连接建立之后都为 1）。

- A 发送连接释放报文，FIN=1。
- B 收到之后发出确认，此时 TCP 属于**半关闭状态**，B 能向 A 发送数据但是 A 不能向 B 发送数据。
- 当 B 不再需要连接时，发送连接释放报文，FIN=1。
- A 收到后发出确认，进入 TIME-WAIT 状态，**等待 2 MSL**（最大报文存活时间）后释放连接。
- B 收到 A 的确认后**立刻**释放连接。

## Q：为什么三次握手不能简化为两次？

一句话：防止重复建立连接。

考虑情况：客户端发送的连接请求c1如果在网络中滞留，隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接c2。

但是这个滞留的连接请求c1最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器对连接c2请求的确认，因此就不会再次打开连接。

**通俗理解（全网独家！！！）**

客户端是主动方，只用两次握手就能建立**单向**连接了。但服务器是被动方，也需要一去一回两次握手建立**单向**连接，本质上总共需要四次握手才能建立双向连接。但服务器发送响应给客户端，和服务器发送建立连接的请求，这两次可以优化为一次，因此三次就足够。

## Q：为什么要四次挥手？

类似于[为什么三次握手不能简化为两次？](###Q：为什么三次握手不能简化为两次？)的通俗理解，结束双向连接也需要双方分别结束单向连接，共四次。

第一次挥手后，服务器就进入 CLOSE-WAIT 状态，是为了让服务器端发送还未传送完毕的数据。

**为何不像三次握手那样将服务器的两次握手合并成一次？**

因为此时连接已建立，应该让服务器充分利用连接。

**TIME_WAIT**

客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。两个理由：

- 确保A最后一个确认报文能够到达B。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文（超时重传），导致A一直无法关闭。
- 为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。

## Q：2MSL如何得出？

**类似问题：如何保证A发出最后一个连接释放报文，B一定能关闭？**

考虑最坏情况：A发出最后一个连接释放报文，最多1MSL到达B，如果该报文丢失，则B发起超时重传（B发出FIN也会等2MSL），最多1MSL到达A，总共经历2MSL。如果2MSL后没收到B的报文，则说明B没有超时重传，确认B已经关闭，因此A可以放心关闭。

## Q：既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？

考虑情况：如果tcp整个报文交给IP层分片，当IP层有一个超过MTU大小的数据要发送，则要进行分片，把这个数据拆分成若干个小于MTU的分片。

而IP层没有tcp的超时重传机制，只要其中一个IP分片丢失，则所有分片都要重传。则一个tcp报文的超时重传会导致下层多个IP分片的重传。

因此tcp报文的长度不应超过IP报文的最大长度

## Q：TCP的字节序是大端小端？

TCP/IP协议规定使用 **“大端”** 字节序作为网络字节序。

> Big-Endian（大端字节序）：高位字节排放在内存的低地址端，低位字节排放在内存的高地址端（这是人类读写数值的方法）；
>
> Little-Endian（小端字节序）：低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。
>
> 例如 0x1234567 的大端和小端存储如下，地址从左到右：
>
> <img src="images/计算机网络/1200.jpeg" alt="img" />

如果接收到的第一个字节作为高位字节（如上图“01”），这就要求发送时也是先发高位字节。

因此收发双方需要约定使用同样的字节序，才能正常传输。TCP就约定都用大端。

## Q：什么是SYN攻击？如何解决？

TCP 连接建立是需要三次握手，假设攻击者短时间伪造不同 IP 地址的 `SYN` 报文，服务端每接收到一个 `SYN` 报文，就进入`SYN_RCVD` 状态，但服务端发送出去的 `ACK + SYN` 报文，无法得到未知 IP 主机的 `ACK` 应答，久而久之就会**占满服务端的 SYN 接收队列（未连接队列）**，使得服务器不能为正常用户服务。

**解决**

修改 Linux 内核参数，控制队列大小和当队列满时应做什么处理。

- 当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包。控制该队列的最大值如下参数：

```
net.core.netdev_max_backlog
```

- SYN_RCVD 状态连接的最大个数：

```
net.ipv4.tcp_max_syn_backlog
```

- 超出处理能力时，对新的 SYN 直接回报 RST，丢弃连接：

```
net.ipv4.tcp_abort_on_overflow
```

## TCP可靠传输

TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。

一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下：
$$
RTTs = (1-a)*RTTs+a*RTT
$$
其中，0 ≤ a ＜ 1，RTTs 随着 a 的增加更容易受到 RTT 的影响。

超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下：
$$
RTO=RTTs+4*RTTd
$$
其中 RTTd 为偏差的加权平均值。

**【2011年 题40】**主机甲与主机乙之间已建立一个TCP连接，主机甲向主机乙发送了3个连续的TCP段，分 别包含300字节、400字节和500字节的有效载荷，第3个段的序号为900。若主机乙仅正 确接收到第1和第3个段，则主机乙发送给主机甲的确认序号是 ()

A．300     B．500     C．1200      D．1400

答案：B

TCP保证按序接收，报文1和3都接收到，缺了2，因此会要求重传2。第3个报文序号900，则根据第2个报文长度400，900-400=500，即是第2个报文的序号。期望获得该报文，则ACK=500

## TCP滑动窗口

窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。

发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。

接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。

<img src="images/计算机网络/a3253deb-8d21-40a1-aae4-7d178e4aa319.jpg" alt="img" />

##  TCP 流量控制

流量控制是为了控制发送方发送速率，保证接收方来得及接收。

接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。

##  TCP 拥塞控制

如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。

<img src="images/计算机网络/51e2ed95-65b8-4ae9-8af3-65602d452a25.jpg" alt="img" style="zoom:50%;" />

TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。

发送方需要维护一个叫做**拥塞窗口**（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。

为了便于讨论，做如下假设：

- 接收方有足够大的接收缓存，因此不会发生流量控制；
- 虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。

<img src="images/计算机网络/910f613f-514f-4534-87dd-9b4699d59d31.png" alt="img" />

### 1. 慢开始与拥塞避免

发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 ...

注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd >= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。

如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。

### 2. 快重传与快恢复

在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。

在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。

在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。

慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。

<img src="images/计算机网络/f61b5419-c94a-4df1-8d4d-aed9ae8cc6d5.png" alt="img" style="zoom: 50%;" />



# 传输层-UDP

## UDP 首部格式

<img src="images/计算机网络/d4c3a4a1-0846-46ec-9cc3-eaddfca71254.jpg" alt="img" style="zoom:50%;" />

首部字段只有 8 个字节，包括源端口、目的端口、长度（报文长度）、检验和。

- **源端口**：16bit，表示0~65535号端口

- **目的端口**：16bit，表示0~65535号端口

- **长度**：16bit，表示报文的**字节数**

- **检验和**：

伪首部：12 字节，为计算**检验和**临时添加，发送时去除。包含IP首部的一些字段。

## Q：TCP和UDP不同？ 

|                | TCP                                                          | UDP                                                          |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 面向           | 字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块） | 报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部） |
| 连接           | 面向连接                                                     | 无连接                                                       |
| 交付           | 可靠交付（不丢失，有序）                                     | 不可靠， 尽最大可能交付                                      |
| 拥塞控制       | 有                                                           | 无                                                           |
|                | 全双工                                                       |                                                              |
|                | 点对点（一对一）                                             | 一对一、一对多、多对一、多对多                               |
| 报文最大长度   | 无上限（TCP首部的序号并未限制长度）。但建议不超过IP分片限制（1500-ip头20=1480） | 65536（UDP首部的长度字段16bit）                              |
| 首部           | 不定长，20~60字节（选项部分可选）                            | 定长，8字节                                                  |
| 伪首部         | 协议位：6                                                    | 协议位：17                                                   |
| 首部的长度字段 | 4bit，指示首部长度（字节数）                                 | 2bit，指示报文长度                                           |

## Q：什么是TCP拆包、粘包？

UDP对上层（应用层）报文直接加首部处理，既不合并也不拆分，因此说UDP协议是面向报文的

而TCP面向字节流，将应用层数据视为一连串字节流，并无具体含义，编号仅是为了传输。因此发送时，可能会将有具体含义的某段字节流拆分为多个TCP段（包），称为**拆包**。反之，将某几段字节流合并为一个TCP段，称为**粘包**。

两种解决：

1. 对每个包，包开头指明实际长度
2. 将每个包封装为固定长度，不足的填充

<img src="images/计算机网络/image-20230131001118474.png" alt="image-20230131001118474" style="zoom: 50%;" />



# 应用层-HTTP

## HTTP头部

是HTTP报文的一部分

### 1.通用头

是客户端和服务器都可以使用的头部，可以在客户端、服务器和其他应用程序之间提供一些非常有用的通用功能

|    首部字段名     |                    说明                    |
| :---------------: | :----------------------------------------: |
|   Cache-Control   |               控制缓存的行为               |
|    Connection     | 控制不再转发给代理的首部字段、管理持久连接 |
|       Date        |             创建报文的日期时间             |
|      Pragma       |                  报文指令                  |
|      Trailer      |             报文末端的首部一览             |
| Transfer-Encoding |         指定报文主体的传输编码方式         |
|      Upgrade      |               升级为其他协议               |
|        Via        |            代理服务器的相关信息            |
|      Warning      |                  错误通知                  |

### 2.请求头

是请求报文特有的，它们为服务器提供了一些额外信息，比如客户端希望接收什么类型的数据

|     首部字段名      |                      说明                       |
| :-----------------: | :---------------------------------------------: |
|       Accept        |            用户代理可处理的媒体类型             |
|   Accept-Charset    |                  优先的字符集                   |
|   Accept-Encoding   |                 优先的内容编码                  |
|   Accept-Language   |             优先的语言（自然语言）              |
|    Authorization    |                  Web 认证信息                   |
|       Expect        |              期待服务器的特定行为               |
|        From         |               用户的电子邮箱地址                |
|        Host         |               请求资源所在服务器                |
|      If-Match       |              比较实体标记（ETag）               |
|  If-Modified-Since  |               比较资源的更新时间                |
|    If-None-Match    |        比较实体标记（与 If-Match 相反）         |
|      If-Range       |      资源未更新时发送实体 Byte 的范围请求       |
| If-Unmodified-Since | 比较资源的更新时间（与 If-Modified-Since 相反） |
|    Max-Forwards     |                 最大传输逐跳数                  |
| Proxy-Authorization |         代理服务器要求客户端的认证信息          |
|        Range        |               实体的字节范围请求                |
|       Referer       |            对请求中 URI 的原始获取方            |
|         TE          |                传输编码的优先级                 |
|     User-Agent      |              HTTP 客户端程序的信息              |

### 3.响应头

便于客户端提供信息，比如，客服端在与哪种类型的服务器进行交互

|     首部字段名     |             说明             |
| :----------------: | :--------------------------: |
|   Accept-Ranges    |     是否接受字节范围请求     |
|        Age         |     推算资源创建经过时间     |
|        ETag        |        资源的匹配信息        |
|      Location      |   令客户端重定向至指定 URI   |
| Proxy-Authenticate | 代理服务器对客户端的认证信息 |
|    Retry-After     |   对再次发起请求的时机要求   |
|       Server       |    HTTP 服务器的安装信息     |
|        Vary        |   代理服务器缓存的管理信息   |
|  WWW-Authenticate  |   服务器对客户端的认证信息   |

> 自定义响应头
>
> 自定义HTTP headers 通常意味着提供一些对 web 开发者有用的**附加信息**，或者是方便故障排除（troubleshooting）。这些 headers 通常以 `X-` 开头，例如X-Request-Id，就是项目后端塞进header的：
>
> <img src="images/计算机网络/image-20230909155446459.png" alt="image-20230909155446459" style="zoom:67%;" />
>
> 实现：添加拦截器
>
> ```java
> public ClientHttpResponse intercept(HttpRequest request, byte[] body, ClientHttpRequestExecution execution) throws IOException {
>     // 请求中塞入header：X-REQUEST-ID
>     // 用于trace请求线程执行链路
>     if (StringHelper.isEmpty(request.getHeaders().getFirst("X-REQUEST-ID")))
>         request.getHeaders().set("X-REQUEST-ID", LocalUser.getTraceId()); 
>     try {
>         logRequest(request, body);
>     } catch (Throwable throwable) {}
>     long st = System.currentTimeMillis();
>     ClientHttpResponse response = null;
>     try {
>         response = execution.execute(request, body);
>     } finally {
>         long elapsedTime = System.currentTimeMillis() - st;
>         logResponse(request, response, elapsedTime);
>     } 
>     return response;
> }
> ```
>
> Nginx配置：
>
> ```java
> add_header X-REQUEST-ID "X-REQUEST-ID"
> ```
>
> `X-REQUEST-ID`可以替换为其他自定义header

### 4.实体头

指的是用于应对实体主体部分的头部，比如，可以用实体头部来说明实体主体部分的数据类型

|    首部字段名    |          说明          |
| :--------------: | :--------------------: |
|      Allow       | 资源可支持的 HTTP 方法 |
| Content-Encoding | 实体主体适用的编码方式 |
| Content-Language |   实体主体的自然语言   |
|  Content-Length  |     实体主体的大小     |
| Content-Location |   替代对应资源的 URI   |
|   Content-MD5    |   实体主体的报文摘要   |
|  Content-Range   |   实体主体的位置范围   |
|   Content-Type   |   实体主体的媒体类型   |
|     Expires      | 实体主体过期的日期时间 |
|  Last-Modified   | 资源的最后修改日期时间 |

## 请求报文

客户端发送一个请求报文给服务器，服务器根据请求报文中的信息进行处理，并将处理结果放入响应报文中返回给客户端。

请求报文结构：

- 第一行是包含了请求方法、URL、协议版本；
- 接下来的多行都是请求首部 Header，每个首部都有一个首部名称，以及对应的值。
- 一个**空行**用来分隔首部和内容主体 Body
- 最后是请求的内容主体（13行

```text
GET http://www.example.com/ HTTP/1.1
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8
Cache-Control: max-age=0
Host: www.example.com
If-Modified-Since: Thu, 17 Oct 2019 07:18:26 GMT
If-None-Match: "3147526947+gzip"
Proxy-Connection: keep-alive
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 xxx

param1=1&param2=2
```

## 响应报文

服务器返回给客户端的报文

- 第一行包含协议版本、状态码以及描述，最常见的是 200 OK 表示请求成功了
- 接下来多行也是首部内容
- 一个**空行**分隔首部和内容主体
- 最后是响应的内容主体（18行

```text
HTTP/1.1 200 OK
Age: 529651
Cache-Control: max-age=604800
Connection: keep-alive
Content-Encoding: gzip
Content-Length: 648
Content-Type: text/html; charset=UTF-8
Date: Mon, 02 Nov 2020 17:53:39 GMT
Etag: "3147526947+ident+gzip"
Expires: Mon, 09 Nov 2020 17:53:39 GMT
Keep-Alive: timeout=4
Last-Modified: Thu, 17 Oct 2019 07:18:26 GMT
Proxy-Connection: keep-alive
Server: ECS (sjc/16DF)
Vary: Accept-Encoding
X-Cache: HIT

<!doctype html>
<html>
<head>
    <title>Example Domain</title>
	// 省略... 
</body>
</html>
```

## URL

HTTP 使用 URL（ **U** niform **R**esource **L**ocator，统一资源定位符）来定位资源，它是 URI（**U**niform **R**esource **I**dentifier，统一资源标识符）的子集，URL 在 URI 的基础上增加了定位能力。

URN（Uniform Resource Name，统一资源名称），也是URI的子集，它只是用来定义一个资源的名称，并不具备定位该资源的能力。例如 urn:isbn:0451450523 用来定义一个书籍名称，但是却没有表示怎么找到这本书。

<img src="images/计算机网络/8441b2c4-dca7-4d6b-8efb-f22efccaf331.png" alt="img" />

## HTTP方法

HTTP/1.0 定义了三种：GET, POST 和 HEAD 

HTTP/1.1 增加了六种：OPTIONS, PUT, PATCH, DELETE, TRACE 和 CONNECT

| 方法                                   | 描述                                                         |
| :------------------------------------- | ------------------------------------------------------------ |
| GET                                    | 请求指定的页面信息，并返回具体内容，通常只用于读取数据。     |
| POST                                   | 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立或已有资源的更改。 |
| HEAD                                   | 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头，确认 URL 的有效性以及资源更新的日期时间等。 |
| =================HTTP1.1新增========== | ======================HTTP1.1新增=======================     |
| PUT                                    | 替换 URL 标识的资源（如文件等），没有的话就新增，**不带验证机制**。（不安全） |
| DELETE                                 | 请求服务器删除资源数据，同样不带验证机制。（不安全）         |
| PATCH                                  | 是对 PUT 方法的补充，用来对已知资源进行**局部更新**（PUT只能完全替换）。（不安全） |
| CONNECT                                | 将服务器作为**代理**，建立隧道让服务器代替用户进行访问。使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。 |
| OPTIONS                                | 查询指定的 URL 能够支持的 HTTP 请求方法。例如会返回 `Allow: GET, POST, HEAD, OPTIONS` 这样的内容。 |
| TRACE                                  | 回显服务器收到的请求数据，即服务器返回自己收到的数据，主要用于测试和诊断。（不安全，容易受到 XST 攻击） |

put示例：

```html
PUT /new.html HTTP/1.1
Host: example.com
Content-type: text/html
Content-length: 16

<p>New File</p>
```

patch示例：

```html
PATCH /file.txt HTTP/1.1
Host: www.example.com
Content-Type: application/example
If-Match: "e0023aa4e"
Content-Length: 100

[description of changes]
```

delete示例：

```html
DELETE /file.html HTTP/1.1
```

## HTTP状态码

服务器返回的 **响应报文** 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。

| 状态码 |            类别            |            含义            |
| :----: | :------------------------: | :------------------------: |
|  1XX   |   Informational（信息）    |     接收的请求正在处理     |
|  2XX   |      Success（成功）       |      请求正常处理完毕      |
|  3XX   |   Redirection（重定向）    | 需要进行附加操作以完成请求 |
|  4XX   | Client Error（客户端错误） |     服务器无法处理请求     |
|  5XX   | Server Error（服务器错误） |     服务器处理请求出错     |

### 1XX 信息

- **100 Continue** ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。
- 101 协议切换：例如从HTTP切换为Websocket

### 2XX 成功

- **200 OK**：服务器成功处理请求。
- **201 Created**：服务器成功处理请求，并且创建了新的资源
- **202 Accepted**：服务器接受请求，但未处理
- **204 No Content** ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。
- **206 Partial Content** ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。

### 3XX 重定向

指当浏览器请求一个URL时，服务器返回一个重定向指令，告诉浏览器地址已经变了，麻烦使用新的URL再重新发送新请求。

- **301 Moved Permanently** ：永久性重定向
- **302 Found** ：临时性重定向
- **303 See Other** ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。
- 注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。
- **304 Not Modified** ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。
- **307 Temporary Redirect** ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。

**过程**

如果浏览器发送`GET /hi`请求，Spring的`RedirectServlet`将处理此请求。由于`RedirectServlet`在内部又发送了重定向响应，因此，浏览器会收到如下响应：

```
HTTP/1.1 302 Found
Location: /hello
```

当浏览器收到302响应后，它会立刻根据`Location`的指示发送一个新的`GET /hello`请求。

```ascii
┌───────┐   GET /hi     ┌───────────────┐
│Browser│ ────────────> │RedirectServlet│
│       │ <──────────── │               │
└───────┘   302         └───────────────┘


┌───────┐  GET /hello   ┌───────────────┐
│Browser│ ────────────> │ HelloServlet  │
│       │ <──────────── │               │
└───────┘   200 <html>  └───────────────┘
```

观察Chrome浏览器的网络请求，可以看到两次HTTP请求，并且浏览器的地址栏路径自动更新为`/hello`：

<img src="images/计算机网络/image-20230104172235427.png" alt="image-20230104172235427" style="zoom: 67%;" />

**注意**：301和302区别：如果服务器发送301，浏览器会**缓存**`/hi`到`/hello`这个重定向的关联，下次请求`/hi`的时候，浏览器就直接发送`/hello`请求了。



### 4XX 客户端错误

- **400 Bad Request** ：请求报文中存在语法错误。
- **401 Unauthorized** ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。
- **403 Forbidden** ：请求被拒绝。
- **404 Not Found**：服务器上没有找到请求的资源

### 5XX 服务器错误

- **500 Internal Server Error** ：服务器正在执行请求时发生错误。
- **503 Service Unavailable** ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。

## 连接管理

<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/HTTP1_x_Connections.png" alt="img" style="zoom: 67%;" />****



**短连接与长连接**

当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问的 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。

长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。

- 从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 `Connection : close`；
- 在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 `Connection : Keep-Alive`。

**流水线**

默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于受网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。

流水线：同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟。

## Session

Session 是浏览器和服务器会话过程中，服务器会分配的一块储存空间 。

因为HTTP协议是一个**无状态协议**，即Web应用程序无法区分收到的两个HTTP请求是否是同一个浏览器发出的。为了跟踪用户状态，服务器可以向浏览器分配一个唯一ID，并以Cookie的形式发送到浏览器，浏览器在后续访问时总是附带此Cookie，这样，服务器就可以识别用户身份。

**Session机制**

指这种基于唯一ID识别用户身份的机制。每个用户第一次访问服务器后，会自动获得一个Session ID（即发送给浏览器的Cookie）。如果用户在一段时间内没有访问服务器，那么Session会自动失效，下次即使带着上次分配的Session ID访问，服务器也认为这是一个新用户，会分配新的Session ID。

### java操作

JavaEE的Servlet机制内建了对Session的支持。我们以登录为例，当一个用户登录成功后，我们就可以把这个用户的名字放入一个`HttpSession`对象，以便后续访问其他页面的时候，能直接从`HttpSession`取出用户名：

```java
@WebServlet(urlPatterns = "/signin")
public class SignInServlet extends HttpServlet {
    // 模拟一个数据库:
    private Map<String, String> users = Map.of("bob", "bob123", "alice", "alice123", "tom", "tomcat");

    // POST请求时处理用户登录:
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        String name = req.getParameter("username");
        String password = req.getParameter("password");
        String expectedPassword = users.get(name.toLowerCase());
        if (expectedPassword != null && expectedPassword.equals(password)) {
            // 判断用户登录成功后，立刻将用户名放入当前HttpSession中
            req.getSession().setAttribute("user", name);
            resp.sendRedirect("/");
        } else {
            resp.sendError(HttpServletResponse.SC_FORBIDDEN);
        }
    }
}
```

服务器识别Session的关键就是依靠一个名为`JSESSIONID`的Cookie。在Servlet中第一次调用`req.getSession()`时，Servlet容器自动创建一个Session ID，然后通过一个名为`JSESSIONID`的Cookie发送给浏览器：

<img src="images/计算机网络/l.jpeg" alt="session" />

除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。

Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。

## Cookie

因为HTTP 协议是无状态的，HTTP/1.1 引入 Cookie 来保存状态信息，是服务器发送到**用户浏览器**并保存在**本地**的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。

Cookie是Session机制的一种实现方式（其他实现还有隐藏表单、URL末尾附加ID等，但不如Cookie常用）。实际上，Servlet提供的`HttpSession`本质上就是通过一个名为`JSESSIONID`的Cookie来跟踪用户会话的。除了这个名称外，其他名称的Cookie我们可以任意使用。

Cookie 曾一度用于客户端数据的存储，现已淘汰。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。



### 创建过程

服务器发送的响应报文中包含首部字段： **Set-Cookie** 。客户端得到响应报文后把 Cookie 内容保存到浏览器中。

```html
HTTP/1.0 200 OK
Content-type: text/html
Set-Cookie: yummy_cookie=choco
Set-Cookie: tasty_cookie=strawberry

[page content]
```

客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器。

```html
GET /sample_page.html HTTP/1.1
Host: www.example.org
Cookie: yummy_cookie=choco; tasty_cookie=strawberry
```

### 持久性 Cookie

- 会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。
- 持久性 Cookie：指定过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。

```html
Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;
```

### java操作

如果我们想要设置一个Cookie，例如，记录用户选择的语言，可以编写一个`LanguageServlet`：

```java
@WebServlet(urlPatterns = "/pref")
public class LanguageServlet extends HttpServlet {

    private static final Set<String> LANGUAGES = Set.of("en", "zh");

    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        String lang = req.getParameter("lang");
        if (LANGUAGES.contains(lang)) {
            // 创建一个新的Cookie:
            Cookie cookie = new Cookie("lang", lang);
            // 该Cookie生效的路径范围:
            cookie.setPath("/");
            // 该Cookie有效期:
            cookie.setMaxAge(8640000); // 8640000秒=100天
            // 将该Cookie添加到响应:
            resp.addCookie(cookie);
            // 如果访问的是https网页，还需要调用setSecure(true)，否则浏览器不会发送该Cookie。
        }
        resp.sendRedirect("/");
    }
}
```

读取Cookie主要依靠遍历`HttpServletRequest`附带的所有Cookie。

```java
private String parseLanguageFromCookie(HttpServletRequest req) {
    // 获取请求附带的所有Cookie:
    Cookie[] cookies = req.getCookies();
    // 如果获取到Cookie:
    if (cookies != null) {
        // 循环每个Cookie:
        for (Cookie cookie : cookies) {
            // 如果Cookie名称为lang:
            if (cookie.getName().equals("lang")) {
                // 返回Cookie的值:
                return cookie.getValue();
            }
        }
    }
    // 返回默认值:
    return "en";
}
```

### 浏览器禁用 Cookie

此时无法使用 Cookie 保存用户信息，只能用 Session。

此外，不能再将 Session ID 存放到 Cookie 中，而是使用 **URL 重写技术**，将 Session ID 作为 URL 的参数进行传递。

### 安全性问题

存储在浏览器中，容易被恶意查看

### 服务器集群Session问题

多台服务器集群使用反向代理作为网站入口：

```ascii
                                     ┌────────────┐
                                ┌───>│Web Server 1│
                                │    └────────────┘
┌───────┐     ┌─────────────┐   │    ┌────────────┐
│Browser│────>│Reverse Proxy│───┼───>│Web Server 2│
└───────┘     └─────────────┘   │    └────────────┘
                                │    ┌────────────┐
                                └───>│Web Server 3│
                                     └────────────┘
```

为了使得大型网站具有伸缩性，集群中的应用服务器通常需要保持无状态，使用户可以请求任何一个节点。如果多台Web Server采用无状态集群，那么反向代理总是以轮询方式将请求依次转发给每台Web Server，这会造成一个用户在Web Server 1存储的Session信息，在Web Server 2和3上并不存在，即从Web Server 1登录后，如果后续请求被转发到Web Server 2或3，那么用户看到的仍然是未登录状态。

**解决**

- 方案一：在所有Web Server之间进行**Session复制**，但这样会严重消耗网络带宽，并且，每个Web Server的内存均存储所有用户的Session，内存使用率很低。
- 方案二：采用**粘滞会话**（Sticky Session）机制，即反向代理在转发请求的时候，总是根据JSESSIONID的值判断，相同的JSESSIONID总是转发到固定的Web Server，但这需要反向代理的支持。

> 无论采用何种方案，使用Session机制，会使得Web Server的集群很难扩展，因此，Session适用于中小型Web应用程序。**对于大型Web应用程序来说，通常需要避免使用Session机制**。

- 方案三：Session Server。使用一个单独的服务器存储 Session 数据，可以使用传统的 MySQL，也使用 Redis 或者 Memcached 这种内存型数据库。

  优点：为了使得大型网站具有伸缩性，集群中的应用服务器通常需要保持无状态，那么应用服务器不能存储用户的会话信息。Session Server 将用户的会话信息单独进行存储，从而保证了应用服务器的无状态。

  缺点：需要去实现存取 Session 的代码。

**最佳实践：nginx + tomcat + redis**

tomcat中配置连接redis，将session存redis以实现在多个Web Server之间共享。

具体是在$TOMCAT_BASE/conf/context.xml中配置RedissonSessionManager，让所有tomcat实例都连接同一个redis。在所有tomcat之前配一个nginx做反向代理即可

参考：https://www.jianshu.com/p/d3df0d708f2e

## Q：Cookie与Session比较？

|          | Cookie                                            | 客户端Session                                       | 服务端Session                               |
| -------- | ------------------------------------------------- | --------------------------------------------------- | ------------------------------------------- |
| 格式     | ASCII码字符串                                     | 字符串                                              | 任意类型（但本质上还是字符串）              |
| 大小     | 4KB                                               | 5MB（在浏览器中称sessionStorage）                   | 无上限                                      |
| 生命周期 | 过期时间 之前，一直有效（页面或浏览器关闭后失效） | 过期时间 之前，一直有效；（页面或浏览器关闭后失效） | 一直有效（服务器程序终止后失效）            |
| 存储位置 | 浏览器（客户端）                                  | 浏览器（客户端）                                    | 服务器上（文件、数据库或者内存，甚至Redis） |
| 安全性   | 差，易被恶意查看（解决：加密，在服务器解密）      |                                                     | 好，因为不存客户端。可以安全存放用户信息    |
| 用途     | 会话状态管理、个性化设置、浏览器行为跟踪          |                                                     | 同Cookie                                    |

## 缓存

### 优点

- 缓解服务器压力；
- 降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并且缓存服务器在地理位置上也有可能比源服务器来得近，例如浏览器缓存。

### 实现方法

- 让代理服务器进行缓存；
- 让客户端浏览器进行缓存。

### Cache-Control

HTTP/1.1 通过 Cache-Control 首部字段来控制缓存。

**1 禁止进行缓存**

no-store 指令规定不能对请求或响应的任何一部分进行缓存。

```html
Cache-Control: no-store
```

**2 强制确认缓存**

no-cache 指令规定缓存服务器需要先向源服务器验证缓存资源的有效性，只有当缓存资源有效时才能使用该缓存对客户端的请求进行响应。

```html
Cache-Control: no-cache
```

**3 私有缓存和公共缓存**

private 指令规定了将资源作为私有缓存，只能被单独用户使用，一般存储在用户浏览器中。

```html
Cache-Control: private
```

public 指令规定了将资源作为公共缓存，可以被多个用户使用，一般存储在代理服务器中。

```html
Cache-Control: public
```

**4 缓存过期机制**

max-age 指令出现在请求报文，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。

max-age 指令出现在响应报文，表示缓存资源在缓存服务器中保存的时间。

```html
Cache-Control: max-age=31536000
```

Expires 首部字段也可以用于告知缓存服务器该资源什么时候会过期。

```html
Expires: Wed, 04 Jul 2012 08:26:05 GMT
```

- 在 HTTP/1.1 中，会优先处理 max-age 指令；
- 在 HTTP/1.0 中，max-age 指令会被忽略掉。

### 内容协商

通过内容协商返回最合适的内容，例如根据浏览器的默认语言选择返回中文界面还是英文界面。

**类型**

**1.1 服务端驱动型**

客户端设置特定的 HTTP 首部字段，例如 Accept、Accept-Charset、Accept-Encoding、Accept-Language，服务器根据这些字段返回特定的资源。

它存在以下问题：

- 服务器很难知道客户端浏览器的全部信息；
- 客户端提供的信息相当冗长（HTTP/2 协议的首部压缩机制缓解了这个问题），并且存在隐私风险（HTTP 指纹识别技术）；
- 给定的资源需要返回不同的展现形式，共享缓存的效率会降低，而服务器端的实现会越来越复杂。

**1.2 代理驱动型**

服务器返回 300 Multiple Choices 或者 406 Not Acceptable，客户端从中选出最合适的那个资源。

**Vary**

```html
Vary: Accept-Language
```

在使用内容协商的情况下，只有当缓存服务器中的缓存满足内容协商条件时，才能使用该缓存，否则应该向源服务器请求该资源。

例如，一个客户端发送了一个包含 Accept-Language 首部字段的请求之后，源服务器返回的响应包含 `Vary: Accept-Language` 内容，缓存服务器对这个响应进行缓存之后，在客户端下一次访问同一个 URL 资源，并且 Accept-Language 与缓存中的对应的值相同时才会返回该缓存。

## 内容编码

浏览器发送 Accept-Encoding 首部，其中包含有它所支持的压缩算法，以及各自的优先级。服务器则从中选择一种，使用该算法对响应的消息主体进行压缩，并且发送 Content-Encoding 首部来告知浏览器它选择了哪一种算法。由于该内容协商过程是基于编码类型来选择资源的展现形式的，响应报文的 Vary 首部字段至少要包含 Content-Encoding。

常见编码：gzip、compress、deflate、identity

## 范围请求

如果网络出现中断，服务器只发送了一部分数据，范围请求可以使得客户端只请求服务器未发送的那部分数据，从而避免服务器重新发送所有数据。

**1.Range**

在请求报文中添加 Range 首部字段指定请求的范围。

```html
GET /z4d4kWk.jpg HTTP/1.1
Host: i.imgur.com
Range: bytes=0-1023
```

请求成功的话服务器返回的响应包含 206 Partial Content 状态码。

```html
HTTP/1.1 206 Partial Content
Content-Range: bytes 0-1023/146515
Content-Length: 1024
...
(binary content)
```

**2.Accept-Ranges**

响应首部字段 Accept-Ranges 用于告知客户端是否能处理范围请求，可以处理使用 bytes，否则使用 none。

```html
Accept-Ranges: bytes
```

**3.响应状态码**

- 在请求成功的情况下，服务器会返回 206 Partial Content 状态码。
- 在请求的范围越界的情况下，服务器会返回 416 Requested Range Not Satisfiable 状态码。
- 在不支持范围请求的情况下，服务器会返回 200 OK 状态码。

## 分块传输编码

Chunked Transfer Encoding，可以把数据分割成多块，让浏览器逐步显示页面。

## 多部分对象集合

一份报文主体内可含有多种类型的实体同时发送，每个部分之间用 boundary 字段定义的分隔符进行分隔，**每个部分**都可以有首部字段。

例如，上传多个表单时可以使用如下方式

```html
Content-Type: multipart/form-data; boundary=AaB03x

--AaB03x
Content-Disposition: form-data; name="submit-name"

Larry
--AaB03x
Content-Disposition: form-data; name="files"; filename="file1.txt"
Content-Type: text/plain

... contents of file1.txt ...
--AaB03x--
```

第一行是首部，表示是多部份对象，边界分隔符是“AaB03x”

第3行 表示一个部分对象的起始边界，第4行是其首部，名称为“submit-name”，内容是Larry

第7行 表示另一个部分对象的起始边界，第8行是其首部，表示名称为“files”，文件名为“file1.txt”，11行开始是文件内容

第12行表示多部份的结束，在分隔符之后加上“--”

## 通信数据转发

**1.代理**

代理服务器接受客户端的请求，并且转发给其它服务器。

使用代理的主要目的是：

- 缓存
- 负载均衡
- 网络访问控制
- 访问日志记录

代理服务器分为正向代理和反向代理两种

- 正向代理：客户端请求经过代理到达服务器，服务器不知道真正的客户端是谁
- 反向代理：服务器响应经过代理到达客户端，客户端不知道真正的服务器是谁



**2.网关**

与代理服务器不同的是，网关服务器会将 HTTP 转化为其它协议进行通信，从而请求其它非 HTTP 服务器的服务。

**3.隧道**

使用 SSL 等加密手段，在客户端和服务器之间建立一条安全的通信线路。



## HTTP1.1

### Q：HTTP1.0与HTTP1.1比较？

|          | HTTP1.0                                                      | HTTP1.1                                                      |
| -------- | :----------------------------------------------------------- | ------------------------------------------------------------ |
| 连接长短 | 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接 | 默认**长连接**，完成一次HTTP请求和响应后，可以接着复用该连接；但必须**串行**（一个连接不能同时发送多个请求）。 |
| 连接数   | 一个                                                         | 支持同时打开**多个 TCP 连接**。连接数没有具体限制，但浏览器会限制，如Chrome 最多允许对同一个 Host 建立 **6个** TCP 连接 |
| 方法     | 定义三种方法：GET, POST 和 HEAD                              | 增加了六种：OPTIONS, PUT, PATCH, DELETE, TRACE 和 CONNECT    |
| 状态码   |                                                              | 新增状态码 100（表示信息）                                   |
| 新特性   |                                                              | 支持**分块传输**编码                                         |
| 新特性   |                                                              | 支持虚拟主机（一台服务器拥有多个域名，在逻辑上可以看成多个服务器） |
| 新特性   |                                                              | 新增缓存处理指令 max-age                                     |
| 新特性   |                                                              | 连接支持流水线（`Pipelining`字段，又称管道机制）：连接内同时发出多个请求，不用一个个等待响应 |

### Q：短连接、长连接、管道机制和并行连接的区别？

<img src="images/计算机网络/2525618-20221225224821371-1302315289.png" alt="img" />

<img src="images/计算机网络/image-20230201142524097.png" alt="image-20230201142524097" />

<img src="images/计算机网络/2525618-20221225224836834-2024524297.png" alt="img" />

**管道机制**

连接内同时发出多个请求，不用一个个等待响应。

**管道的缺点：队头堵塞**

虽然请求可以连续发出，但服务器必须按照接收请求的顺序依次发送对这些管道化请求的响应，以保证客户端能够区分出每次请求的响应内容。（原因大概是 HTTP/1.1 是个文本协议，只看返回报文无法确定是哪个请求的返回）

如果服务端在处理一个请求时耗时比较长，那么后续请求的处理都会被阻塞住，会导致客户端迟迟收不到数据

实际上，虽然管道机制的想法很好，但实现困难，因而很多浏览器不支持。一般为了提升性能，采用**并行多个 TCP 连接**的形式来实现请求的同时发送。

## HTTPS

HTTP 有以下三个安全性问题：

1. 使用明文进行通信，内容可能会被窃听；
2. 不验证通信方的身份，通信方的身份有可能遭遇伪装；
3. 无法证明报文的完整性，报文有可能遭篡改。

HTTPS 并不是新协议，而是让 HTTP 先和 **SSL**（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，即 HTTPS 使用隧道通信。



**TLS**（Transport Layer Security）基于SSL3.0设计，以下SSL/TLS都指的是同一协议。

通过SSL，HTTPS 解决了上述三个安全性问题，具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。

### TLS 四次握手

<img src="images/计算机网络/image-20230202010614422.png" alt="image-20230202010614422" />

- 前两次握手：加密算法协商。

  1. Client Hello：浏览器向服务器发送一些可选的加密算法，以及【客户端随机数】。

  2. Server Hello：服务器从这些加密算法中选出自己支持的算法告知浏览器，并发送一个包含其公钥的**数字证书** 和 【服务端随机数】。

     浏览器用该证书的认证中心CA公开发布的公钥对该证书进行验证，验证通过后才进行下一步。

- 后两次握手：产生**会话密钥**。使用**非对称加密算法**计算，即浏览器选择一个随机数`pre_master_key`，用公钥加密后发送，服务器用私钥解密得到该`pre_master_key`。

  此时双方都掌握三个随机数：【客户端随机数】、【服务端随机数】和`pre_master_key`，用这三个随机数计算得到会话密钥。

<img src="images/计算机网络/640.png" alt="图片" style="zoom:50%;" />

之后就建立了用会话密钥**对称加密**的安全传输连接

### 加密

**1.对称密钥加密**（Symmetric-Key Encryption），加密和解密使用**同一密钥**。

- 优点：运算速度快；
- 缺点：无法安全地将密钥传输给通信方。
- 常用算法：AES

**2.非对称密钥加密**，又称公开密钥加密（Public-Key Encryption），加密和解密使用**不同的密钥**。

- 加密【公加私解】：公开密钥所有人都可以获得，通信发送方获得接收方的公钥之后，用公钥加密，接收方收到通信内容后使用私有密钥解密。

- 签名【私加公解】：还可用来签名，过程与加密相反。因为私钥无法被其他人获取，因此发送方使用其私钥签名，接收方使用发送方的公钥对签名解密，就能判断这个签名是否正确，即是否发送方发出的，其他人由于没有私钥不能伪造，此外发送方也无法抵赖。


- 优点：可以更安全地将公开密钥传输给通信发送方；
- 缺点：运算速度慢。
- 常用算法：RSA

**3.HTTPS 采用的加密方式：混合加密（RSA+AES）**

- 先使用非对称密钥加密（如RSA），传输对称密钥加密方式（如AES）需要的 Secret Key，从而保证安全性;
- 获取到 Secret Key 后，再使用对称密钥加密方式进行通信，从而保证效率。

实际中也可以不将密钥和数据分开加密，整体先RSA再AES，与接收端约定好即可。

### 认证

通过使用 **证书** 来对通信方进行认证。

数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。

服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后**绑定**在一起。

进行 HTTPS 通信时，服务器会把 **证书** 发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。

### 完整性保护

SSL 提供报文摘要功能来进行完整性保护。

HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。

HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。

### 

### HTTPS 的缺点

- 因为需要加密解密等过程，因此速度会更慢；
- 需要支付证书授权的高额费用。

## HTTP2 

HTTP/1.x 实现简单是以牺牲性能为代价的：

- 客户端需要使用多个连接才能实现并发和缩短延迟；
- 报文为纯文本格式，体积大
- 不会压缩请求和响应首部，从而导致不必要的网络流量；
- 不支持有效的资源优先级，致使底层 TCP 连接的利用率低下。

Http2改进：

多路复用、二进制传输、压缩首部、服务端推送

### 二进制帧

HTTP1的报头是基于ASCII文本的，无法直接表示二进制（除非用base64转换）

HTTP/2.0 将报文分成 HEADERS 帧和 DATA 帧，它们都是二进制格式的。

<img src="images/计算机网络/86e6a91d-a285-447a-9345-c5484b8d0c47.png" alt="img" style="zoom:50%;" />

在通信过程中，只会有一个 TCP 连接存在，它承载了任意数量的双向数据流（Stream）。

- 流（Stream）是二进制帧的双向传输序列，对于一个完整的请求-响应过程。
- 消息（Message）是**逻辑上完整**的一系列帧。
- 帧（Frame）是**最小**的通信单位，来自不同数据流的帧可以交错发送，然后再根据每个**帧头**的数据流标识符重新组装。

<img src="images/计算机网络/af198da1-2480-4043-b07f-a3b91a88b815.png" alt="img" style="zoom: 67%;" />

### 多路复用

HTTP2可以在一个TCP连接中并行发送多个流（即并行多个请求或响应），以复用这个TCP连接

通过流的Stream ID区分不同的请求-响应，解决了HTTP1.1 的队头阻塞问题。

### 服务端推送

HTTP/1.1 中，只能客户端发起请求，服务器对请求进行响应。

HTTP/2 中，服务端可以**主动**给客户端推送必要的资源

例如客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端。

<img src="images/计算机网络/e3f1657c-80fc-4dfa-9643-bf51abd201c6.png" alt="img" style="zoom:75%;" />

### 首部压缩

HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。

HTTP/2.0 改进：

1. 要求客户端和服务器同时维护和更新一个包含之前见过的**首部字段表**，从而避免了重复传输。
2. 此外HTTP/2.0 也使用 **Huffman 编码**对首部字段进行压缩。

<img src="images/计算机网络/http2header.png" alt="img" style="zoom: 50%;" />

## HTTP3



<img src="images/计算机网络/2525618-20221225224912330-853622009.png" alt="img" />

### 无队头阻塞

HTTP/2 仍然采用 TCP 连接，因此并没有解决 TCP 的【队头阻塞】问题，只要出现丢包，则TCP就要重传，可能导致连接上的所有流阻塞，直到丢的包重传成功。

HTTP3 基于**QUIC协议**，底层是UDP。丢包不会阻塞其他流，彻底解决了【队头阻塞】问题。将原先 TCP 协议提供的部分功能上移至 QUIC，在应用层保证可靠性。

### 优化重传机制

TCP 采用**序号+确认号+超时重传**机制来保证消息的可靠性，由于网络拥堵情况不断变化，因而消息的超时时间并不是固定的，而是通过不断采样消息的【往返时间】不断调整的，但 **TCP 超时采样存在不准确的问题**。

例如客户端发送一个序号为 N 的包，然后超时了。于是重新发送一个序号为 N 的包，之后服务器收到后返回一个确认号 ACK 为 N+1 的包。但此时客户端并无法判断这个确定包是对【原始报文】的确认还是【重传报文】的确认，如下图，情况1会将采样时间算长，情况2会将采样时间算短

<img src="images/计算机网络/2525618-20221225224921040-1399680491.png" alt="img" />

问题：原始报文和重传报文序列号都为N，如何确定ACK N+1是回应哪个报文？

QUIC 定义了一个**递增**的序列号（不再叫 Seq，而是 Packet Number），每个序列号的包只发送一次，**即使重传相同的包，其序列号也不一样**。

<img src="images/计算机网络/2525618-20221225224927917-822131467.png" alt="img" />

如何知道包 N 和包 N+1 是同一个包呢？QUIC 定义了一个 **Offset **概念。发送的数据有个偏移量 Offset，可以通过 Offset 知道数据目前发送到了哪里，因而如果某个 Offset 的包没有收到确认，就重发。

### 连接迁移

一条 TCP 连接是由四元组标识的，分别是**源 IP、源端口、目的 IP、目的端口**。一旦其中一个元素发生了变化，就需要断开重连。

QUIC 不再采用四元组，而是以一个 **64 位的随机数 ID** 来标识连接，通过此连接 ID 标记通信的两端，之后即使网络发生变化，IP 或端口变了，但只要 ID 不变，则无需重连，只需要复用原先连接即可。时延低，减少了用户的卡顿感，实现连接迁移。

## 总结HTTP的升级

| 版本     | 升级                                                         |
| -------- | ------------------------------------------------------------ |
| HTTP/1.0 | GET、POST、HEAD方法，基于TCP                                 |
| HTTP/1.1 | 增加了六种：OPTIONS, PUT, PATCH, DELETE, TRACE 和 CONNECT；引入长连接、管道（流水线）、分块传输；支持多个连接；新增100状态码； |
| HTTP/2   | 多路复用、二进制传输、首部压缩、服务器推送                   |
| HTTP/3   | 基于UDP                                                      |









## Q：GET和POST区别？

| GET                                                         | POST                                   |
| ----------------------------------------------------------- | -------------------------------------- |
| get 提交的数据放在 URL 中（http包头），可能会存在安全问题。 | post 参数放在请求主体（http正文）中    |
| get请求参数会被缓存，会留在浏览器历史记录                   | post请求不会被缓存，也不会保留历史记录 |
| get 只支持 URL 编码（百分比编码，只能用ASCII字符）          | post 支持多种编码                      |
| get 提交的数据大小有限制（是浏览器的限制，与http无关）      | post 提交的数据大小没限制              |
| get产生一个TCP数据包                                        | post产生两个（视浏览器而定）           |

### 幂等性

幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。即，幂等方法不应该具有副作用（统计用途除外），是安全的。



在正确实现的条件下，GET，HEAD，PUT 和 DELETE等方法都是幂等的，而 **POST 方法不是**。

例如，DELETE删多次，最终结果都是删除一个URL资源而已：

```text
DELETE /idX/delete HTTP/1.1   -> Returns 200 if idX exists
DELETE /idX/delete HTTP/1.1   -> Returns 404 as it just got deleted
DELETE /idX/delete HTTP/1.1   -> Returns 404
```

### 可缓存

如果要对响应进行缓存，需要满足以下条件：

- 请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。
- 响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。
- 响应报文的 Cache-Control 首部字段没有指定不进行缓存。

### XMLHttpRequest

为了阐述 POST 和 GET 的另一个区别，需要先了解 XMLHttpRequest：

> XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。

- 在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。
- 而 GET 方法 Header 和 Data 会一起发送。

# wireshark抓包

SYN表示建立连接

FIN表示关闭连接

ACK表示响应

PSH表示有 data 数据传输

RST表示连接重置

<img src="images/计算机网络/image-20230103102225757.png" alt="image-20230103102225757" />

如图表示一个已经建立的TCP连接，红框第一行表示A向B发送一个空包（LEN=0），表示确认（ACK）收到B的第2630字节以前的内容

第二行表示A向B传输数据（PSH），长度1460，因此发送第4402~5861（4402+1460-1，因为包括4402）个字节。

第三行表示B向A发送一个空确认包，ACK=5862 （A发送的最后一个字节号5861+1）

由上可知实际使用符合TCP传输规定

## TLS 解密

### 

<img src="images/计算机网络/640-1675306555603-15.png" alt="图片" style="zoom:50%;" />

HTTP协议里的Host和实际发送的request body都会被加密。所以没办法通过`http.host`进行过滤。

HTTPS握手中的Client Hello阶段，里面有个扩展`server_name`，会记录你想访问的是哪个网站，通过下面的筛选条件可以将它过滤出来。

```
  tls.handshake.extensions_server_name == "baidu.com"
```

<img src="images/计算机网络/640-1675306567420-18.png" alt="图片" style="zoom: 67%;" />

执行tcpdump抓包

```
$ tcpdump -i eth0 host 39.156.66.10 -w baidu.pcap
```

然后在另外一个命令行窗口下执行下面的命令，**目的是将加密的key导出，并给出对应的导出地址**是`/Users/xiaobaidebug/ssl.key`。

```
$ export SSLKEYLOGFILE=/Users/xiaobaidebug/ssl.key
```

然后在同一个命令行窗口下，继续执行curl命令或用命令行打开chrome浏览器。**目的是为了让curl或chrome继承这个环境变量。**

```
$ curl 'https://baidu.com'
或者
$ open -a Google\ Chrome #在mac里打开chrome浏览器
```

此时会看到在`/Users/xiaobaidebug/`下会多了一个`ssl.key`文件。

这时候跟着下面的操作修改`wireshark`的配置项。

再修改`wireshark`的配置项，将`ssl.key`文件路径填入。

<img src="images/计算机网络/640-1675307511214-21.png" alt="图片" style="zoom:50%;" />

点击确定后，就能看到**18号和20号数据包已经被解密**

<img src="images/计算机网络/640-1675307553927-24.png" alt="图片" style="zoom:67%;" />

此时再用`http.host == "baidu.com"`，就能过滤出数据了。

<img src="images/计算机网络/640-1675307576785-27.png" alt="图片" style="zoom:50%;" />



参考：https://mp.weixin.qq.com/s/h1SgPEkOlg8QZomJy1pt_A

# Socket

Socket（套接字）是一个抽象概念，一个应用程序通过一个Socket来建立一个远程连接，而Socket内部通过TCP/IP协议传输数据。一个Socket就是由 **IP地址+端口号**（范围是0～65535）组成

使用Socket进行网络编程时，本质上就是两个进程之间的网络通信。其中一个进程必须充当服务器端，它会主动监听某个指定的端口，另一个进程必须充当客户端，它必须主动连接服务器的IP地址和指定端口，如果连接成功，服务器端和客户端就成功地建立了一个TCP连接，双方后续就可以随时发送和接收数据。

## Q：Socket和http的区别和应用场景

Socket连接就是所谓的长连接，理论上客户端和服务器端一旦建立起连接将不会主动断掉；Socket适用场景：网络游戏，银行持续交互，直播，在线视屏等。
http连接就是所谓的短连接，即客户端向服务器端发送一次请求，服务器端响应后连接即会断开等待下次连接。http适用场景：公司OA服务，互联网服务，电商，办公，网站等等等等

## 编写HTTP Server（1.0)

一个HTTP Server本质上是一个TCP服务器，先用[TCP编程](https://www.liaoxuefeng.com/wiki/1252599548343744/1305207629676577)的多线程实现的服务器端框架。

只需要在`handle()`方法中，用Reader读取HTTP请求，用Writer发送HTTP响应，即可实现一个最简单的HTTP服务器。

```java
public class Server {
    public static void main(String[] args) throws IOException {
        ServerSocket ss = new ServerSocket(8080); // 监听指定端口
        System.out.println("server is running...");
        for (;;) {
            Socket sock = ss.accept();
            System.out.println("connected from " + sock.getRemoteSocketAddress());
            Thread t = new Handler(sock);  // 传入Socket创建线程
            t.start();
        }
    }
}

class Handler extends Thread {
    Socket sock;

    public Handler(Socket sock) {
        this.sock = sock;
    }

    public void run() {
        try (InputStream input = this.sock.getInputStream()) {
            try (OutputStream output = this.sock.getOutputStream()) {
                handle(input, output);
            }
        } catch (Exception e) {
            try {
                this.sock.close();
            } catch (IOException ioe) {
            }
            System.out.println("client disconnected.");
        }
    }
    // 核心逻辑：处理http请求和发送响应
    private void handle(InputStream input, OutputStream output) throws IOException {
    	System.out.println("Process new http request...");
    	var reader = new BufferedReader(new InputStreamReader(input, StandardCharsets.UTF_8));
    	var writer = new BufferedWriter(new OutputStreamWriter(output, StandardCharsets.UTF_8));
    	// 读取HTTP请求:
    	boolean requestOk = false;
    	String first = reader.readLine();
    	if (first.startsWith("GET / HTTP/1.")) { // 不是以这个开头的，认为请求非法
        	requestOk = true;
   	 	}
    	for (;;) {
        	String header = reader.readLine();
        	if (header.isEmpty()) { // 读取到空行时, HTTP Header读取完毕
            	break;
        	}
        	System.out.println(header);
    	}
    	System.out.println(requestOk ? "Response OK" : "Response Error");
    	if (!requestOk) {
        	// 发送错误响应:
        	writer.write("HTTP/1.0 404 Not Found\r\n");
        	writer.write("Content-Length: 0\r\n");
        	writer.write("\r\n");
        	writer.flush();
    	} else {
        	// 发送成功响应:
        	String data = "<html><body><h1>Hello, world!</h1></body></html>";
        	int length = data.getBytes(StandardCharsets.UTF_8).length;
            // 首先发送响应代码，表示一个成功的200响应，使用HTTP/1.0协议
        	writer.write("HTTP/1.0 200 OK\r\n");
            // Header
        	writer.write("Connection: close\r\n");
        	writer.write("Content-Type: text/html\r\n");
        	writer.write("Content-Length: " + length + "\r\n");
             // 空行标识Header和Body的分隔
        	writer.write("\r\n");
            // Body
        	writer.write(data);
        	writer.flush();
    	}
	}
}
```

# Websocket

现在使用最广泛的`HTTP1.1`，也是基于TCP协议的，**同一时间里**，客户端和服务器**只能有一方主动**发数据，这就是所谓的**半双工**。也就是说，好好的全双工TCP，被HTTP用成了半双工。这是由于HTTP协议设计之初，考虑的是看看网页文本的场景，能做到**客户端发起请求再由服务器响应**，就够了，根本就没考虑网页游戏这种，客户端和服务器之间都要互相主动发大量数据的场景。

所以为了更好的支持这样的场景，我们需要另外一个**基于TCP的新协议**。于是新的应用层协议**websocket**就被设计出来了。

> 虽然名字带了个socket，但其实socket和websocket之间，就跟雷峰和雷峰塔一样，二者接近**毫无关系**。

## 建立websocket连接

<img src="images/计算机网络/90cf4e27558d4373b8f9ef678b696eb9tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp" alt="建立websocket连接.drawio" style="zoom: 25%;" />

浏览器在**TCP三次握手**建立连接之后，都**统一使用HTTP协议**先进行一次通信。

- 如果此时是**普通的HTTP请求**，那后续双方就还是老样子继续用普通HTTP协议进行交互，这点没啥疑问。
- 如果这时候是**想建立websocket连接**，就会在HTTP请求里带上一些**特殊的header头**。

   ```
   Connection: Upgrade
   Upgrade: websocket
   Sec-WebSocket-Key: T2a6wZlAwhgQNqruZ2YUyg==\r\n
   ```

这些header头的意思是，浏览器想**升级协议（Connection: Upgrade）**，并且想升级成**websocket协议（Upgrade: websocket）**。

同时带上一段**随机生成的base64码（Sec-WebSocket-Key）**，发给服务器。

如果服务器正好支持升级成websocket协议。就会走websocket握手流程，同时根据客户端生成的base64码，用某个**公开的**算法变成另一段字符串，放在HTTP响应的 `Sec-WebSocket-Accept` 头里，同时带上`101状态码`，发回给浏览器。

```
HTTP/1.1 101 Switching Protocols\r\n
Sec-WebSocket-Accept: iBJKv/ALIW2DobfoA4dmr3JHBCY=\r\n
Upgrade: websocket\r\n
Connection: Upgrade\r\n
```

> http状态码=200（正常响应）的情况，大家见得多了。101确实不常见，它其实是指**协议切换**。

之后，浏览器也用同样的**公开算法**将`base64码`转成另一段字符串，如果这段字符串跟服务器传回来的**字符串一致**，那验证通过。

就这样经历了一来一回两次HTTP握手，websocket就建立完成了，后续双方就可以使用webscoket的数据格式进行通信了。

你在网上可能会看到一种说法："websocket是基于HTTP的新协议"，**其实这并不对**，因为websocket只有在建立连接时才用到了HTTP，**升级完成之后就跟HTTP没有任何关系了**。

# 应用层其他协议

## 常用端口



|       应用       | 应用层协议 | 端口号  | 传输层协议 |                             备注                             |
| :--------------: | :--------: | :-----: | :--------: | :----------------------------------------------------------: |
|     域名解析     |    DNS     |   53    |  UDP/TCP   | 两种情况使用 TCP：1. 长度超过 **512** 字节（因为UDP 建议最大只支持 512 ）2. 区域传送（主域名服务器向辅助域名服务器传送变化的那部分数据，数据量大） |
| 动态主机配置协议 |    DHCP    |  67/68  |    UDP     |                                                              |
| 简单网络管理协议 |    SNMP    | 161/162 |    UDP     |                                                              |
|   文件传送协议   |    FTP     |  20/21  |    TCP     |                   控制连接 21，数据连接 20                   |
|   远程终端协议   |   TELNET   |   23    |    TCP     |                                                              |
|  超文本传送协议  |    HTTP    |   80    |    TCP     |                                                              |
| 简单邮件传送协议 |    SMTP    |   25    |    TCP     |                                                              |
|   邮件读取协议   |    POP3    |   110   |    TCP     |                                                              |
| 网际报文存取协议 |    IMAP    |   143   |    TCP     |                                                              |

## 1. 域名系统DNS

是一个分布式数据库，提供了**主机名**和 **IP 地址**之间相互转换的服务。

**分布式数据库**是指，每个站点只保留它自己的那部分数据。

### 域名格式

1. 共四级，从左到右分别是低级域名到高级域名；
2. 每一级都由英文+数字构成，不超过63字符（加上分隔符`.`号，总共不超过63*4+3=255）；

<img src="images/计算机网络/image-20230206003327376.png" alt="image-20230206003327376" />

### 域名结构（逻辑概念）

层次树状结构：

<img src="images/计算机网络/image-20230206003544941.png" alt="image-20230206003544941" />

树根：没有对应域名

顶级：国家（cn）、组织（com、org）等

二级：省、机构等

### 域名服务器（物理存在）

域名和ip对应关系实际上保存再域名服务器上

1. 根域名服务器：最高层级，全球共13台。并不直接对域名解析，而是返回该域名**所属顶级域名**所在的服务器的（即顶级服务器）ip
2. 顶级域名服务器
3. 权限域名服务器
4. 本地域名服务器：不属于域名服务器的等级结构。主机最先请求本地服务器，本地服务器只做代理作用

域名服务器使用**高速缓存**减少网络中DNS报文数量

### 域名解析过程



<img src="images\计算机网络\1632307681-keCKRT-image.png" alt="DNS.png" style="zoom: 33%;" />

1. 递归查询：如果主机所询问的本地域名服务器不知道被查询域名的 IP 地址，那么本地域名服务器就以 DNS 客户端的身份，向其他根域名服务器继续发出查询请求报文，即**把查询委托给其他服务器**，而不是让主机自己进行下一步查询。根服务器又将查询委托给服务器①，如此递归下去，直到查到主机B。如上图步骤（1）~（10）。
2. 迭代查询：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地服务器下一步应该找哪个域名服务器进行查询，然后**还是让本地服务器进行后续的查询**，如上图步骤（2）~（9）。

由于递归查询对被查询的服务器负担太大，通常采取以下方式：主机A到本地DNS用递归查询，其余用迭代查询。

DNS

### DNS劫持

即域名劫持，是通过将原域名对应的 IP 地址进行替换从而使得用户访问到错误的网站，或者使用户无法正常访问网站的一种攻击方式。

攻击者冒充原域名所属机构，修改电子邮件来修改机构的域名注册信息，或将域名转让给其他组织，并将新域名保存在指定DNS服务器，使用户无法通过对原域名解析来访问目的网址。

域名劫持往往只能在特定的网络范围内进行，范围外DNS解析正常。

预防手段：

直接通过ip地址访问，避开DNS

## 2. 文件传送协议FTP

FTP 使用 TCP 进行连接，它需要两个连接来传送一个文件：

- 控制连接：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。
- 数据连接：用来传送一个文件的数据。

根据数据连接**是否由服务器端主动**建立，FTP 有主动和被动两种模式：

1. 主动模式：服务器端主动建立数据连接，其中服务器端的端口号为 20，客户端的端口号随机，但是必须大于 1024，因为 0~1023 是熟知端口号。
2. 被动模式：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。

主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。

被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是安全性减弱。

## 3. 动态主机配置协议

DHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要手动配置 IP 地址等信息。

DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。

DHCP 工作过程如下：

1. 客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。
2. DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。
3. 如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。
4. DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。

<img src="images/计算机网络/23219e4c-9fc0-4051-b33a-2bd95bf054ab.jpg" alt="img" />

## 4. 电子邮件协议

一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。

邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。

<img src="images/计算机网络/7b3efa99-d306-4982-8cfb-e7153c33aab4.png" alt="img" />

#### SMTP

SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。

<img src="images/计算机网络/ed5522bb-3a60-481c-8654-43e7195a48fe.png" alt="img" />

#### POP3

POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。但最新版本的 POP3 可以不删除邮件。

#### IMAP

IMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。



## 5. 远程登录协议

TELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。

TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。

## Web 页面请求过程

### 1. DHCP 配置主机信息

- 假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。
- 主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。
- 该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。
- 该数据报则被放置在 MAC 帧中，该帧具有目的地址 `FF:FF:FF:FF:FF:FF`，将广播到与交换机连接的所有设备。
- 连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。
- 该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。
- 主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。

### 2. ARP 解析 MAC 地址

- 主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。
- 主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。
- 该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。
- 该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。
- DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。
- 主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（`FF:FF:FF:FF:FF:FF`）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。
- 网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。

### 3. DNS 解析域名

- 知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。
- 网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。
- 因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。
- 到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。
- 找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。

### 4. HTTP 请求页面

- 有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。
- 在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。
- HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。
- 连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。
- HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。
- 浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。

