# Zookeeper

Zookeeper 提供了一种树形结构的命名空间，/app1/p_1 节点的父节点为 /app1。

<img src="images\分布式\aefa8042-15fa-4e8b-9f50-20b282a2c624.png" alt="img" style="zoom:50%;" />

**节点类型**

- 永久节点：不会因为会话结束或者超时而消失；
- 临时节点：如果会话结束或者超时就会消失；
- 有序节点：会在节点名的后面加一个数字后缀，并且是有序的，例如生成的有序节点为 /lock/node-0000000000，它的下一个有序节点则为 /lock/node-0000000001，以此类推。

**监听器**

为一个节点注册监听器，在节点状态发生改变时，会给客户端发送消息。

**分布式锁实现**

- 创建一个锁目录 /lock；
- 当一个客户端需要获取锁时，在 /lock 下创建临时的且有序的子节点；
- 客户端获取 /lock 下的子节点列表，判断自己创建的子节点是否为当前子节点列表中序号最小的子节点，如果是则认为获得锁；否则监听自己的前一个子节点，获得子节点的变更通知后重复此步骤直至获得锁；
- 执行业务代码，完成后，删除对应的子节点。

**会话超时**

如果一个已经获得锁的会话超时了，因为创建的是临时节点，所以该会话对应的临时节点会被删除，其它会话就可以获得锁了。可以看到，这种实现方式不会出现数据库的唯一索引实现方式释放锁失败的问题。

**羊群效应**

一个节点未获得锁，只需要监听自己的前一个子节点，这是因为如果监听所有的子节点，那么任意一个子节点状态改变，其它所有子节点都会收到通知（羊群效应，一只羊动起来，其它羊也会一哄而上），而我们只希望它的后一个子节点收到通知。

## 应用

**分布式协调**

![image-20220406013858750](images\分布式\image-20220406013858750.png)

A系统发送一个请求到mq，B消费该请求进行处理，A如何知道B的处理结果？用zk。

A发mq后，在zk上对某个节点（如订单orderId=1）的值注册一个监听器，一旦B处理完就修改zk上该节点的值，A立马就能收到通知，问题解决。

**分布式锁**

某个客户端尝试创建临时znode，成功则获取到锁，由此保证获得znode的客户端唯一，其他客户端来创建这个znode就会失败，只能对这个znode注册一个监听器。

释放锁就是删除znode，一旦删除会立即通知正在监听的客户端，这时等待的客户端就能获得该锁。

**元数据/配置信息管理**

zk可用作很多系统的配置信息管理，如kafka、storm和dubbo等分布式系统都会用zk做元数据/配置信息的管理。

例如将dubbo注册中心（管理多个服务A的注册）的信息存到zk上，调用者注册一个服务A的地址监听器，只要有服务A注册到dubbo就通知调用者，哪些服务A节点可用

![image-20220407003625058](images\分布式\image-20220407003625058.png)

**HA高可用性**

hadoop、hdfs、yarn等大数据系统都是用zk开发HA高可用机制，就是一个重要进程做主从备份，主进程挂了立刻通过zk感知切换到备用进程，原主进程恢复后当备份，互为主备

![image-20220407005336536](D:\CS-Note\images\分布式\image-20220407005336536.png)



# CAP理论

一个分布式系统不可能同时满足Consistency（一致性）、Availability（可用性）、Partition Tolerance（分区容错性），最多满足两项。 

## Consistency

一致性：各节点的数据保证一致（每次成功写入之后，无论从哪个节点读取，都能读取到最新数据），相当于向所有节点的写操作是原子操作（要么全部失败要么全部成功）。

## Availability

可用性：每次向未崩溃的节点发送请求，总能保证收到响应数据（允许不是最新数据，允许一定延迟）。 一致性C和可用性A在分布式环境下是无法兼顾的

- 若要保证一致性：则必须进行节点间数据同步，**同步期间数据锁定**，导致期间的读取失败或超时，破坏了可用性；
- 若要保证可用性：则不允许节点间同步期间锁定，这又破坏了一致性。

## Partition tolerance

**网络分区**指分布式系统中的节点被划分为多个区域，每个区域内部可以通信，但是区域之间无法通信。

在分区容忍性条件下，分布式系统在遇到任何网络分区故障的时候，仍然需要能对外提供一致性和可用性的服务，除非是整个网络环境都发生了故障。

## 权衡

在分布式系统中，分区容忍性P必不可少，因为需要总是假设网络是不可靠的。因此，CAP 理论实际上是要在可用性C和一致性A之间做权衡。

可用性和一致性往往是冲突的，很难使它们同时满足。在多个节点之间进行数据同步时，

- 为了保证一致性（CP），不能访问未同步完成的节点（同步期间**锁定**），也就失去了部分可用性；
- 为了保证可用性（AP），允许读取所有节点的数据（同步期间不锁定），但是又可能导致数据不一致。

**典型CP系统**

Zookeeper、Redis集群

**典型AP系统**

SpringCloud Eureka



## BASE

是基本可用（Basically Available）、软状态（Soft State）和最终一致性（Eventually Consistent）三个短语的缩写。

BASE 理论是对 CAP 中的**CA**权衡的结果，基本可用和软状态是对A的妥协，最终一致性是对C的妥协

它的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。

### 基本可用

指分布式系统在出现故障的时候，保证核心可用，允许损失部分可用性。

例如，电商在做促销时，为了保证购物系统的稳定性，部分消费者可能会被引导到一个降级的页面。

### 软状态

指允许系统中的数据存在**中间状态**，并认为该中间状态不会影响系统整体可用性，即允许系统不同节点的数据副本之间进行同步的过程存在时延。

### 最终一致性

最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能达到一致的状态。

ACID 要求强一致性，通常运用在传统的数据库系统上。而 BASE 要求最终一致性，通过牺牲强一致性来达到可用性，通常运用在大型分布式系统中。

在实际的分布式场景中，不同业务单元和组件对一致性的要求是不同的，因此 ACID 和 BASE 往往会结合在一起使用。

# 分布式锁

java内置锁只能对单jvm有效，若是分布式环境则失效，需要其他解决方案

## 1. 数据库的唯一索引

## 2. Redis 的 SETNX 指令

- 加锁命令：SETNX key value，当键不存在时，对键进行设置操作并返回成功，否则返回失败。KEY 是锁的唯一标识，一般按业务来决定命名。
- 解锁命令：DEL key，通过删除键值对来释放锁，以便其他线程可以通过 SETNX 命令来获取锁。
- 锁超时：EXPIRE key timeout, 设置 key 的超时时间，以保证即使锁没有被显式释放，锁也可以在一定时间后自动释放，避免资源被永远锁住。

## 3. Redis 的 RedLock 算法

- 尝试从 N 个互相独立 Redis 实例获取锁；
- 计算获取锁消耗的时间，只有时间小于锁的过期时间，并且从大多数（N / 2 + 1）实例上获取了锁，才认为获取锁成功；
- 如果获取锁失败，就到每个实例上释放锁。

## 4. Zookeeper锁

某个客户端尝试创建临时znode，成功则获取到锁，由此保证获得znode的客户端唯一，其他客户端来创建这个znode就会失败，只能对这个znode注册一个监听器。

释放锁就是删除znode，一旦删除会立即通知正在监听的客户端，这时等待的客户端就能获得该锁。

# 分布式定时任务

## 1. 单机定时任务

sprintboot的@Scheduled注解，使用cron表达式表示定时任务周期

缺点：

- 功能相对简单，可用性差；部署效率低，开发和维护成本高，不方便管理和控制，尤其在多系统的环境；
- 任务跟踪和告警难以实现。

## 2. 分布式定时任务

运行在分布式集群环境下的调度任务，同⼀个定时任务程序**部署多份**，则同一时刻应当只允许⼀个定时任务执行。

优点：

- 集群的方式进行管理调度，更高效，降低开发和维护成本
- 分布式部署，保证系统高可用性，伸缩性，负载均衡，提高容错；
- 任务可持久化到库，并有完善的重做机制、任务跟踪和告警。

# 

# 分布式事务

# 分布式ID

在开发中，我们通常会需要一个唯一ID来标识数据，如果是单体架构，我们可以通过数据库的主键，或直接在内存中维护一个自增数字来作为ID都是可以的，但对于一个分布式系统，就会有可能会出现ID冲突，此时有以下解决方案：

1. uuid，这种方案复杂度最低，但是会影响存储空间和性能
2. 利用单机数据库的自增主键，作为分布式ID的生成器，复杂度适中，ID长度较之uuid更短，但是受到单机数据库性能的限制，并发量大的时候，此方案也不是最优方案
3. 利用redis、zookeeper的特性来生成id，比如redis的自增命令、zookeeper的顺序节点，这种方案和单机数据库(mysql)相比，性能有所提高，可以适当选用
4. 雪花算法，一切问题如果能直接用算法解决，那就是最合适的，利用雪花算法也可以生成分布式ID，底层原理就是通过某台机器在某一毫秒内对某一个数字自增，这种方案也能保证分布式架构中的系统id唯一，但是只能保证趋势递增。业界存在tinyid、leaf等开源中间件实现了雪花算法。

# 一致性哈希

**背景**

分布式系统中移除或者添加一个服务器时，需要尽可能小地改变已存在的服务请求与处理请求服务器之间的映射关系。一致性哈希解决了简单哈希算法在分布式[哈希表](https://link.segmentfault.com/?enc=p5OInMW%2F3WSZJ2KGlosPvg%3D%3D.wHQzjtg98brugvAMWUH5UQcNSPlsjqS19iRWDulfLadBLHhAH7UoXjTMYo6zEk7uh6YTnppjEI%2FzP%2BJpK7aAIjOfBPjKMI2NMTb4IA3Slgw%3D)（Distributed Hash Table，DHT）中存在的动态伸缩等问题 。

## 优点

- 可扩展性。一致性哈希算法保证了增加或减少服务器时，数据存储的改变最少，相比传统哈希算法大大节省了数据移动的开销 。

- 更好地适应数据的快速增长。采用一致性哈希算法分布数据，当数据不断增长时，部分虚拟节点中可能包含很多数据、造成数据在虚拟节点上分布不均衡，此时可以将包含数据多的虚拟节点分裂，这种分裂仅仅是将原有的虚拟节点一分为二、不需要对全部的数据进行重新哈希和划分。

  虚拟节点分裂后，如果物理服务器的负载仍然不均衡，只需在服务器之间调整部分虚拟节点的存储分布。这样可以随数据的增长而动态的扩展物理服务器的数量，且代价远比传统哈希算法重新分布所有数据要小很多。

## 一致性哈希算法与哈希算法的关系

一致性哈希算法是在哈希算法基础上提出的，在动态变化的分布式环境中，哈希算法应该满足的几个条件：平衡性、单调性和分散性。

- 平衡性：是指 hash 的结果应该平均分配到各个节点，这样从算法上解决了负载均衡问题。
- 单调性：是指在新增或者删减节点时，不影响系统正常运行。
- 分散性：是指数据应该分散地存放在分布式集群中的各个节点（节点自己可以有备份），不必每个节点都存储所有的数据。

## 原理

通过一个叫作一致性哈希环的数据结构实现。这个环的起点是 0，终点是 2^32 - 1，并且起点与终点连接，故这个环的整数分布范围是 `[0, 2^32-1]`，如下图所示：

<img src="images\分布式\image-20220414161411266.png" alt="image-20220414161411266" style="zoom: 80%;" />

### 1. 定位算法

1. 计算节点哈希，放到哈希环

2. 计算对象哈希，放到哈希环

3. 为每个对象寻找存放节点：在哈希环上**顺时针**找距离该对象最近的节点


Object A、Object B、Object C、Object D四个数据对象，经过哈希计算后，在环空间上的位置如下：

<img src="images\分布式\image-20220414161437805.png" alt="image-20220414161437805" style="zoom:50%;" />

根据一致性哈希算法，数据A会被定位到Node A上，B被定位到Node B上，C被定位到Node C上，D被定位到Node D上：

<img src="images\分布式\image-20220414161501236.png" alt="image-20220414161501236" style="zoom: 67%;" />



### 2. 节点减少

现假设Node C宕机，可以看到此时对象A、B、D不会受到影响，只有C对象被重定位到Node D。

### 3. 节点增加

<img src="images\分布式\image-20220414161551189.png" alt="image-20220414161551189" style="zoom: 67%;" />

此时对象Object A、B、D不受影响，只有对象C需要重定位到新的Node X 。一般的，在一致性哈希算法中，如果增加一台服务器，则受影响的数据仅仅是新服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它数据也不会受到影响。

综上所述，一致性哈希算法对于节点的增减都只需重定位环空间中的**一小部分**数据，具有较好的容错性和可扩展性。

### 4. 虚拟节点

节点太少时（如只有两个）可能造成数据在节点的分布不均匀，大量数据集中到某个节点。

解决办法是引入虚拟节点，即对每一个节点计算**多个哈希**，每个哈希位置都放置一个虚拟节点，**本质是增加分散性**。如下图，节点A和B都计算三个哈希

<img src="images\分布式\image-20220414161618218.png" alt="image-20220414161618218" style="zoom: 67%;" />

数据的定位算法不变，只是多了一步虚拟节点到实际节点的映射，即Node A#1、Node A#2和Node A#3最终都定位到实际节点A，Node B亦然。

# 幂等性

幂等性是系统服务对外一种承诺，承诺只要调用接口成功，外部多次调用对系统的影响是一致的。声明为幂等的服务会认为外部调用失败是常态，并且失败之后必然会有重试。

## **什么情况下需要幂等**

以SQL为例：

SELECT col1 FROM tab1 WHER col2=2，无论执行多少次都不会改变状态，是天然的幂等。
UPDATE tab1 SET col1=1 WHERE col2=2，无论执行成功多少次状态都是一致的，因此也是幂等操作。
UPDATE tab1 SET col1=col1+1 WHERE col2=2，每次执行的结果都会发生变化，这种不是幂等的。
insert into user(userid,name) values(1,'a') 如userid为唯一主键，即重复操作上面的业务，只会插入一条用户数据，具备幂等性。
如userid不是主键，可以重复，那上面业务多次操作，数据都会新增多条，不具备幂等性。
delete from user where userid=1，多次操作，结果一样，具备幂等性

## **如何保证幂等**

**token机制**

1、服务端提供了发送token的接口。我们在分析业务的时候，哪些业务是存在幂等问题的，就必须在执行业务前，先去获取token，服务器会把token保存到redis中。

2、然后调用业务接口请求时，把token携带过去，一般放在请求头部。

3、服务器判断token是否存在redis中，存在表示第一次请求，然后删除token,继续执行业务。

4、如果判断token不存在redis中，就表示是重复操作，直接返回重复标记给client，这样就保证了业务代码，不被重复执行。

**关键点 先删除token，还是后删除token。**

后删除token：如果进行业务处理成功后，删除redis中的token失败了，这样就导致了有可能会发生重复请求，因为token没有被删除。这个问题其实是数据库和缓存redis数据不一致问题，后续会写文章进行讲解。

先删除token：如果系统出现问题导致业务处理出现异常，业务处理没有成功，接口调用方也没有获取到明确的结果，然后进行重试，但token已经删除掉了，服务端判断token不存在，认为是重复请求，就直接返回了，无法进行业务处理了。

先删除token可以保证不会因为重复请求，业务数据出现问题。出现业务异常，可以让调用方配合处理一下，重新获取新的token，再次由业务调用方发起重试请求就ok了。
**token机制缺点**
业务请求每次请求，都会有额外的请求（一次获取token请求、判断token是否存在的业务）。其实真实的生产环境中，1万请求也许只会存在10个左右的请求会发生重试，为了这10个请求，我们让9990个请求都发生了额外的请求。

**乐观锁机制**

这种方法适合在更新的场景中，`update t_goods set count = count -1 , version = version + 1 where good_id=2 and version = 1`
根据version版本，也就是在操作库存前先获取当前商品的version版本号，然后操作的时候带上此version号。我们梳理下，我们第一次操作库存时，得到version为1，调用库存服务version变成了2；但返回给订单服务出现了问题，订单服务又一次发起调用库存服务，当订单服务传如的version还是1，再执行上面的sql语句时，就不会执行；因为version已经变为2了，where条件就不成立。这样就保证了不管调用几次，只会真正的处理一次。
乐观锁主要使用于处理读多写少的问题

**唯一主键**
这个机制是利用了数据库的主键唯一约束的特性，解决了在insert场景时幂等问题。但主键的要求不是自增的主键，这样就需要业务生成全局唯一的主键。

如果是分库分表场景下，路由规则要保证相同请求下，落地在同一个数据库和同一表中，要不然数据库主键约束就不起效果了，因为是不同的数据库和表主键不相关。

**防重表**
使用订单号orderNo做为去重表的唯一索引，把唯一索引插入去重表，再进行业务操作，且他们在同一个事务中。这个保证了重复请求时，因为去重表有唯一约束，导致请求失败，避免了幂等问题。这里要注意的是，去重表和业务表应该在同一库中，这样就保证了在同一个事务，即使业务操作失败了，也会把去重表的数据回滚。这个很好的保证了数据一致性。

**唯一ID**
调用接口时，生成一个唯一id，redis将数据保存到集合中（去重），存在即处理过。