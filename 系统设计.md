# 登录

# 限流

分为单Java级别限流和网关限流

## 网关限流

微服务部署多个java进程，因此需要从入口网关处限流。主要是用nginx，一是控制速率，二是控制并发连接数。

- 控制速率：使用 limit_req_zone 用来限制单位时间内的请求数

  ```
  limit_req_zone $binary_remote_addr zone=mylimit:10m rate=2r/s;
  server { 
      location / { 
          limit_req zone=mylimit;
      }
  }
  ```

  限制每个 IP 访问的速度为 2r/s，因为 Nginx 的限流统计是基于毫秒的，rate = 2r/s，转换一下就是 500ms 内单个 IP 只允许通过 1 个请求。

- 控制并发连接数：利用 limit_conn_zone 和 limit_conn 两个指令

  ```
  limit_conn_zone $binary_remote_addr zone=perip:10m;
  limit_conn_zone $server_name zone=perserver:10m;
  server {
      ...
      limit_conn perip 10;
      limit_conn perserver 100;
  }
  ```

  limit_conn perip 10 ：表示限制单个 IP 同时最多能持有 10 个连接；

  limit_conn perserver 100 ：表示 server 同时能处理并发连接的总数为 100 个。

## spring限流

接口层面，用计数器cnt记录调用数，到达限额max就拒绝

```java
@RestController
@RequestMapping("/api/v1/batmgr")
public class BatchMgrController {
    private static final int max = 5;
    private volatile Integer cnt = 0;
    @GetMapping("testCzz")
    public Integer testCzz (@RequestParam(name = "i") Integer i) throws InterruptedException {
        if (cnt < max) {
            logger.warn("i={}， 当前cnt={}",i, cnt);
            cnt ++; 
            Thread.sleep(10000); // 执行接口主逻辑
            cnt --; // 执行完成后计数自减
            return i;
        } else {
            logger.warn("i={}, cnt={} 到达限流max",i, cnt);
            return -1;
        }
    }
}
```

问题：高并发环境下，由于cnt达限的if判断和cnt自增操作不是原子性，可能同时有超过限额的访问进入if，限流不起效。

在被调用端使用guava的RateLimiter，基于令牌桶算法，用`acquire()`等待令牌执行。

> 常用的限流算法有**令牌桶和和漏桶**
>
> 漏桶算法：把请求比作是水，水来了都先放进桶里，并以限定的速度出水。当加水速度超过出水速度时，最后会导致水直接溢出，即拒绝服务。该算法可以强行限死出水速率，适合在**调用方**限流。
>
> 令牌桶算法：以恒定的速率向桶中放入令牌，当令牌桶满时不再放入，只能取出。每个请求需要消耗一个令牌，取不到令牌则拒绝请求。该算法不仅可以限制请求频率（桶空时，且消耗速度大于放入速度），还能应对突发的大量请求（桶满时），适合做**被调用方**限流。

```java
//创建令牌桶实例
private RateLimiter rateLimiter =  RateLimiter.create(5);  // 每秒5个令牌
public Integer testCzz (@RequestParam(name = "i") Integer i)  {
    rateLimiter.acquire(); // 阻塞等待令牌
    return i;
     if (!rateLimiter.tryAcquire(100, TimeUnit.MICROSECONDS)) {
            logger.warn("i={}, 到达限流max",i);
            return -1;
        }
}
```

调用端：

```java
@GetMapping("testLimit")
public void testLimit() throws ExecutionException, InterruptedException {
    int threadNum = 10;
    ExecutorService executorService = Executors.newCachedThreadPool();
    for (int i = 0; i < threadNum; i++) {
        int finalI = i;
        executorService.execute(() -> {
            Integer res = orderBatMgrApi.testCzz(finalI);  // RPC
            logger.warn("res: {}, ts:{}", res, Instant.now());
        });
    }
    executorService.shutdown();
}
```

观察输出：

```
res: 2, ts:2023-06-29T07:50:12.418Z
res: 7, ts:2023-06-29T07:50:12.419Z
res: 0, ts:2023-06-29T07:50:12.423Z
res: 1, ts:2023-06-29T07:50:12.421Z
res: 4, ts:2023-06-29T07:50:12.421Z
res: 8, ts:2023-06-29T07:50:12.423Z
res: 5, ts:2023-06-29T07:50:12.617Z
res: 9, ts:2023-06-29T07:50:12.816Z
res: 6, ts:2023-06-29T07:50:13.017Z
res: 3, ts:2023-06-29T07:50:13.217Z
```

可以看到一开始就允许5个令牌，从res=8起，每1000/5=200ms释放一个令牌

还可用`tryAcquire()`，若拿不到令牌就等待

```java
private RateLimiter rateLimiter =  RateLimiter.create(5);
public Integer testCzz (@RequestParam(name = "i") Integer i)  {
    if (!rateLimiter.tryAcquire(100, TimeUnit.MICROSECONDS)) {  //  等待100ms
        logger.warn("i={}, 到达限流max",i);
        return -1;
    }
    return i;
}
```

从res=5开始，经过0ms、200ms、400ms……依次释放一个令牌，而tryAcquire只等待100ms后重试，因此res=5之后的令牌都等待超时返回-1

```
res: 7, ts:2023-06-29T08:01:37.548Z
res: 3, ts:2023-06-29T08:01:37.547Z
res: 9, ts:2023-06-29T08:01:37.548Z
res: 0, ts:2023-06-29T08:01:37.549Z
res: 6, ts:2023-06-29T08:01:37.548Z
res: 5, ts:2023-06-29T08:01:37.550Z
res: -1, ts:2023-06-29T08:01:37.551Z
res: -1, ts:2023-06-29T08:01:37.552Z
res: -1, ts:2023-06-29T08:01:37.552Z
res: -1, ts:2023-06-29T08:01:37.553Z
```



# 订单

# 断点续传



