# 0.架构设计

```ascii
           1  ┌───────────┐  2  ┌───────────┐  7  ┌───────────┐
Request  ────>│   User    │────>│  Account  │<────│ Clearing  │
              └───────────┘     └───────────┘     └───────────┘
                                     3│                 ▲
                                      ▼                 │
                                ┌───────────┐           │
                                │   Order   │          6│
                                └───────────┘           │
                                     4│                 │
                                      ▼                 │
                                ┌───────────┐  5  ┌───────────┐
                                │ Sequence  │────>│   Match   │
                                └───────────┘     └───────────┘
                                                        │
                                                        ▼
                                                  ┌───────────┐
Market   <────────────────────────────────────────│ Quotation │
                                                  └───────────┘
```

当一个请求进入交易系统后，首先由用户系统（User）识别用户身份，然后由账户系统（Account）对用户资产进行冻结，买入冻结USD，卖出冻结BTC，冻结如果成功，订单就进入定序系统（Sequence）。

经过定序的订单被送入撮合引擎（Match）。

当撮合引擎输出了成交结果后，该成交记录由清算系统（Clearing）进行清算。清算的工作就是把买单冻结的USD扣掉，并加上买入所得的BTC，同时，把卖单冻结的BTC扣掉，并加上卖出所得的USD。根据taker／maker的费率，向买卖双方收取手续费。

清算系统完成清算后，更新订单状态，再通知用户，用户就可以查询到买卖的成交情况。

在撮合引擎输出成交记录给清算系统的同时，它还把去除用户和订单相关信息的成交记录输出给行情系统（Quotation），由行情系统保存市场的成交价、成交量等信息，并输出实时价格、K线图等技术数据，以便公开市场查询。

## 基于数据库

订单全部存入数据库，并且，每次撮合都基于数据库的订单进行排序，这种完全基于数据库操作，并通过数据库事务保证数据一致性的交易系统，显然性能有限，并且，对数据库的硬件配置有非常高的要求。实际上，这种交易系统的处理能力每秒在100左右，提升系统性能完全依靠数据库服务器的硬件升级

## 基于内存撮合

使用内存撮合的订单处理速度每秒可高达100万，但清算仍然是基于数据库事务，是整个系统的瓶颈，因此，系统的订单处理能力大约能提升到每秒1000单

## 基于内存撮合清算

全内存模型和前面两种设计模型有个很大的区别，就是并不需要多线程并发处理，而是依赖**单线程无锁模型**，让所有计算全部在内存中完成，反而可以轻松获得10万+的量级。

好处是极高的处理速度，此外另一个好处是硬件成本很低，原因是内存非常便宜，单机32G内存就可以轻松实现每秒10万的订单处理速度。注意这里的每秒10万订单是指用户下单到订单撮合、清算全部完毕的整个流程，而不是单独指某个模块的处理速度。

缺点是由于内存的易失性，因为不再通过数据库事务保证数据一致性，如果遭遇宕机、断电等系统故障，交易系统必须能可靠地恢复整个系统的状态

# 1.定序系统

为什么需要设计一个定序系统？因为交易系统的所有订单是一个有序队列。不同的用户在同一时刻下单，也必须由定序系统确定先后顺序。

首先定义要接收的事件消息，它包含一个Sequence ID、上一个Sequence ID以及一个可选的用于去重的全局唯一ID：

```java
public class AbstractEvent extends AbstractMessage {
    // 定序后的Sequence ID:
    public long sequenceId;
    // 定序后的Previous Sequence ID:
    public long previousId;
    // 可选的全局唯一标识:
    @Nullable
    public String uniqueId;
}
```

定序系统接收的事件仅包含可选的`uniqueId`，忽略`sequenceId`和`previousId`。定序完成后，把`sequenceId`和`previousId`设置好，再发送给下游。

`SequenceService`用于接收上游消息、定序、发送消息给下游：

```java
@Component
public class SequenceService {
    @Autowired
    SequenceHandler sequenceHandler;
    // 全局唯一递增ID:
    private AtomicLong sequence;
    // 接收消息并定序再发送:
    synchronized void processMessages(List<AbstractEvent> messages) {
        // 定序后的事件消息:
        List<AbstractEvent> sequenced = null;
        try {
            // 定序:
            sequenced = this.sequenceHandler.sequenceMessages(this.messageTypes, this.sequence, messages);
        } catch (Throwable e) {
            // 定序出错时进程退出:
            logger.error("exception when do sequence", e);
            System.exit(1);
            throw new Error(e);
        }
        // 发送定序后的消息:
        sendMessages(sequenced);
    }
}
```

`SequenceHandler`是真正写入Sequence ID并落库的，在`SequenceService`中调用`SequenceHandler`是因为我们写入数据库时需要利用Spring提供的声明式数据库事务，而消息的接收和发送并不需要被包含在数据库事务中。

## Q：如何在定序器重启后正确初始化下一个序列号？

正确初始化下一个序列号实际上就是要把一个正确的初始值给`AtomicLong sequence`字段。可以读取数据库获得当前最大的Sequence ID，这个Sequence ID就是上次最后一次定序的ID。

## Q：如何在定序器崩溃后自动恢复？

由于任何一个时候都只能有一个定序器工作，这样才能保证Sequence ID的正确性，因此，无法让两个定序器同时工作。

虽然无法让两个定序器同时工作，但可以让两个定序器以主备模式同时运行，仅主定序器工作。当主定序器崩溃后，备用定序器自动切换为主定序器接管后续工作即可。

为了实现主备模式，可以启动两个定序器，然后抢锁的形式确定主备。抢到锁的定序器开始工作，并定期刷新锁，未抢到锁的定序器定期检查锁。可以用数据库锁实现主备模式。

## Q：如何解决定序的性能瓶颈？

通常来说，消息系统的吞吐量远超数据库。定序的性能取决于批量写入数据库的能力。首先要**提高数据库的性能**，其次考虑按Sequence ID进行分库，但分库会提高定序的复杂度，也会使下游从数据库读取消息时复杂度增加。最后，可以考虑使用专门针对时序优化的数据库，但这样就不如MySQL这种数据库通用、易用。

# 2.交易引擎

## 1.1.资产系统

**用户资产**：用户以各种方式将USD、BTC充入交易所后的余额

用户在买入BTC时，需要花费USD，而卖出BTC后，获得USD。当用户下单买入时，系统会先冻结对应的USD金额；当用户下单卖出时，系统会先冻结对应的BTC。

> 之所以需要有**冻结**这一操作，是因为判断能否下单成功，是根据用户的可用资产判断。每下一个新的订单，就会有一部分可用资产被冻结，因此，用户资产本质上是一个由用户ID和资产ID标识的二维表。

使用双层map表示资产： `用户ID -> (资产ID -> Asset)`



在`AssetService`上定义对用户资产的操作。实际上，所有资产操作只有一种操作，即转账。转账类型可用`Transfer`定义为枚举类：

```java
public enum Transfer {
    // 可用转可用:
    AVAILABLE_TO_AVAILABLE,
    // 可用转冻结:
    AVAILABLE_TO_FROZEN,
    // 冻结转可用:
    FROZEN_TO_AVAILABLE;
}
```

转账操作只需要一个`tryTransfer()`方法，实现如下：

```java
public boolean tryTransfer(Transfer type, Long fromUser, Long toUser, AssetEnum assetId, BigDecimal amount, boolean checkBalance) {
    // 转账金额不能为负:
    if (amount.signum() < 0) {
        throw new IllegalArgumentException("Negative amount");
    }
    // 获取源用户资产:
    Asset fromAsset = getAsset(fromUser, assetId);
    if (fromAsset == null) {
        // 资产不存在时初始化用户资产:
        fromAsset = initAssets(fromUser, assetId);
    }
    // 获取目标用户资产:
    Asset toAsset = getAsset(toUser, assetId);
    if (toAsset == null) {
        // 资产不存在时初始化用户资产:
        toAsset = initAssets(toUser, assetId);
    }
    return switch (type) {
        case AVAILABLE_TO_AVAILABLE -> {
            // 需要检查余额且余额不足:
            if (checkBalance && fromAsset.available.compareTo(amount) < 0) {
                // 转账失败:
                yield false;
            }
            // 源用户的可用资产减少:
            fromAsset.available = fromAsset.available.subtract(amount);
            // 目标用户的可用资产增加:
            toAsset.available = toAsset.available.add(amount);
            // 返回成功:
            yield true;
        }
            // 从可用转至冻结:
        case AVAILABLE_TO_FROZEN -> {
            if (checkBalance && fromAsset.available.compareTo(amount) < 0) {
                yield false;
            }
            fromAsset.available = fromAsset.available.subtract(amount);
            toAsset.frozen = toAsset.frozen.add(amount);
            yield true;
        }
            // 从冻结转至可用:
        case FROZEN_TO_AVAILABLE -> {
            if (checkBalance && fromAsset.frozen.compareTo(amount) < 0) {
                yield false;
            }
            fromAsset.frozen = fromAsset.frozen.subtract(amount);
            toAsset.available = toAsset.available.add(amount);
            yield true;
        }
        default -> {
            throw new IllegalArgumentException("invalid type: " + type);
        }
    };
}
```

除了用户存入资产时，需要调用`tryTransfer()`并且不检查余额，因为此操作是从系统负债账户向用户转账，其他常规转账操作均需要检查余额：

```java
public void transfer(Transfer type, Long fromUser, Long toUser, AssetEnum assetId, BigDecimal amount) {
    if (!tryTransfer(type, fromUser, toUser, assetId, amount, true)) {
        throw new RuntimeException("Transfer failed");
    }
}
```

冻结和解冻操作，其实都是在`tryTransfer()`基础上封装。



测试验证：交易所要保证任意操作后，所有用户资产的各余额总和为0（有一个特殊账户--系统账户，用户充值实际上是系统账户对用户账户转账，整个系统无外部金额输入，总和应为0）。

```java
public class AssetServiceTest {
    @Test
    void tryTransfer() {
        // TODO...
    }
}
```



###  Q：为什么不使用数据库？

因为我们要实现的交易引擎是100%全内存交易引擎，因此所有用户资产均存放在内存中，无需访问数据库。

### Q：为什么要使用ConcurrentMap？

**并不是为了让多线程并发写入，而是为了多线程读**

使用`ConcurrentMap`并不是为了让多线程并发写入，因为`AssetService`中并没有任何同步锁。对`AssetService`进行写操作必须是单线程，不支持多线程调用`tryTransfer()`。

但是读取Asset支持多线程并发读取，这也是使用`ConcurrentMap`的原因。如果改成`HashMap`，根据不同JDK版本的实现不同，多线程读取`HashMap`可能造成死循环（注意这不是`HashMap`的bug），必须引入同步机制。

### Q：如何扩展以支持更多的资产类型？

我们在`AssetEnum`中以枚举方式定义了USD和BTC两种资产，如果要扩展到更多资产类型，可以以整型ID作为资产ID，同时需要管理一个资产ID到资产名称的映射，这样可以在业务需要的时候更改资产名称。



## 1.2.订单系统

一个订单由订单ID唯一标识。为简化设计，该对象既作为订单系统的订单对象，也作为数据库映射实体。包含以下重要字段：

- userId：订单关联的用户ID；
- sequenceId：定序ID，相同价格的订单根据定序ID进行排序；
- direction：订单方向：买或卖；
- price：订单价格；
- quantity：订单数量；
- unfilledQuantity：尚未成交的数量；
- status：订单状态，包括等待成交、部分成交、完全成交、部分取消、完全取消。



创建订单：先**冻结**要交易的资产（买入冻结USD，卖出冻结BTC），再创建。一个订单被成功创建后，它后续由撮合引擎处理时，只有`unfilledQuantity`和`status`会发生变化，其他属性均为只读，不会改变。

删除订单：当订单状态变为完全成交、部分取消、完全取消时，订单就已经处理完成。处理完成的订单从订单系统中删除，并写入数据库永久变为历史订单。用户查询活动订单时，需要读取订单系统，用户查询历史订单时，只需从数据库查询，就与订单系统无关了。

 

根据业务需要，订单系统需要支持：

- 根据订单ID查询到订单；
- 根据用户ID查询到该用户的所有活动订单。

因此，`OrderService`需要用两个`Map`存储活动订单：

activeOrders：跟踪所有活动订单`map<OrderID, OrderEntity>`

userOrders：二维map，跟踪用户活动订单`map<UserID, Map<OrderID, OrderEntity>>`

添加和删除Order，要更新这两个map。

```java
/**
 * 创建订单，失败返回null:
 */
public OrderEntity createOrder(long sequenceId, long ts, Long orderId, Long userId, Direction direction, BigDecimal price, BigDecimal quantity) {
    switch (direction) {
    case BUY -> {
        // 买入，需冻结USD：
        if (!assetService.tryFreeze(userId, AssetEnum.USD, price.multiply(quantity))) {
            return null;
        }
    }
    case SELL -> {
        // 卖出，需冻结BTC：
        if (!assetService.tryFreeze(userId, AssetEnum.BTC, quantity)) {
            return null;
        }
    }
    default -> throw new IllegalArgumentException("Invalid direction.");
    }
    // 实例化Order:
    OrderEntity order = new OrderEntity();
    order.id = orderId;
    order.sequenceId = sequenceId;
    order.userId = userId;
    order.direction = direction;
    order.price = price;
    order.quantity = quantity;
    order.unfilledQuantity = quantity;
    order.createdAt = order.updatedAt = ts;
    // 添加到ActiveOrders:
    this.activeOrders.put(order.id, order);
    // 添加到UserOrders:
    ConcurrentMap<Long, OrderEntity> uOrders = this.userOrders.get(userId);
    if (uOrders == null) {
        uOrders = new ConcurrentHashMap<>();
        this.userOrders.put(userId, uOrders);
    }
    uOrders.put(order.id, order);
    return order;
}
```



### Q：Order的id和sequenceId为何不合并使用一个ID？

订单ID是Order.id，是用户看到的订单标识，而Order.sequenceId是系统内部给订单的定序序列号，用于后续撮合时进入订单簿的排序，两者功能不同。

可以使用一个简单的算法来根据Sequence ID计算Order ID：

```
OrderID = SequenceID * 10000 + today("YYmm")
```

因为SequenceID是全局唯一的，我们给SequenceID添加创建日期的"YYmm"部分，可轻松实现按月分库保存和查询。



## 1.3 撮合引擎

撮合引擎是交易系统的核心。本质上就是维护一个**买卖盘**列表，然后按价格优先原则对订单进行撮合，能够成交的就输出成交结果，不能成交的放入买卖盘。这里注意没有时间优先原则，因为经过定序的订单队列已经是一个时间优先的队列了。

### 订单薄OrderBook

用来表示买卖盘

买盘排序：价格高在前，价格相同时间早在前

卖盘排序：价格低在前，价格相同时间早在前

首先考虑list，但插入删除效率低，因此用红黑树（TreeMap实现），以**定序id**比较时间

> 订单上虽然保存了创建时间，但排序时，是根据定序ID即`sequenceId`来排序，以确保全局唯一。时间本身实际上是订单的一个普通属性，仅展示给用户，不参与业务排序。

### 撮合引擎MatchEngine

定义`MatchEngine`核心数据结构如下：

```java
public class MatchEngine {
    public final OrderBook buyBook = new OrderBook(Direction.BUY); // 买盘
    public final OrderBook sellBook = new OrderBook(Direction.SELL); // 卖盘
    public BigDecimal marketPrice = BigDecimal.ZERO; // 最新市场价
    private long sequenceId; // 上次处理的Sequence ID
}
```

一个完整的撮合引擎包含一个买盘、一个卖盘和一个最新成交价（初始值为0）。撮合引擎的输入是一个`OrderEntity`实例，每处理一个订单，就输出撮合结果`MatchResult`。

对于撮合交易来说，如果新订单是一个买单，则首先尝试在卖盘中匹配价格合适的卖单，如果匹配成功则成交。

> 一个大的买单可能会匹配多个较小的卖单。当买单被完全匹配后，说明此买单已完全成交，处理结束，否则，如果存在未成交的买单，则将其放入买盘。处理卖单的逻辑是类似的。

已经挂在买卖盘的订单称为挂单（Maker），当前正在处理的订单称为吃单（Taker），一个Taker订单如果**未完全成交**则转为Maker挂在买卖盘。

核心处理方法定义如下：

```java
public MatchResult processOrder(long sequenceId, OrderEntity order) {
    return switch (order.direction) {
            // 买单与sellBook匹配，（如果还有剩）最后放入buyBook:
        case BUY -> processOrder(sequenceId, order, this.sellBook, this.buyBook);
            // 卖单与buyBook匹配，（如果还有剩）最后放入sellBook:
        case SELL -> processOrder(sequenceId, order, this.buyBook, this.sellBook);
        default -> throw new IllegalArgumentException("Invalid direction.");
    };
}
MatchResult processOrder(long sequenceId, OrderEntity takerOrder, OrderBook makerBook, OrderBook anotherBook) {
    ...
}
```

撮合结果记录在`MatchResult`中，它可以用一个Taker订单和一系列撮合匹配记录表示：

```java
public class MatchResult {
    public final Order takerOrder;
    public final List<MatchDetailRecord> MatchDetails = new ArrayList<>();
    // 构造方法略
}
```

 每一笔撮合记录则由成交双方、成交价格与数量表示：

```java
public record MatchDetailRecord(BigDecimal price, BigDecimal quantity, OrderEntity takerOrder, OrderEntity makerOrder) {
}
```

根据价格匹配，直到成交双方有一方完全成交或成交条件不满足时结束处理，`processOrder()`的业务逻辑代码：

```java
/**
     * @param sequenceId 定序id
     * @param takerOrder  当前正在处理的订单
     * @param makerBook   尝试匹配成交的OrderBook（对手盘）
     * @param anotherBook 未能完全成交后挂单的OrderBook
     * @return 成交结果
     */
private MatchResult processOrder(long sequenceId, OrderEntity takerOrder, OrderBook makerBook,
                                 OrderBook anotherBook) {
    this.sequenceId = sequenceId;
    long ts = takerOrder.createdAt;
    MatchResult matchResult = new MatchResult(takerOrder);
    BigDecimal takerUnfilledQuantity = takerOrder.quantity;
    // 一直循环，每次取maker（对手盘）第一个，目标是将taker完全匹配完
    for (;;) {
        OrderEntity makerOrder = makerBook.getFirst();
        if (makerOrder == null) {
            // 对手盘不存在:
            break;
        }
        if (takerOrder.direction == Direction.BUY && takerOrder.price.compareTo(makerOrder.price) < 0) {
            // 买入订单价格比卖盘第一档价格低:
            break;
        } else if (takerOrder.direction == Direction.SELL && takerOrder.price.compareTo(makerOrder.price) > 0) {
            // 卖出订单价格比买盘第一档价格高:
            break;
        }
        // 以Maker价格成交:
        this.marketPrice = makerOrder.price;
        // 待成交数量为两者较小值:
        BigDecimal matchedQuantity = takerUnfilledQuantity.min(makerOrder.unfilledQuantity);
        // 成交记录:（价格、数量、maker
        matchResult.add(makerOrder.price, matchedQuantity, makerOrder);
        // 更新成交后的订单数量:
        // taker数量减去待成交数量
        takerUnfilledQuantity = takerUnfilledQuantity.subtract(matchedQuantity);
        BigDecimal makerUnfilledQuantity = makerOrder.unfilledQuantity.subtract(matchedQuantity);
        // 对手盘完全成交后，从订单簿中删除:
        // 即看成交后的订单数是否为0
        if (makerUnfilledQuantity.signum() == 0) {
            makerOrder.updateOrder(makerUnfilledQuantity, OrderStatus.FULLY_FILLED, ts);
            makerBook.remove(makerOrder);
        } else {
            // 对手盘部分成交:
            makerOrder.updateOrder(makerUnfilledQuantity, OrderStatus.PARTIAL_FILLED, ts);
        }
        // Taker订单完全成交后，退出循环:
        if (takerUnfilledQuantity.signum() == 0) {
            takerOrder.updateOrder(takerUnfilledQuantity, OrderStatus.FULLY_FILLED, ts);
            break;
        }
    } // end for
    // Taker订单未完全成交时，放入买/卖订单簿:
    if (takerUnfilledQuantity.signum() > 0) {
        takerOrder.updateOrder(takerUnfilledQuantity,
                               takerUnfilledQuantity.compareTo(takerOrder.quantity) == 0 ? OrderStatus.PENDING
                               : OrderStatus.PARTIAL_FILLED,
                               ts);
        anotherBook.add(takerOrder);
    }
    return matchResult;
}
```



## 1.4 清算系统

要把撮合结果最终实现为买卖双方的资产交换，就需要清算。清算系统就是处理撮合结果，将买卖双方冻结的USD和BTC分别交换到对方的可用余额，就使得买卖双方真正完成了资产交换。

设计清算系统`ClearingService`，需要引用`AssetService`和`OrderService`：

```java
public class ClearingService {
    final AssetService assetService;
    final OrderService orderService;

    public ClearingService(@Autowired AssetService assetService, @Autowired OrderService orderService) {
        this.assetService = assetService;
        this.orderService = orderService;
    }
}
```

撮合引擎输出`MatchResult`后，`ClearingService`需要处理该结果，，该清算方法代码框架如下：

```java
public void clearMatchResult(MatchResult result) {
    OrderEntity taker = result.takerOrder;
    switch (taker.direction) {
    case BUY -> {
        // TODO
    }
    case SELL -> {
        // TODO
    }
    default -> throw new IllegalArgumentException("Invalid direction.");
    }
}
```

### 买入

买家冻结的USD转入卖方账户，卖方冻结的BTC转入买方账户。

> 对Taker买入成交的订单，处理时需要注意，成交价格是按照Maker的报价成交的，而Taker冻结的金额是按照Taker订单的报价冻结的，因此，解冻后，部分差额要退回至Taker可用余额
>
> 交易资产在哪冻结的？创建订单时。

```java
// 买入时，按Maker的价格成交：
case BUY -> {
     // 遍历撮合结果的所有匹配记录
    for (MatchDetailRecord detail : result.matchDetails) {
        OrderEntity maker = detail.makerOrder();
        BigDecimal matched = detail.quantity();
        if (taker.price.compareTo(maker.price) > 0) {
            // 实际买入价比报价低，部分USD退回账户:
            BigDecimal unfreezeQuote = taker.price.subtract(maker.price).multiply(matched);
            assetService.unfreeze(taker.userId, AssetEnum.USD, unfreezeQuote);
        }
        // 买方USD转入卖方账户:
        assetService.transfer(Transfer.FROZEN_TO_AVAILABLE, taker.userId, maker.userId, AssetEnum.USD, maker.price.multiply(matched));
        // 卖方BTC转入买方账户:
        assetService.transfer(Transfer.FROZEN_TO_AVAILABLE, maker.userId, taker.userId, AssetEnum.BTC, matched);
        // 删除完全成交的Maker:
        if (maker.unfilledQuantity.signum() == 0) {
            orderService.removeOrder(maker.id);
        }
    }
    // 删除完全成交的Taker:
    if (taker.unfilledQuantity.signum() == 0) {
        orderService.removeOrder(taker.id);
    }
}
```

### 卖出

**卖家出BTC，换买家的USD**

对Taker卖出成交的订单，只需将冻结的BTC转入Maker，将Maker冻结的USD转入Taker即可：

> 这里不用考虑差价，因为设计下单时，卖单冻结的是BTC，换成USD直接按挂单价换算即可。

```java
case SELL -> {
    for (MatchDetailRecord detail : result.matchDetails) {
        OrderEntity maker = detail.makerOrder();
        BigDecimal matched = detail.quantity();
        // 卖方BTC转入买方账户:
        assetService.transfer(Transfer.FROZEN_TO_AVAILABLE, taker.userId, maker.userId, AssetEnum.BTC, matched);
        // 买方USD转入卖方账户:
        assetService.transfer(Transfer.FROZEN_TO_AVAILABLE, maker.userId, taker.userId, AssetEnum.USD, maker.price.multiply(matched));
        // 删除完全成交的Maker:
        if (maker.unfilledQuantity.signum() == 0) {
            orderService.removeOrder(maker.id);
        }
    }
    // 删除完全成交的Taker:
    if (taker.unfilledQuantity.signum() == 0) {
        orderService.removeOrder(taker.id);
    }
}
```





## 1.5 完成交易引擎

把上述模块整合，实现一个完整的交易引擎：

```java
public class TradingEngineService {
    @Autowired
    AssetService assetService;

    @Autowired
    OrderService orderService;

    @Autowired
    MatchEngine matchEngine;

    @Autowired
    ClearingService clearingService;
}
```

### 整合定序系统

交易引擎由事件驱动，因此，通过订阅Kafka的Topic实现批量读消息，然后依次处理每个事件。由于【定序系统】的作用，消息的sequenceId应该**严格递增**，考虑消息重复和消息丢失两种情况：

```java
void processMessages(List<AbstractEvent> messages) {
    for (AbstractEvent message : messages) {
        processEvent(message);
    }
}

void processEvent(AbstractEvent event) {
    // 重复消息，丢弃
    if (event.sequenceId <= this.lastSequenceId) {
        logger.warn("skip duplicate event: {}", event);
        return;
    }	
    // 丢失了消息，从数据库读取恢复
    if (event.previousId > this.lastSequenceId) {
        List<AbstractEvent> events = storeService.loadEventsFromDb(this.lastSequenceId);
        if (events.isEmpty()) {    // 读取失败
            System.exit(1);
            return;
        }
        for (AbstractEvent e : events) { // 处理丢失的消息
            this.processEvent(e);
        }
        return;
    }
    // 判断当前消息是否指向上一条消息
    if (event.previousId != lastSequenceId) {
        System.exit(1);  // 不满足说明【系统异常】，退出
        return;
    }
    if (event instanceof OrderRequestEvent) {
        createOrder((OrderRequestEvent) event);
    } else if (event instanceof OrderCancelEvent) {
        cancelOrder((OrderCancelEvent) event);
    } else if (event instanceof TransferEvent) {
        transfer((TransferEvent) event);
    }
}
```

这样，对消息系统的依赖就不是要求它100%可靠，遇到重复消息、丢失消息，交易引擎都可以从这些错误中自己恢复。

目前一共有3种类型的事件：创建订单、取消订单、转账，处理都非常简单。以`createOrder()`为例，核心代码很少：

```java
void createOrder(OrderRequestEvent event) {
    // 生成Order ID:
    long orderId = event.sequenceId * 10000 + (year * 100 + month);
    // 创建Order:
    OrderEntity order = orderService.createOrder(event.sequenceId, event.createdAt, orderId, event.userId, event.direction, event.price, event.quantity);
    if (order == null) {
        logger.warn("create order failed.");
        return;
    }
    // 撮合:
    MatchResult result = matchEngine.processOrder(event.sequenceId, order);
    // 清算:
    clearingService.clearMatchResult(result);
}
```

### 异步处理

核心的业务逻辑并不复杂，只是交易引擎在处理完订单后，仅仅改变自身状态是不够的，它还得向外输出具体的成交信息、订单状态等。

因此，需要根据业务需求，在清算后继续收集撮合结果、已完成订单、准备发送的通知等，通过消息系统或Redis向外输出交易信息。

如果把这些功能放到同一个线程内同步完成是非常耗时的，更好的方法是把它们先存储起来，再**异步处理**。

例如，对于已完成的订单，可以异步落库：

```java
Queue<List<OrderEntity>> orderQueue = new ConcurrentLinkedQueue<>();

void createOrder(OrderRequestEvent event) {
    ...
    // 清算完成后,收集已完成Order:
    if (!result.matchDetails.isEmpty()) {
        List<OrderEntity> closedOrders = new ArrayList<>();
        if (result.takerOrder.status.isFinalStatus) {
            closedOrders.add(result.takerOrder);
        }
        for (MatchDetailRecord detail : result.matchDetails) {
            OrderEntity maker = detail.makerOrder();
            if (maker.status.isFinalStatus) {
                closedOrders.add(maker);
            }
        }
        this.orderQueue.add(closedOrders);
    }
}

// 启动一个线程将orderQueue的Order异步写入数据库:
void saveOrders() {
    // TODO:
}
```

类似的，输出OrderBook、通知用户成交等信息都是异步处理。

### 验证模块

由于资产、订单、撮合、清算都在内存中完成，如何保证交易引擎每处理一个事件，它的内部状态都是正确的呢？我们可以为交易引擎增加一个自验证功能，在debug模式下，每处理一个事件，就自动验证内部状态的完整性，包括：

- 验证资产系统总额为0，且除负债账户外其余账户资产不为负；
- 验证订单系统未成交订单所冻结的资产与资产系统中的冻结一致；
- 验证订单系统的订单与撮合引擎的订单簿一对一存在。

```java
void processEvent(AbstractEvent event) {
    ...
    if (debugMode) {
        this.validate();
    }
    void validate() {
        logger.debug("start validate...");
        validateAssets();
        validateOrders();
        validateMatchEngine();
        logger.debug("validate ok.");
    }
}
```

这样我们就能快速在开发阶段尽可能早地发现问题。

### Q：交易引擎崩溃后如何恢复？

交易引擎如果运行时崩溃，可以重启，然后把现有的**所有交易事件重头开始执行一遍**，即可得到最新的状态。

注意到重头开始执行交易事件，会导致重复发出市场成交、用户订单通知等事件，因此，可根据时间做判断，不再重复发通知。下游系统在处理通知事件时，也要根据通知携带的`sequenceId`做去重判断。

### Q：如果现有的交易事件太多，恢复需要花费几天，怎么办？

可以定期把交易引擎的**状态序列化**至文件系统，例如，每10分钟一次。当交易引擎崩溃时，读取最新的状态文件，即可恢复至约10分钟前的状态，后续追赶只需要执行很少的事件消息。

交易引擎的状态包括：

- 资产系统的状态：即所有用户的资产列表；
- 订单系统的状态：即所有活动订单列表；
- 撮合引擎的状态：即买卖盘和最新市场价；
- 最后一次处理的sequenceId。

序列化时，分别针对每个子系统进行序列化。对资产系统来说，每个用户的资产可序列化为`用户ID: [USD可用, USD冻结, BTC可用, BTC冻结]`的JSON格式，整个资产系统序列化后结构如下：

```json
{
    "1": [-123000, 0, -12.3, 0],
    "100": [60000, 20000, 9, 0],
    "200": [43000, 0, 3, 0.3]
}
```

订单系统可序列化为一系列活动订单列表：

```json
[
    { "id": 10012207, "sequenceId": 1001, "price": 20901, ...},
    { "id": 10022207, "sequenceId": 1002, "price": 20902, ...},
]
```

撮合引擎可序列化为买卖盘列表（仅包含订单ID）：

```json
{
    "BUY": [10012207, 10022207, ...],
    "SELL": [...],
    "marketPrice": 20901
}
```

最后合并为一个交易引擎的状态文件：

```json
{
    "sequenceId": 189000,
    "assets": { ... },
    "orders": [ ... ],
    "match": { ... }
}
```

交易引擎启动时，读取状态文件，然后依次恢复资产系统、订单系统和撮合引擎的状态，就得到了指定`sequenceId`的状态。

写入状态时，如果是异步写入，需要先复制状态、再写入，防止多线程读同一实例导致状态不一致。读写JSON时，要使用JSON库的流式API（例如Jackson的Streaming API），以免内存溢出。对`BigDecimal`进行序列化时，要注意不要误读为`double`类型以免丢失精度。

# 3.API系统

# 4.行情系统

# 5.推送系统





