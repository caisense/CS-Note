# 0.架构设计

```ascii
           1  ┌───────────┐  2  ┌───────────┐  7  ┌───────────┐
Request  ────>│   User    │────>│  Account  │<────│ Clearing  │
              └───────────┘     └───────────┘     └───────────┘
                                     3│                 ▲
                                      ▼                 │
                                ┌───────────┐           │
                                │   Order   │          6│
                                └───────────┘           │
                                     4│                 │
                                      ▼                 │
                                ┌───────────┐  5  ┌───────────┐
                                │ Sequence  │────>│   Match   │
                                └───────────┘     └───────────┘
                                                        │
                                                        ▼
                                                  ┌───────────┐
Market   <────────────────────────────────────────│ Quotation │
                                                  └───────────┘
```

当一个请求进入交易系统后，首先由用户系统（User）识别用户身份，然后由账户系统（Account）对用户资产进行冻结，买入冻结USD，卖出冻结BTC，冻结如果成功，订单就进入定序系统（Sequence）。

经过定序的订单被送入撮合引擎（Match）。

当撮合引擎输出了成交结果后，该成交记录由清算系统（Clearing）进行清算。清算的工作就是把买单冻结的USD扣掉，并加上买入所得的BTC，同时，把卖单冻结的BTC扣掉，并加上卖出所得的USD。根据taker／maker的费率，向买卖双方收取手续费。

清算系统完成清算后，更新订单状态，再通知用户，用户就可以查询到买卖的成交情况。

在撮合引擎输出成交记录给清算系统的同时，它还把去除用户和订单相关信息的成交记录输出给行情系统（Quotation），由行情系统保存市场的成交价、成交量等信息，并输出实时价格、K线图等技术数据，以便公开市场查询。

## 基于数据库

订单全部存入数据库，并且，每次撮合都基于数据库的订单进行排序，这种完全基于数据库操作，并通过数据库事务保证数据一致性的交易系统，显然性能有限，并且，对数据库的硬件配置有非常高的要求。实际上，这种交易系统的处理能力每秒在100左右，提升系统性能完全依靠数据库服务器的硬件升级

## 基于内存撮合

使用内存撮合的订单处理速度每秒可高达100万，但清算仍然是基于数据库事务，是整个系统的瓶颈，因此，系统的订单处理能力大约能提升到每秒1000单

## 基于内存撮合清算

全内存模型和前面两种设计模型有个很大的区别，就是并不需要多线程并发处理，而是依赖**单线程无锁模型**，让所有计算全部在内存中完成，反而可以轻松获得10万+的量级。

好处是极高的处理速度，此外另一个好处是硬件成本很低，原因是内存非常便宜，单机32G内存就可以轻松实现每秒10万的订单处理速度。注意这里的每秒10万订单是指用户下单到订单撮合、清算全部完毕的整个流程，而不是单独指某个模块的处理速度。

缺点是由于内存的易失性，因为不再通过数据库事务保证数据一致性，如果遭遇宕机、断电等系统故障，交易系统必须能可靠地恢复整个系统的状态

# 1.定序系统

为什么需要设计一个定序系统？因为交易系统的所有订单是一个有序队列。不同的用户在同一时刻下单，也必须由定序系统确定先后顺序。

#  

# 2.交易引擎

## 1.1.资产系统

100%全内存交易引擎，因此所有用户资产均存放在内存中，无需访问数据库。

使用双层map表示资产： 用户ID -> (资产ID -> Asset)

用ConcurrentMap并不是为了让多线程并发写入，而是为了多线程读

保证任意操作后，所有用户资产的各余额总和为0。

 

## 1.2.订单系统

OrderEntity 既作为订单系统的订单对象，也作为数据库映射实体。

先**冻结**要交易的资产（买入冻结USD，卖出冻结BTC），再创建订单

一个订单被成功创建后，它后续由撮合引擎处理时，只有unfilledQuantity和status会发生变化，其他属性均为只读，不会改变。

 

当订单状态变为完全成交、部分取消、完全取消时，订单就已经处理完成。处理完成的订单从订单系统中删除，并写入数据库永久变为历史订单。用户查询活动订单时，需要读取订单系统，用户查询历史订单时，只需从数据库查询，就与订单系统无关了。

 

根据业务需要，订单系统需要支持：

- 根据订单ID查询到订单；
- 根据用户ID查询到该用户的所有活动订单。

## 1.3 撮合引擎

撮合引擎是交易系统的核心。本质上就是维护一个**买卖盘**列表，然后按价格优先原则对订单进行撮合，能够成交的就输出成交结果，不能成交的放入买卖盘。这里注意没有时间优先原则，因为经过定序的订单队列已经是一个时间优先的队列了。

### 订单薄OrderBook

用来表示买卖盘

买盘排序：价格高在前，价格相同时间早在前

卖盘排序：价格低在前，价格相同时间早在前

首先考虑list，但插入删除效率低，因此用红黑树（TreeMap实现），以**定序id**比较时间

> 订单上虽然保存了创建时间，但排序时，是根据定序ID即`sequenceId`来排序，以确保全局唯一。时间本身实际上是订单的一个普通属性，仅展示给用户，不参与业务排序。

### 撮合引擎MatchEngine

撮合结果记录在`MatchResult`中，它可以用一个Taker订单和一系列撮合匹配记录表示：

```java
public class MatchResult {
    public final Order takerOrder;
    public final List<MatchDetailRecord> MatchDetails = new ArrayList<>();

    // 构造方法略
}
```

 每一笔撮合记录则由成交双方、成交价格与数量表示：

```java
public record MatchDetailRecord(BigDecimal price, BigDecimal quantity, OrderEntity takerOrder, OrderEntity makerOrder) {
}
```



## 1.4 清算系统