# 0.架构设计

```ascii
           1  ┌───────────┐  2  ┌───────────┐  7  ┌───────────┐
Request  ────>│   User    │────>│  Account  │<────│ Clearing  │
              └───────────┘     └───────────┘     └───────────┘
                                     3│                 ▲
                                      ▼                 │
                                ┌───────────┐           │
                                │   Order   │          6│
                                └───────────┘           │
                                     4│                 │
                                      ▼                 │
                                ┌───────────┐  5  ┌───────────┐
                                │ Sequence  │────>│   Match   │
                                └───────────┘     └───────────┘
                                                        │
                                                        ▼
                                                  ┌───────────┐
Market   <────────────────────────────────────────│ Quotation │
                                                  └───────────┘
```

当一个请求进入交易系统后，首先由用户系统（User）识别用户身份，然后由账户系统（Account）对用户资产进行冻结，买入冻结USD，卖出冻结BTC，冻结如果成功，订单就进入定序系统（Sequence）。

经过定序的订单被送入撮合引擎（Match）。

当撮合引擎输出了成交结果后，该成交记录由清算系统（Clearing）进行清算。清算的工作就是把买单冻结的USD扣掉，并加上买入所得的BTC，同时，把卖单冻结的BTC扣掉，并加上卖出所得的USD。根据taker／maker的费率，向买卖双方收取手续费。

清算系统完成清算后，更新订单状态，再通知用户，用户就可以查询到买卖的成交情况。

在撮合引擎输出成交记录给清算系统的同时，它还把去除用户和订单相关信息的成交记录输出给行情系统（Quotation），由行情系统保存市场的成交价、成交量等信息，并输出实时价格、K线图等技术数据，以便公开市场查询。

## 基于数据库

订单全部存入数据库，并且，每次撮合都基于数据库的订单进行排序，这种完全基于数据库操作，并通过数据库事务保证数据一致性的交易系统，显然性能有限，并且，对数据库的硬件配置有非常高的要求。实际上，这种交易系统的处理能力每秒在100左右，提升系统性能完全依靠数据库服务器的硬件升级

## 基于内存撮合

使用内存撮合的订单处理速度每秒可高达100万，但清算仍然是基于数据库事务，是整个系统的瓶颈，因此，系统的订单处理能力大约能提升到每秒1000单

## 基于内存撮合清算

全内存模型和前面两种设计模型有个很大的区别，就是并不需要多线程并发处理，而是依赖**单线程无锁模型**，让所有计算全部在内存中完成，反而可以轻松获得10万+的量级。

好处是极高的处理速度，此外另一个好处是硬件成本很低，原因是内存非常便宜，单机32G内存就可以轻松实现每秒10万的订单处理速度。注意这里的每秒10万订单是指用户下单到订单撮合、清算全部完毕的整个流程，而不是单独指某个模块的处理速度。

缺点是由于内存的易失性，因为不再通过数据库事务保证数据一致性，如果遭遇宕机、断电等系统故障，交易系统必须能可靠地恢复整个系统的状态

# 1.定序系统

为什么需要设计一个定序系统？因为交易系统的所有订单是一个有序队列。不同的用户在同一时刻下单，也必须由定序系统确定先后顺序。

首先定义要接收的事件消息，它包含一个Sequence ID、上一个Sequence ID以及一个可选的用于去重的全局唯一ID：

```java
public class AbstractEvent extends AbstractMessage {
    // 定序后的Sequence ID:
    public long sequenceId;
    // 定序后的Previous Sequence ID:
    public long previousId;
    // 可选的全局唯一标识:
    @Nullable
    public String uniqueId;
}
```

定序系统接收的事件仅包含可选的`uniqueId`，忽略`sequenceId`和`previousId`。定序完成后，把`sequenceId`和`previousId`设置好，再发送给下游。

`SequenceService`用于接收上游消息、定序、发送消息给下游：

```java
@Component
public class SequenceService {
    @Autowired
    SequenceHandler sequenceHandler;
    // 全局唯一递增ID:
    private AtomicLong sequence;
    // 接收消息并定序再发送:
    synchronized void processMessages(List<AbstractEvent> messages) {
        // 定序后的事件消息:
        List<AbstractEvent> sequenced = null;
        try {
            // 定序:
            sequenced = this.sequenceHandler.sequenceMessages(this.messageTypes, this.sequence, messages);
        } catch (Throwable e) {
            // 定序出错时进程退出:
            logger.error("exception when do sequence", e);
            System.exit(1);
            throw new Error(e);
        }
        // 发送定序后的消息:
        sendMessages(sequenced);
    }
}
```

`SequenceHandler`是真正写入Sequence ID并落库的，在`SequenceService`中调用`SequenceHandler`是因为我们写入数据库时需要利用Spring提供的声明式数据库事务，而消息的接收和发送并不需要被包含在数据库事务中。

## Q：如何在定序器重启后正确初始化下一个序列号？

正确初始化下一个序列号实际上就是要把一个正确的初始值给`AtomicLong sequence`字段。可以读取数据库获得当前最大的Sequence ID，这个Sequence ID就是上次最后一次定序的ID。

## Q：如何在定序器崩溃后自动恢复？

由于任何一个时候都只能有一个定序器工作，这样才能保证Sequence ID的正确性，因此，无法让两个定序器同时工作。

虽然无法让两个定序器同时工作，但可以让两个定序器以主备模式同时运行，仅主定序器工作。当主定序器崩溃后，备用定序器自动切换为主定序器接管后续工作即可。

为了实现主备模式，可以启动两个定序器，然后抢锁的形式确定主备。抢到锁的定序器开始工作，并定期刷新锁，未抢到锁的定序器定期检查锁。可以用数据库锁实现主备模式。

## Q：如何解决定序的性能瓶颈？

通常来说，消息系统的吞吐量远超数据库。定序的性能取决于批量写入数据库的能力。首先要**提高数据库的性能**，其次考虑按Sequence ID进行分库，但分库会提高定序的复杂度，也会使下游从数据库读取消息时复杂度增加。最后，可以考虑使用专门针对时序优化的数据库，但这样就不如MySQL这种数据库通用、易用。

# 2.交易引擎

## 1.1.资产系统

**用户资产**：用户以各种方式将USD、BTC充入交易所后的余额

用户在买入BTC时，需要花费USD，而卖出BTC后，获得USD。当用户下单买入时，系统会先冻结对应的USD金额；当用户下单卖出时，系统会先冻结对应的BTC。

> 之所以需要有**冻结**这一操作，是因为判断能否下单成功，是根据用户的可用资产判断。每下一个新的订单，就会有一部分可用资产被冻结，因此，用户资产本质上是一个由用户ID和资产ID标识的二维表。

使用双层map表示资产： `用户ID -> (资产ID -> Asset)`



在`AssetService`上定义对用户资产的操作。实际上，所有资产操作只有一种操作，即转账。转账类型可用`Transfer`定义为枚举类：

```java
public enum Transfer {
    // 可用转可用:
    AVAILABLE_TO_AVAILABLE,
    // 可用转冻结:
    AVAILABLE_TO_FROZEN,
    // 冻结转可用:
    FROZEN_TO_AVAILABLE;
}
```

转账操作只需要一个`tryTransfer()`方法，实现如下：

```java
public boolean tryTransfer(Transfer type, Long fromUser, Long toUser, AssetEnum assetId, BigDecimal amount, boolean checkBalance) {
    // 转账金额不能为负:
    if (amount.signum() < 0) {
        throw new IllegalArgumentException("Negative amount");
    }
    // 获取源用户资产:
    Asset fromAsset = getAsset(fromUser, assetId);
    if (fromAsset == null) {
        // 资产不存在时初始化用户资产:
        fromAsset = initAssets(fromUser, assetId);
    }
    // 获取目标用户资产:
    Asset toAsset = getAsset(toUser, assetId);
    if (toAsset == null) {
        // 资产不存在时初始化用户资产:
        toAsset = initAssets(toUser, assetId);
    }
    return switch (type) {
        case AVAILABLE_TO_AVAILABLE -> {
            // 需要检查余额且余额不足:
            if (checkBalance && fromAsset.available.compareTo(amount) < 0) {
                // 转账失败:
                yield false;
            }
            // 源用户的可用资产减少:
            fromAsset.available = fromAsset.available.subtract(amount);
            // 目标用户的可用资产增加:
            toAsset.available = toAsset.available.add(amount);
            // 返回成功:
            yield true;
        }
            // 从可用转至冻结:
        case AVAILABLE_TO_FROZEN -> {
            if (checkBalance && fromAsset.available.compareTo(amount) < 0) {
                yield false;
            }
            fromAsset.available = fromAsset.available.subtract(amount);
            toAsset.frozen = toAsset.frozen.add(amount);
            yield true;
        }
            // 从冻结转至可用:
        case FROZEN_TO_AVAILABLE -> {
            if (checkBalance && fromAsset.frozen.compareTo(amount) < 0) {
                yield false;
            }
            fromAsset.frozen = fromAsset.frozen.subtract(amount);
            toAsset.available = toAsset.available.add(amount);
            yield true;
        }
        default -> {
            throw new IllegalArgumentException("invalid type: " + type);
        }
    };
}
```

除了用户存入资产时，需要调用`tryTransfer()`并且不检查余额，因为此操作是从系统负债账户向用户转账，其他常规转账操作均需要检查余额：

```java
public void transfer(Transfer type, Long fromUser, Long toUser, AssetEnum assetId, BigDecimal amount) {
    if (!tryTransfer(type, fromUser, toUser, assetId, amount, true)) {
        throw new RuntimeException("Transfer failed");
    }
}
```

冻结和解冻操作，其实都是在`tryTransfer()`基础上封装。



测试验证：交易所要保证任意操作后，所有用户资产的各余额总和为0。

```java
public class AssetServiceTest {
    @Test
    void tryTransfer() {
        // TODO...
    }
}
```



###  Q：为什么不使用数据库？

因为我们要实现的交易引擎是100%全内存交易引擎，因此所有用户资产均存放在内存中，无需访问数据库。

### Q：为什么要使用ConcurrentMap？

**并不是为了让多线程并发写入，而是为了多线程读**

使用`ConcurrentMap`并不是为了让多线程并发写入，因为`AssetService`中并没有任何同步锁。对`AssetService`进行写操作必须是单线程，不支持多线程调用`tryTransfer()`。

但是读取Asset支持多线程并发读取，这也是使用`ConcurrentMap`的原因。如果改成`HashMap`，根据不同JDK版本的实现不同，多线程读取`HashMap`可能造成死循环（注意这不是`HashMap`的bug），必须引入同步机制。

### Q：如何扩展以支持更多的资产类型？

我们在`AssetEnum`中以枚举方式定义了USD和BTC两种资产，如果要扩展到更多资产类型，可以以整型ID作为资产ID，同时需要管理一个资产ID到资产名称的映射，这样可以在业务需要的时候更改资产名称。



## 1.2.订单系统

OrderEntity 既作为订单系统的订单对象，也作为数据库映射实体。

先**冻结**要交易的资产（买入冻结USD，卖出冻结BTC），再创建订单

一个订单被成功创建后，它后续由撮合引擎处理时，只有unfilledQuantity和status会发生变化，其他属性均为只读，不会改变。

 

当订单状态变为完全成交、部分取消、完全取消时，订单就已经处理完成。处理完成的订单从订单系统中删除，并写入数据库永久变为历史订单。用户查询活动订单时，需要读取订单系统，用户查询历史订单时，只需从数据库查询，就与订单系统无关了。

 

根据业务需要，订单系统需要支持：

- 根据订单ID查询到订单；
- 根据用户ID查询到该用户的所有活动订单。

## 1.3 撮合引擎

撮合引擎是交易系统的核心。本质上就是维护一个**买卖盘**列表，然后按价格优先原则对订单进行撮合，能够成交的就输出成交结果，不能成交的放入买卖盘。这里注意没有时间优先原则，因为经过定序的订单队列已经是一个时间优先的队列了。

### 订单薄OrderBook

用来表示买卖盘

买盘排序：价格高在前，价格相同时间早在前

卖盘排序：价格低在前，价格相同时间早在前

首先考虑list，但插入删除效率低，因此用红黑树（TreeMap实现），以**定序id**比较时间

> 订单上虽然保存了创建时间，但排序时，是根据定序ID即`sequenceId`来排序，以确保全局唯一。时间本身实际上是订单的一个普通属性，仅展示给用户，不参与业务排序。

### 撮合引擎MatchEngine

撮合结果记录在`MatchResult`中，它可以用一个Taker订单和一系列撮合匹配记录表示：

```java
public class MatchResult {
    public final Order takerOrder;
    public final List<MatchDetailRecord> MatchDetails = new ArrayList<>();

    // 构造方法略
}
```

 每一笔撮合记录则由成交双方、成交价格与数量表示：

```java
public record MatchDetailRecord(BigDecimal price, BigDecimal quantity, OrderEntity takerOrder, OrderEntity makerOrder) {
}
```



## 1.4 清算系统



# 3.API系统

# 4.行情系统

# 5.推送系统





