# 网络框架笔记

## OSI七层模型

OSI（Open System Interconnection）模型是ISO组织提出的互联网标准框架，它将网络从逻辑上分为了7层，自底向上分别为：

- 物理层：利用传输介质为数据链路层提供物理连接，传输比特流；（数据在该层称为bite）
- 数据链路层：控制网络层和物理层之间的通信，将从网络层接受到的数据分割成可被物理层传输的帧；（数据在该层称为帧）
- 网络层：负责IP寻址和路由选择等工作，将网络地址转换为实际的物理地址；（数据在该层称为数据包）
- 传输层：保证数据传输的可靠性，包括数据分割、流量控制、确认/重传、差错校验等工作；定义了一些传输协议和端口号等；（数据在该层称为段）
- 会话层：负责网络中的两节点之间通信的建立、维护和终止；
- 表示层：数据格式化，加密，解密；
- 应用层：为应用程序提供网络服务；

OSI的意义在于它将服务、协议、接口三者明确区分开来：

- 服务：说明某一层为上一层提供什么功能；
- 协议：如何实现本层的服务；
- 接口：说明上层如何使用下层的服务

## TCP/IP四层模型

TCP/IP协议模型包含一系列网络协议，是互联网的基础，由OSI七层模型发展而来，将网络从逻辑上分为4层，自底向上分别为：

- 数据链路层：实现网卡接口的网络驱动程序，以处理数据在物理媒介上的传输。该层常见的协议包括：

  - ARP 地址解析协议
  - RARP 逆地址解析协议

  两者结合实现了IP地址和机器物理地址（通常是MAC地址）之间的相互转换。

  对应OSI模型的中的物理层+数据链路层。

- 网络层：实现数据包的选路和转发。WLAN使用众多分级的主机和LAN，通信中的两台主机一般不是直接相连而是通过多个中间节点（路由器）来连接的，网络层的任务就是合理正确地选择这些中间节点。该层最重要的协议有：

  - IP 因特网协议：根据数据包的目的IP地址来决定如何投递它。如果数据包不能直接发送给目标主机，那么IP协议就为它寻找一个合适的路由器（next hop），并将数据包交付给该路由器来转发。多次重复这一过程，直到数据包最终到达目标主机（或最终失败被丢弃）。可见IP协议使用逐跳（hop by hop）的方式确定通信路径。
  - ICMP 因特网报文控制协议：IP协议的重要补充，用于检测网络连接。

  对应OSI模型中的网络层。

- 传输层：提供端到端（end to end）通信。传输层只关心通信的起始端和目的端，不在乎中转过程。该层的重要协议有：

  - TCP 传输控制协议：为应用层提供可靠的、面向连接的和基于流（stream）的服务。TCP协议使用超时重传、数据确认等方式来确保数据包被正确地发送至目的端，因此TCP服务是可靠的；使用TCP协议通信的双方必须先建立TCP连接，并在内核中为该连接维持一些必要的数据结构，当通信结束时，双方必须关闭连接以释放这些内核数据；TCP服务是基于流的，数据没有边界（长度）限制，发送端可以逐个字节地向数据流中写入数据，接收端也可以逐个字节地将数据读出。
  - UDP 用户数据报协议：与TCP协议完全相反，UDP为应用层提供不可靠、无连接和基于数据报的服务，无法保证数据从发送端正确地传送到目的端。如果数据在中途丢失或者目的端通过数据校验发现数据错误而将其丢弃，UDP协议只会通知应用程序发送失败；UDP协议是无连接的，应用程序每次发送数据都要明确指定接收端的地址（IP地址）等信息；UDP是基于数据报的，每个UDP数据报都有一个长度，接收端必须以该长度为最小单位将其所有内容一次性读出，否则数据会被截断。

  对应OSI模型中的传输层。

- 应用层：负责处理应用程序的逻辑，如文件传输、名称查询和网络管理等。该层重要的协议和工具有：

  - telnet 远程登录协议：用于在本地完成远程任务。
  - QSPF 开放最短路径优先：一种动态路由更新协议，用于路由器之间的通信，以告知对方各自的路由信息，基于网络层IP协议。
  - DNS 域名服务：提供机器域名到IP地址的转换。
  - ping工具：直接使用网络层的ICMP协议检测网络连接，是调试网络环境的工具。
  - HTTP 超文本传输协议
  - FTP 文件传输协议
  - SMTP 简单邮件传输协议
  - POP3 邮局协议
  
  对应OSI模型中的应用层+表示层+会话层。

TCP/IP四层模型中，数据链路层、网络层、传输层工作在内核空间，而应用层工作在用户空间。

## TCP协议

### 三次握手四次挥手

**三次握手**

建立TCP时，客户端服务器之间需要发送三个包。目的：确认发送接收能力，指定自己的初始化序列号。

1. 初始：客户端处于closed状态， 服务器处于listen状态；
2. 客户端发送一个SYN报文，客户端处于SYN_SEND状态，seq=x；
3. 服务器收到该报文（第一次握手完成），发送自己的SYN报文回答，将客户端的seq+1作为ACK（x+1），seq=y。服务器处于SYN_REVD状态；
4. 客户端收到该报文（第二次握手完成），发送ACK报文，将服务器的seq+1作为ACK（y+1）。客户端处于Established状态；
5. 服务器收到报文（第三次握手完成），服务器处于Established状态，至此三次握手完成，连接建立。

**四次挥手**

由于TCP的半关闭性质（一端结束发送后还可继续接受），需要4次挥手来关闭TCP

1. 初始：通信双方均处于Established状态；
2. 主动方发送FIN报文，指定序列号seq=u，主动方处于FIN_WAIT1状态；
3. 被动方收到报文（第一次挥手完成），返回ACK报文，ack=u+1，seq=v，被动方处于CLOSED_WAIT状态；
4. 此时主动方到被动方的连接被释放，TCP处于半关闭状态。主动方收到ACK报文后，处于FIN_WAIT2状态（第二次挥手完成）；
5. 若被动方也想断开连接，发送FIN报文，ack=u+1，seq=w，被动方处于LAST_ACK状态；
6. 主动方收到报文后（第三次挥手完成），进入TIME_WAIT状态，发送ACK报文，ack=w+1；
7. 被动方收到报文（第四次挥手完成）后进入CLOSED状态，主动方等待2ms后进入CLOSED状态，至此四次挥手完成，连接完全关闭。

**若允许只握手两次就建立连接，可能出现的问题**

若服务器不需要客户端的ack报文就能建立连接，则可能出现以下情景：

1. 客户端发送了一个请求，但由于网络堵塞延迟了；

2. 客户端发送了第二个请求，正常建立，数据处理完关闭连接。

3. 被延迟的第一个请求达到服务器，服务器返回确认报文，单方面建立了连接，等待客户端发送数据。而客户端无视了这条确认，服务器长时间等待，造成了浪费。

**三次握手过程中可否携带数据**

第三次可以，前两次不行。因为第三次握手时客户端自身已经处于Established状态。

**为什么需要四次挥手**

因为服务器的ACK和FIN报文不能一起发送（可能存在尚未发送的报文）。

**TIME_WAIT状态存在的原因**

1. 为实现TCP全双工（full-duplex）连接的可靠释放

   假设发起关闭请求的一方发送的ACK（四次挥手过程的最后一个包）在网络中丢失，那么由于TCP的重传机制，被动方需要重发其FIN报文，在该FIN到达主动方之前，主动方必须维护这条连接的状态，即这条TCP连接对应的资源不能被立即释放或重新分配。直到重发的FIN达到，主动方也重发ACK后，该TCP连接才能恢复到CLOSED状态。如果主动方不进入TIME_WAIT以维护其连接状态，则当被动方重发的FIN达到时，会被认为有错误发生，而事实上，这是正常的关闭连接过程，并非异常。

2. 防止lost duplicate对后续新建的正常连接造成破坏

   TCP协议一个四元组（four-tuple，也称socket pair）：local_ip，local_port，remote_ip，remote_port 唯一地标识一条TCP连接。

   假设当前有一条TCP连接关闭，接着通信双方很快以相同的四元组建立一条新连接。TCP协议栈无法区分前后两条TCP连接的不同，在它看来，两者是同一条连接，先释放再建立的过程对其来说是感知不到的。若不存在TIME_WAIT状态的限制，就可能发生如下情况：

   假设新建的TCP连接在某一时刻收到的seq=1000，此时来了一个lost duplicate（旧的连接中因为连接关闭而未被接受，一直在路由之间跳转的数据包）为seq=1000，则TCP认为这个lost duplicate合法，并将其存放入了receive buffer，导致传输出现错误。

   通过设置TIME_WAIT状态，使得旧数据包在网络中到达最大跳数而被丢弃，避免破坏新的正常连接。

### TCP序列号（seq）为什么要采用随机数

1. 防止序列号预测攻击；

2. 避免数据混淆（如果从0开始，那么断开后重新建立连接会出现大量同序列号的数据包）。

### TCP拥塞控制

1. 滑动窗口机制

   传输层进行流控的一种措施，接收方通告发送方自己的窗口大小，控制发送方的发送速度，从而防止发送方发送速度过快而导致自己被淹没。

   在接收方返回的ACK报文中，有两个重要信息：1）接收方期望收到的下一字节的序列号n（注意，如果此时接收方收到了序列号大于n的报文，如n+1，接收方并不会返回n+2的ACK报文，而是继续返回n的ACK报文）；2）当前的窗口大小m。发送方在获得这两个信息后就可以得到还可以发送多少数据给接收方。

   TCP的滑动窗口分为接受窗口，发送窗口。由于TCP是双工通信协议，会话的双方都各自维护一个“发送窗口”和一个“接收窗口”。其中各自的“接收窗口”大小取决于应用、系统、硬件的限制（TCP传输速率不能大于应用的数据处理速率）；各自的“发送窗口”则取决于对端通告的“接收窗口”。

   - 发送窗口只有收到对端对于本段发送窗口内字节的ACK确认时，才会移动发送窗口的左边界；
   - 接收窗口只有在前面所有的段都确认的情况下才会移动左边界。当在前面还有字节未接收但收到后面字节的情况下，窗口不会移动，并不对后续字节确认。以此确保对端会对这些数据重传。

2. 慢启动机制

   新建立的连接不能够一开始就发送大尺寸的数据包，而只能从一个小尺寸的包开始发送，在发送和数据被对方确认的过程中去计算对方的接收速度，来逐步增加每次发送的数据量（最后到达一个稳定的值，进入高速传输阶段）。

   经典的慢启动算法NewReno中，cwnd（拥塞控制窗口）的值被初始化为10，每过一个RTT往返时间就将其翻倍，直到cwnd达到上限sshthresh（slow start threshold），然后进入拥塞避免算法。

3. 拥塞避免机制

   拥塞避免算法每过一个RTT往返时间将cwnd+1而非翻倍，避免拥塞窗口迅速增长。

4. 快速重传与恢复

## HTTP协议

### 什么是HTTP协议？

HTTP协议是一个基于请求与响应、无状态的、应用层的协议，通常基于TCP/IP协议传输数据。

HTTP的四个基于：

- 请求与响应：客户端发送请求，服务端响应请求。
- 无状态的：HTTP对事务处理没有记忆能力，每当客户端向服务端发送请求、服务端响应请求后，连接会被断开（除非使用HTTP 1.1的长连接），连接状态不会被保留。当客户端再次发起请求时，需要重新建立连接。
- 应用层：HTTP是应用层协议。
- TCP/IP：HTTP协议使用TCP作为它的支撑运输协议。

### 怎样理解HTTP协议的无状态？

常见的很多7层模型协议是有状态的，如SMTP邮件传输协议，它规定通信的第一条消息必须是HELO，用于握手；随后进行AUTH阶段，验证用户身份；然后才可以发送邮件数据；最后通过QUIT命令结束通信。

在整个传输过程中，通信双方需要时刻记住当前连接的状态，不同的状态下可接受的命令是不同的；且之前传输的数据有可能对后续的命令产生影响。

HTTP协议的每个请求是完全独立的，每个请求包含了处理该请求所需的完整的数据。即使一个HTTP请求失败了，后续的请求通常也可以继续处理，发送请求不设计状态变更。

HTTP无状态的优势在于：对于有状态协议，会话状态和连接是绑定的，如果连接意外断开，会话就会丢失，重新连接后一般需要从头开始。而HTTP无状态协议使用元数据维护会话，使会话和连接本身独立，即使连接意外断开，会话状态也不会遭到严重伤害，保持会话也不需要保持连接本身。且无状态协议对中间件友好，中间件无需了解通信双方的交互过程，只需要能正确地分片消息即可，消息可以在不同的连接上传输而不影响正确性，方便了负载均衡等组件的设计。

无状态协议的缺点在于：单个请求必须包含该请求需要的全部信息，一起发送到服务器，导致单个消息的结构比较复杂，因此HTTP协议的解析比很多协议都复杂得多。同时，这也导致了相同的数据往往会在多个请求上反复传输（如Host、Cookies、Server等元数据），一定程度上降低了协议的效率。

PS：HTTP2.0 引入了握手和GOAWAY消息，有类似TCP的流控，严格意义上算是有状态协议了。因此，“HTTP是无状态协议”的概念应该是针对其1.x版本而言的。

### Cookies/Session

Cookies和Session是两种用于从某种意义上保持HTTP连接状态的技术。

- Cookies：本质上是一小段文本信息，存储在客户端。浏览器第一次请求服务器时，如果服务器需要记住用户状态，会将Cookies颁发给客户端。下一次请求时，浏览器将网址和Cookies一起提交给服务器，服务器检查Cookies来确认用户状态。Cookies不可跨域。
- Session：保存在服务器上。浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。浏览器再次访问时服务器只需要从该Session中查找该客户的状态即可。更安全，但会占用一定的服务器资源。

结合使用两种方法：Cookies只存储Session_id，具体数据存储在服务器Session中；或将Session加密作为Cookies存储。

注意，有无Cookies和协议有无状态是两个概念。Cookies/Session的意义是创建和维护多组独立的状态，此处的状态指的是整个服务的状态而非协议本身有无状态。

### HTTP请求报文

HTTP请求报文由四部分组成：

- 请求行

  包括三部分：请求方法、请求地址、协议版本

  - 请求方法：HTTP定义的8种请求方法之一
  - 请求地址：URL（统一资源定位符）地址，其组成为：<协议>://<主机>:<端口>/<路径>，端口和路径有时可省略。GET请求时可带参数。
  - 协议版本：如HTTP/1.0和HTTP/1.1。

- 请求头部

  为请求报文添加一些附加信息，如Host（接受请求的服务器地址），Connection（连接相关的属性，如Connection:keep-alive）等。

- 空行

  请求头部的最后会带上一个空行，用于分隔开请求头部和请求数据。非常重要，不可缺少。

- 请求数据

  实际的请求数据，如POST方法的请求数据可以是用户名/密码等。该部分为可选，部分请求方法如GET就没有请求数据。

### HTTP中的请求方法

HTTP提供了8种请求方法：

GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE。

### HTTP的GET和POST方法

GET和POST方法是最常用的HTTP请求方法，两者的语义上的区别为：

- GET：从指定的资源请求数据；
- POST：向指定的资源提交请求的数据；

具体的区别细节有：

- GET在浏览器回退时是无害的，而POST会再次提交请求；
- GET请求会被浏览器主动cache，而POST不会，除非手动设置；
- GET请求只能进行url编码，而POST支持多种编码方式；
- GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留；
- GET请求在URL中传送的参数是有长度限制，而POST没有；
- 对参数的数据类型，GET只接受ASCII字符，而POST没有限制；
- GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息；
- GET参数通过URL传递，POST放在Request body中（根本原因）。

### 常见的HTTP状态码

HTTP状态码为3位数字，分为6类：

- 1xx：指示信息：表示请求已接收，继续处理。
- 2xx：成功：表示请求已被成功接收、理解、接受。
- 3xx：重定向：要完成请求必须进行更进一步的操作。
- 4xx：客户端错误：请求有语法错误或请求无法实现。
- 5xx：服务器端错误：服务器未能实现合法的请求。
- 600：源站没有返回响应头部，只返回实体内容。

具体地有：

- 100：继续。表示已收到请求的一部分，请求者继续提出请求的剩余部分；
- 200：成功。响应成功；
- 201：已创建。请求成功且服务器已创建了新的资源；
- 202：已接受。服务器已接受请求但尚未处理；
- 301：永久移动。请求的网页已永久移动到新位置，自动将请求者转到新位置；
- 302：临时移动。服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求；
- 400：错误请求。请求有语法错误，不能被服务器识别；
- 403：禁止。服务器收到请求，但拒绝提供服务（认证失败）；
- 404：未找到。请求资源不存在；
- 500：服务器内部错误。
- 502：错误网关。服务器作为网关或代理，从上游服务器收到无效响应；
- 504：网关超时。服务器作为网关或代理，没有及时从上游服务器收到请求。 

### HTTP响应报文

类似请求报文，HTTP响应报文同样由四部分组成：

- 状态行

  包括三部分：协议版本、状态码、状态码描述；

- 响应头部

  作用类似请求头部，为响应报文添加一些附加信息，如Server、Content-Type（响应正文的类型，图片/二进制字符串）、Content- Language（响应正文的语言）等；

- 空行

  同样的，响应头部的最后会带上一个空行，用于分隔开响应头部和响应数据；

- 响应数据

  返回给客户端的实际数据。

### HTTP1.0和HTTP1.1的区别

相对于HTTP1.0，HTTP1.1版本主要的改进有：

1. 缓存处理。在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。
2. 带宽优化。HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了。HTTP1.1在请求头引入了range头域，允许只请求资源的某个部分，返回码是206（Partial Content），有利于充分利用带宽和连接。
3. 错误通知。HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。
4. Host头处理。HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），且共享一个IP地址。HTTP1.1的请求消息和响应消息都需要支持Host头域，且请求消息中若没有Host头域会报告错误（400 Bad Request）。
5. 长连接。HTTP1.1支持长连接和请求的流水线处理：即在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。HTTP1.1默认开启Connection:keep-alive。

### HTTP和HTTPS的区别

HTTP的缺陷：数据以明文传输，若攻击者截获了Web浏览器和服务器之间的传输报文，就可以直接获取其中的信息，因此HTTP不适合传输一些敏感信息如密码、信用卡号等。

HTTPS即安全层套接字超文本传输协议（HTTP over SSL/TLS），在HTTP协议的基础上加入SSL（安全套接字层）或TLS（传输层安全协议），依靠证书来验证服务器身份。目前SSL 3.0已经被弃用，应当使用TLS协议，TLS 1.0版本基于SSL 3.0开发而来。

------

**TLS协议：**

TLS协议可分为两层，底层的TLS记录协议和上层的TLS握手协议：

- TLS记录协议：负责使用对称密码对消息进行加密；

- TLS握手协议：负责在客户端和服务器端商定使用的密码算法和共享密钥，以及证书认证等。

同样运行在SSL/TLS安全框架上的还有SMTP协议、POP3协议等。

------

使用HTTPS通信的步骤：

1. 客户端使用HTTPS的URL访问Web服务器，要求建立SSL连接；
2. Web服务器收到请求后，将网站的证书信息（其中包含公钥）发送给客户端；
3. 客户端与Web服务器协商SSL加密等级；
4. 客户端根据双方同意的安全等级，建立会话密钥，然后利用Web服务器的公钥将其加密发送给服务器；
5. Web服务器使用自身维护的私钥解密得到会话密钥；
6. Web服务器使用会话密钥与客户端进行通信；

该过程中为什么需要CA认证：防止中间人攻击。引入CA后，服务器将自己的公钥交给CA认证机构，并请求认证证书，客户端拿到证书后从证书中获得公钥信息，从而确保拿到的公钥是服务器的（而不是中间攻击者伪造的）。

总结HTTP和HTTPS的区别，主要有以下几点：

1. HTTP是明文传输协议，HTTPS则是加密传输协议；
2. HTTP和HTTPS使用不同的连接方式，默认端口也不同，HTTP是80，HTTPS是443；
3. HTTPS协议需要向CA申请证书，因而需要一定费用；

### 浏览器地址栏键入URL，按下回车之后经历的流程？

1. Web浏览器向DNS服务器请求解析该URL中的域名所对应的IP地址；
2. 解析出IP地址后，Web浏览器根据该IP地址和默认端口80，和Web服务器建立TCP连接；
3. Web浏览器发出读取文件（URL中域名后面部分对应的文件）的HTTP 请求，该请求报文作为TCP三次握手的第三个报文的数据发送给服务器；
4. Web服务器对Web浏览器请求作出响应，并把对应的html文本发送给浏览器；
5. Web服务器释放TCP连接；
6. Web浏览器解析该html文本并显示内容。

## DNS域名服务

域名解析：通过主机名，得到主机名对应的IP地址的过程。

### DNS寻址的过程

- 第一阶段：本地主机

  1. 首先检查浏览器缓存，然后检查系统缓存和本地hosts文件，是否有该网址的映射。若存在，直接调用这个IP地址映射，解析完成；
  2. 若浏览器缓存和hosts文件中都没有该网址的映射，则查找本地DNS解析器缓存，若存在则调用映射，解析完成，否则向本地DNS服务器发起查询。

- 第二阶段：本地DNS服务器

  3. 向TCP/IP参数中设置的首选DNS服务器（本地DNS服务器）发起查询。服务器收到查询时，若在本地配置区域资源中包含查询的域名，则返回解析结果给客户端，完成域名解析，此解析具有权威性；若查询的域名不由本地DNS服务器解析，但服务器缓存了此网址的映射关系，同样返回解析结果，结束查询，但此解析不具有权威性。

- 第三阶段：网络DNS服务器

  4. 如果本地DNS服务器也失效，则本地DNS服务器首先将请求发至根DNS服务器。以`www.baidu.com `为例，根DNS服务器收到请求后，首先判断域名` .com `由谁授权管理，并返回` .com `顶级域名服务器的IP，本地DNS服务器收到顶级域名服务器IP信息后，继续向该顶级域名服务器IP发送请求；若` .com `顶级域名服务器无法解析，则会找到负责这个域名的下一级DNS服务器` baidu.com `的IP地址并返回给本地DNS服务器，本地DNS服务器再向该域名服务器发起查询，循环直至查询到映射，将解析结果返回本地DNS服务器，再由本地DNS服务器返回解析结果，查询完成。最终的查询结果只有两种：要查询的IP地址，或查询失败。
  5. 若本地DNS服务器（或其他任何域名服务器，根服务器除外）设置了转发器，则当查询请求失败时，会将请求转至其他DNS服务器进行查询，其他DNS若同样无法完成解析，则再将转请求转发到它们设置的转发目标服务器上，直至查询到目标IP地址，或最终失败。

其中，步骤4就是通常理解的“迭代模式”查询，在该过程中，客户端负责向本地DNS服务器发出一次查询请求，而本地DNS服务器则重复向其他域名服务器发出查询请求，直到获得结果或查询失败，类似函数的迭代循环。

而步骤5则是所谓的“递归模式”查询，在该过程中，发出请求的服务器转发请求后，后续查询处理便交由被转发请求的服务器处理，被转发的服务器有可能可以解析域名或继续将请求转发...结果最终返回给最初发出请求的服务器，整个过程类似函数的递归调用。

### DNS缓存机制

DNS域名服务中存在三种缓存：浏览器缓存、操作系统缓存、本地DNS服务器缓存。查询过程中，优先查找浏览器缓存，若未命中则查询操作系统缓存，最后再访问本地DNS服务器。

DNS服务器缓存通过维护一个ttl（time to live）值表明一条缓存的有效时间，操作系统缓存参考该值，而浏览器缓存与ttl值无关，每种浏览器使用固定的值。

