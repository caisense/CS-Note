

# SQL执行过程

1. 通过连接器跟客户端**「建立连接」**

2. 通过查询**「缓存查询」**之前是否有查询过该 sql

3. - 有则直接返回结果
   - 没有则执行第三步

4. 通过分析器**「分析该 sql 的语义」**是否正确，包括格式，表等等

5. 通过优化器**「优化该语句」**，比如选择索引，join 表的连接顺序

6. **「验证权限」**，验证是否有该表的查询权限

7. - 没有则返回无权限的错误
   - 有则执行第六步

8. 通过执行器调用存储引擎执行该 sql，然后返回**「执行结果」**

   <img src="https://mmbiz.qpic.cn/mmbiz_png/9dwzhvuGc8aP3ZujaVhV3NucRZQWuMRAd82LHexY0tlTDHzVsAAtVzHKGBR08yzt3OYGHOV8kZibu6K68b7vgOQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom: 50%;" />

# 索引

数据库索引是 DBMS 中一个 排序的数据结构，以 协助快速查询、更新 数据库表中数据，通俗地说相当于目录。索引的实现通常使用 B 树以及变种 B+ 树。

## B树

B 树索引，又称 **平衡树索引**。MySQL、Oracle 和 SQL Server 数据库默认的都是 B 树索引（实际是用 B+ 树实现，只是查看表索引时打印BTREE）

<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/45016e98-6879-4709-8569-262b2d6d60b9.png" alt="img" style="zoom:50%;" />

### m阶B树性质

1. 若节点关键字（键）个数为k，则子节点个数（即指针个数）为k+1
2. 键和数据一起存放
3. 非叶节点由键+指针构成
   - 键两侧各有一个指针
   - 键左边指针指向**小于等于**当前关键字的子节点，右边则**大于等于**（见上图）
   - 键从小到大排列
4. 根节点：
   - 最少2个子节点，最多m个（m阶的含义）
   - 最少1个键，最多m-1个
5. 非根节点：
   - 最少$\lceil m/2 \rceil$个子节点，最多m个
   - 最少$\lceil m/2 \rceil$-1个键，最多m-1个
6. 叶节点：
   - 在同一层
   - 只放元素，没有指针

### 查找过程

B树索引中，从根节点开始，二分查找节点，直到叶节点，这步在磁盘进行

定位叶节点后，将整个节点载入内存，在节点中查找关键字

### 更新操作

#### 插入

#### 删除

1. 直接删除

   被删除关键字所在节点键数满足 大于 $\lceil m/2 \rceil$-1，则直接删除

2. 兄弟够借

   被删除键所在节点键数刚好为$\lceil m/2 \rceil$-1，则删除后不满足b树性质，需要从兄弟节点借一个

   如下图，3阶b树，删除24，则该节点键数为0，不满足最少1个的约束，需要从左兄弟借一个21（不绝对，从右兄弟借也可）

   <img src="D:\CS-Note\images\MySQL\image-20220126171936792.png" alt="image-20220126171936792" style="zoom: 67%;" />

   借来之后21比父节点23小，需要再交换调整：

   <img src="D:\CS-Note\images\MySQL\image-20220126172239296.png" alt="image-20220126172239296" style="zoom:67%;" />

3. 兄弟不够借

### 最大高度

即节点最少

根最少2个子节点，非叶最少$\lceil m/2 \rceil$个子节点



### 最小高度log~m~n

每层都满，则所有节点之和为

1+m+m^2^+m^3^....+m^h−1^ = (m^h−1^)/(m−1)

每个节点都放满，则每个节点键最多为m-1，所有关键字上限为

（m-1) * (m^h−1^)/(m−1) =  (m^h−1^)

记关键字数量为n，则n <=  (m^h−1^)，得

h >= log~m~n

最小高度为：$$log_mn$$

## B+树

**b树**结构如下

![B树.png](D:\CS-Note\images\MySQL\1629446588-fpMLVA-B树.png)

**b+树**结构：

![B_ Tree.png](D:\CS-Note\images\MySQL\1629448733-VWjqZc-B_ Tree.png)

#### 改进

b+树由b树改进而来，大部分性质相同，与b树的不同在于：

- 所有的非叶结点只存储 **关键字信息**，不放数据；所有数据都放叶子（b树非叶也放数据）
- 所有叶子节点之间都有一个链指针。

#### 优点

- 只存放键，不存放值，因此，一次读取，可以在同一内存页中获取更多的键，有利于更快地缩小查找范围
- 叶结点由一条链相连，因此当需要进行一次**全数据遍历** 的时候，B+ 树只需要使用 O(logN) 时间找到最小结点，然后通过链进行 O(N) 的顺序遍历即可；或者在**范围查找**时，B+ 树只需要找到该关键字然后沿着链表遍历即可。


#### 是否m越大越好

不管是内存中的数据，还是磁盘中的数据，操作系统都是按页（一页大小通常是 4KB，这个值可以通过 getconfig PAGE_SIZE 命令查看）来读取的，一次会读一页的数据。**如果要读取的数据量超过一页的大小，就会触发多次 IO 操作。**所以，我们在选择 m 大小的时候，要尽量让每个节点的大小等于一个页的大小。读取一个节点，只需要一次磁盘 IO 操作



## 最左前缀匹配原则

最左优先，以最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询(>、<、between、in、like)就会停止匹配。（注意是索引顺序的最左，与查询条件的顺序无关，因为优化器能调整条件的顺序）

例如：

1. 如果建立(a,b)顺序的索引，我们的条件只有b=xxx，是匹配不到(a,b)索引的；
2. 若查询条件是a = 1 and b = 2或者b=2 and a=1就可以，因为优化器会自动调整a,b的顺序，并不需要严格按照索引的顺序来；
3. 如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，因为c字段是一个范围查询，它之后的字段会停止匹配。而索引(a,b,d,c)能被用到，因为范围查询的c列在索引的最后，且条件a、b、c的顺序能任意调整


### 原理

索引的底层是一颗B+树，那么联合索引也还是一颗B+树，只不过联合索引的健值数量不是一个，而是多个。构建一颗B+树只能根据一个值来构建，因此数据库依据联合索引最左的字段来构建B+树。

例如联合索引(a,b)的B+树：

<img src="D:\CS-Note\images\最左前缀匹配B+树.png" width="500px">

先按a值排序，当a值相等时，才按b值排序。因此当a用范围查询时，b是无序的，无法使用索引，即索引某列是**范围查询**时，其右侧的列无法使用索引。

 

### 注意

只是MySQL有这个限制，Oracle任意顺序都可以



## Hash索引和B+树索引区别

1. hash无法**范围查询**，但**等值查询**更快（缺点是不稳定，当hash碰撞频繁时性能差，而B+树查询效率稳定）
2. hash不支持索引排序
3. hash不支持模糊查询、多列索引的最左前缀匹配（因为hash不可预测）
4. hash避免不了回表查询，而B+树在聚簇索引、覆盖索引等可只用索引完成





## 添加索引原则

很少使用的列不加索引

取值范围太小的列不加（如性别只有两种，区分度低，加索引意义不大）

特殊数据类型不加（text、image和 bit）

有外键的列必须加

## 索引失效场景

1. 违反最左前缀法则（对非最右端的索引使用范围条件>、<、between、in、等）

2. 不要在索引上做任何操作（计算、函数、自动/手动类型转换），不然会导致索引失效而转向全表扫描

3. 使用不等于（！= 或者 < >）判断时

4. 使用 is null / is not null 判断

5. 使用like

6. 索引字段是字符串，但查询时不加引号

7. 使用or

以上都会导致索引失效，而转向全表扫描

## 聚簇索引

并不是一种索引类型，而是一种数据存储方式，将 **数据存储** 和 **索引** 放到一起，找到索引也就找到了数据。

MySQL 里只有 INNODB 表支持聚簇索引，INNODB 表数据本身就是聚簇索引，非叶子节点按照主键顺序存放，叶子节点存放主键以及对应的行记录。所以对 INNODB 表进行全表顺序扫描会非常快。

特点：

- 检索效率高，磁盘IO少（索引和数据放一起）

- 表的物理存储依据聚簇索引的结构，所以一个数据表只能有一个聚簇索引，但可以拥有多个非聚簇索引；
- 一般而言，会在频繁使用、排序的字段上创建聚簇索引。

### 非聚簇索引

除了聚簇索引以外的其他索引。也是 B 树结构，与聚簇索引的存储结构不同之处在于，非聚簇索引中不存储真正的数据行，只包含一个指向数据行的**指针**。

就简单的 SQL 查询来看，分为 `SELECT` 和 `WHERE` 两个部分，索引的创建也是以此为根据的，分为 **复合索引** 和 **覆盖索引**。

![聚簇索引.png](D:\CS-Note\images\MySQL\1628676447-LHnlSz-聚簇索引.png)

## 为什么推荐使用自增 id 作为主键？

1. 普通索引的 B+ 树上存放的是主键索引的值，如果该值较大，会**「导致普通索引的存储空间较大」**
2. 使用自增 id 做主键索引新插入数据只要放在该页的最尾端就可以，直接**「按照顺序插入」**，不用刻意维护
3. 页分裂容易维护，当插入数据的当前页快满时，会发生页分裂的现象，如果主键索引不为自增 id，那么数据就可能从页的中间插入，页的数据会频繁的变动，**「导致页分裂维护成本较高」**

# 存储引擎

##  InnoDB

InnoDB实现了四个标准隔离级别，是MySQL 默认的事务型存储引擎，因此默认隔离级别也是可重复读。通过多版本并发控制（MVCC）+ Next-Key Locking 防止幻读。



## MyISAM

设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。

## 比较

|                  | InnoDB             | MyISAM                |
| ---------------- | ------------------ | --------------------- |
| 事务             | 支持               | 不支持                |
| 外键             | 支持               | 不                    |
| 主键（唯一索引） | 必须有             | 可以没有              |
| 索引             | 聚簇索引           | 非聚簇索引            |
| count            | 不保存表具体行数   | 用一个变量保存        |
| 日志             | redo log           | 没有                  |
| 锁               | 表锁和行锁         | 只有表锁              |
| 存储文件         | 表定义frm、数据ibd | frm、数据myd、myi索引 |

## InnoDB执行更新语句流程

用以下语句来举例，c 字段无索引，id 为主键索引

```
update T set c=c+1 where id=2;
```

1. 执行器先找引擎取 id=2 这一行。id 是主键，引擎直接用树搜索找到这一行

2. - 若这一行所在的数据页本来就**「在内存中」**，就**「直接返回」**给执行器
   - 若**「不在内存」**，需要先从磁盘**「读入内存」**，然后再**「返回」**

3. 执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口**「写入这行新数据」**

4. 引擎将这行新数据更新到内存中，同时将这个更新操作**「记录到 redo log 里面」**，此时 redo log 处于 **「prepare」** 状态。然后告知执行器执行完成了，随时可以提交事务

5. 执行器**「生成这个操作的 binlog」**，并把 binlog **「写入磁盘」**

6. 执行器调用引擎的**「提交事务」**接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，**「更新完成」**

## Innodb 事务为什么要两阶段提交?

- 先写 redolog 后写binlog。假设在 redolog 写完，binlog 还没有写完的时候，MySQL 进程异常重启，这时候 binlog 里面就没有记录这个语句。然后你会发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 **「binlog 丢失」**，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。
- 先写 binlog 后写 redolog。如果在 binlog 写完之后 crash，由于 redolog 还没写，崩溃恢复以后这个事务无效，所以这一行c的值是0。但是 binlog 里面已经记录了“把c从0改成1”这个日志。所以，在之后用 binlog 来恢复的时候就**「多了一个事务出来」**，恢复出来的这一行 c 的值就是 1，与原库的值不同。

可以看到，**「如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致」**。

# 日志

## bin log

归档日志，二进制文件，server层，用于记录用户对数据库操作的SQL信息(DML)

作用：主从复制、数据恢复

## undo log

是 InnoDB 存储引擎的日志，用于保证数据的原子性，**「保存了事务发生之前的数据的一个版本，即记录的是修改之前的数据，可用于回滚」**，同时可以提供多版本并发控制下的读（MVCC）。

作用：事务回滚、实现多版本控制(MVCC)



## redo log

是 InnoDB 存储引擎所特有的一种日志，用于**记录事务操作的变化**，记录的是数据修改之后的值，不管事务是否提交都会记录下来。

执行DML时，先记录到InnoDB 的redo log和缓存页中，再批量写入磁盘文件

作用：数据恢复、crash-safe

## relay log

中继日志，在主从复制中使用，是一个中介临时的日志文件，用于存储从master节点同步过来的binlog



## redolog 和 binlog 的区别

| redolog          | binlog                       |
| ---------------- | ---------------------------- |
| innodb独有       | server层，所有存储引擎都要用 |
| 记录具体修改数据 | 记录操作                     |
| 循环利用         | 满了生成新的                 |
| crash-safe       | 不能                         |



# 主从复制

指将 **主数据库（Master）**中的 DDL 和 DML 操作通过binlog传输到 **从数据库（Slave）** 上，然后将这些日志重新执行（redo），从而使得从数据库的数据与主数据库保持一致。

MySQL 支持单向、异步复制，复制过程中有一主一从、一主多从。

作用：

1. 备份

2. 读写分离，负载均衡

## 流程

两端三线程

- Master 端：binlog线程 —— 记录下所有改变了数据库数据的语句，放进 Master 的 binlog 中；
- Slave 端： I/O 线程 —— 负责从 Master上拉取 binlog 内容，放进自己的Relay log中；

- Slave 端：SQL 执行线程 —— 读取 Relay log，并顺序执行该日志中的 SQL 事件。


## 读写分离

主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。

优点：

- 主从服务器负责各自的读和写，极大程度缓解了锁的争用；
- 从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；
- 增加冗余，提高可用性。

读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。

实现方案：

1. 基于 MySQL proxy 代理

   在应用和数据库之间增加 代理层，代理层接收应用对数据库的请求，根据不同请求类型（即是读 read 还是写 write）转发到不同的实例，在实现读写分离的同时可以实现负载均衡。MySQL 的代理最常见的是 mysql-proxy、cobar、mycat、Atlas 等。

2. 基于应用内路由

   基于应用内路由的方式即为在应用程序中实现，针对不同的请求类型去不同的实例执行 SQL。

   具体实现可基于 spring 的 aop：用 aop 来拦截 spring 项目的 dao 层方法，根据方法名称就可以判断要执行的类型，进而动态切换主从数据源。

3. 基于 MySQL-Connector-Java 的 JDBC 驱动方式

   Java 程序通过在连接 MySQL 的 JDBC 中配置主库与从库等地址，JDBC 会自动将读请求发送给从库，将写请求发送给主库，此外， MySQL 的 JDBC 驱动还能够实现多个从库的负载均衡。

4. 基于 sharding-jdbc 的方式

   sharding-sphere 是强大的读写分离、分表分库中间件，sharding-jdbc 是 sharding-sphere 的核心模块。

