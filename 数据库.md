# 三大范式

第一范式（1NF）：每个列都不可以再拆分，强调的是列的原子性。第一范式要求数据库中的表都是二维表。
第二范式（2NF）：在第一范式的基础上，一个表必须有一个主键，非主键列 完全依赖 于主键，而不能是依赖于主键的一部分。
第三范式（3NF）：在第二范式的基础上，非主键列只依赖（直接依赖）于主键，不依赖于其他非主键。

# 触发器

触发器（trigger）是与表相关的数据库对象，是用户定义在关系表上的一类由**事件驱动**的特殊的存储过程，在满足定义条件时触发，并执行触发器中定义的 语句集合。触发器的这种特性可以协助应用在数据库端确保 数据库的完整性。

使用场景

- 可以通过数据库中的相关表实现 **级联更改**；

- 实时监控某张表中的某个字段的更改，并需要做出相应的处理。

# 事务

## ACID原则

A原子性：事务是最小的执行单位，不可分割。由undo log日志保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql

C一致性：数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。一般由代码层面来保证

I隔离性：一个事务所做的修改在提交前，对其它事务是不可见。由MVCC来保证

D持久性：一旦事务提交，则其所做的修改永远保存到数据库中。即使系统崩溃，事务执行的结果也不能丢失。由内存+redo log来保证，mysql修改数据同时在内存和redo log记录这次操作，事务提交的时候通过redo log刷盘，宕机的时候可以从redo log恢复

### 如何实现ACID特性

用日志来保证原子性、与一致性和持久性

用锁机制保证隔离性

### AUTOCOMMIT

MySQL 默认采用自动提交模式。也就是说，如果不显式使用`START TRANSACTION`语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。

## 事务并发问题

### 脏读（Dirty Read）

一个事务读取了另一个事务未提交的数据。

### 不可重复读（Non-repeatable Read）

就是在一个事务范围内，两次相同的查询会返回两个不同的数据，这是因为在此间隔内有其他事务对数据进行了修改。

### 幻读（Phantom Read）

本质也是不可重复读。

幻读是指当事务 不是独立执行时 发生的一种现象，例如有一个事务对表中的数据进行了修改，这种修改涉及到表中的全部数据行，同时，第一个事务也修改这个表中的数据，这种修改是向表中 插入一行新数据。那么，第一个事务的用户发现表中还有没有修改的数据行，就好像发生了幻觉一样。

### 丢失更新（Lost Update）

两个事务同时读取同一条记录，事务 A 先修改记录，事务 B 也修改记录（B 是不知道 A 修改过），当 B 提交数据后， 其修改结果覆盖了 A 的修改结果，导致事务 A 更新丢失。



## 隔离级别

表示并发事务对同一资源读取的隔离程度，由低到高依次是：

 

### 未提交读（READ UNCOMMITTED）

事务中的修改，即使没有提交，对其它事务也是可见的。



### 提交读（READ COMMITTED）

一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。Oracle 默认采用的是该隔离级别

 

### 可重复读（REPEATABLE READ）

保证在同一个事务中多次读取同一数据的结果是一样的。MySQL 默认采用可重复读隔离级别。

 

### 可串行化（SERIALIZABLE）

强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。

该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。

 

### 各种级别能否解决一致性问题


| 隔离级别 | 脏读 | 不可重复读 | 幻读 | 丢失更新 |
| -------- | ---- | ---------- | ---- | -------- |
| 未提交读 | 否   | 否         | 否   | 否       |
| 提交读   | 能   | 否         | 否   | 否       |
| 可重复读 | 能   | 能         | 否   | 能       |
| 可串行化 | 能   | 能         | 能   | 能       |



# 锁

## 锁粒度

MySQL 中只有两种：行级锁、表级锁

加锁需要资源，锁操作增加系统开销。应该尽量只锁定需要修改的那部分数据，锁定的数据量越少，系统的并发程度就越高。

选择封锁粒度时，需要在锁开销和并发程度之间做权衡



## 锁类型

### 读写锁

- 互斥锁（Exclusive），简写为 X 锁，又称写锁。
- 共享锁（Shared），简写为 S 锁，又称读锁。

限制：

1.  事务对数据A加了X锁，就能**读和写**A，加锁期间其他事务不能对A加**任何锁**
2.  事务对A加了S锁，**可以读但不能写**A，加锁期间其他事务还能对A加S锁，但不能加X锁

兼容关系：

|      |  X   |  S   |
| :--: | :--: | :--: |
|  X   | 不能 | 不能 |
|  S   | 不能 |  能  |



### 意向锁

更容易地支持多粒度封锁

IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁

兼容关系：

|      |  X   |  IX  |  S   |  IS  |
| :--: | :--: | :--: | :--: | :--: |
|  X   |  ×   |  ×   |  ×   |  ×   |
|  IX  |  ×   |      |  ×   |      |
|  S   |  ×   |  ×   |      |      |
|  IS  |  ×   |      |      |      |

- 任意 IS/IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁；
- X锁与所有锁不兼容
- 这里兼容关系针对的是**表级锁**，而表级的 IX 锁和行级的 X 锁兼容
