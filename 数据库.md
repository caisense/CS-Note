# 关系数据库理论

## 键

超键：能唯一标识元组的属性集，包含候选键和主键。可以是一个或多个属性

候选键：**最小**超键，即没有冗余元素的超键

主键：数据库表 中每行数据的**唯一标识**，每行有且只有唯一主键。可以是一个或多个属性，不能为空NULL

外键：一个表中存在的另一个表的主键，与其他表建立约束，可以为NULL

## 三大范式

第一范式（1NF）：属性不可分。
第二范式（2NF）：在第一范式的基础上，一个表必须有一个主键，非主键列 **完全依赖** 于主键，而不能是依赖于主键的一部分。
第三范式（3NF）：在第二范式的基础上，非主键列只依赖（直接依赖）于主键，不依赖于其他非主键。

# 触发器

触发器（trigger）是与表相关的数据库对象，是用户定义在关系表上的一类由**事件驱动**的特殊的存储过程，在满足定义条件时触发，并执行触发器中定义的 语句集合。触发器的这种特性可以协助应用在数据库端确保 数据库的完整性。

使用场景

- 可以通过数据库中的相关表实现 **级联更改**；

- 实时监控某张表中的某个字段的更改，并需要做出相应的处理。

# 事务

作为一个整体，要么都执行，要么都不

作用：保持数据一致性、可恢复性

## ACID原则

- A原子性：事务是最小的执行单位，不可分割。

- C一致性：数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。

- I隔离性：一个事务所做的修改在提交前，对其它事务是不可见。

  

- D持久性：一旦事务提交，则其所做的修改永远保存到数据库中。即使系统崩溃，事务执行的结果也不能丢失。

  

事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种**平级关系**：

- 只有满足一致性，事务的执行结果才是正确的。
- 在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。
- 在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。
- 事务满足持久化是为了能应对系统崩溃的情况。

### 如何实现ACID特性

- 原子性：由**undo log**日志保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql
- 一致性：一般由**代码层面**来保证
- 持久性：由**内存+redo log**来保证，mysql修改数据同时在内存和redo log记录这次操作，事务提交的时候通过redo log刷盘，宕机的时候可以从redo log恢复
- 隔离性：由**MVCC**来保证


### AUTOCOMMIT

MySQL 默认采用自动提交模式。也就是说，如果不显式使用`START TRANSACTION`语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。

## 事务并发问题

### 脏读（Dirty Read）

事务a读取了事务b**未提交**的数据。

### 不可重复读（Non-repeatable Read）

同一事务内，多次读同一数据结果不一样（因为在此过程中有其他事务对数据进行了修改）。例如事务T2读A，T1修改了A，T2再读A和上一次读到的不同

<img src="images/数据库/image-20191207222102010.png" alt="img" style="zoom:50%;" />

### 幻读（Phantom Read）

本质也是不可重复读。

幻读是指当事务 不是独立执行时 发生的一种现象，例如有事务a对表中的数据进行了修改，这种修改涉及到表中的全部数据行，同时，另一个事务b也向表中 插入一行。那么，事务a的用户会发现表中**还有一行**数据没有修改，就好像发生了幻觉一样。

### 丢失更新（Lost Update）

两个事务同时写同一条记录。事务 A 先写，事务 B 后写（B 不知道 A 写），当 B 提交数据后， 其写结果覆盖了 A 的写结果，导致事务 A 更新丢失。



## 隔离级别

表示并发事务对同一资源读取的隔离程度，由低到高依次是：

 

### 未提交读（READ UNCOMMITTED）

事务中的修改，即使没有提交，对其它事务也是可见的。



### 提交读（READ COMMITTED）

一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。Oracle 默认采用的是该隔离级别

 

### 可重复读（REPEATABLE READ）

保证在同一个事务中多次读取同一数据的结果是一样的。MySQL 默认采用可重复读隔离级别。

 

### 可串行化（SERIALIZABLE）

强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。

该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。

 

### 各种级别能否解决一致性问题


| 隔离级别 | 脏读 | 不可重复读 | 幻读 | 丢失更新 |
| -------- | ---- | ---------- | ---- | -------- |
| 未提交读 | 否   | 否         | 否   | 否       |
| 提交读   | 能   | 否         | 否   | 否       |
| 可重复读 | 能   | 能         | 否   | 能       |
| 可串行化 | 能   | 能         | 能   | 能       |



# 锁

## 锁粒度

MySQL 中只有两种：行级锁、表级锁

加锁需要资源，锁操作增加系统开销。应该尽量只锁定需要修改的那部分数据，锁定的数据量越少，系统的并发程度就越高。

选择封锁粒度时，需要在锁开销和并发程度之间做权衡



## 锁类型

### 读写锁

- 互斥锁（Exclusive），简写为 X 锁，又称写锁。
- 共享锁（Shared），简写为 S 锁，又称读锁。

限制：

1.  事务对数据A加了X锁，就能**读和写**A，加锁期间其他事务不能对A加**任何锁**
2.  事务对A加了S锁，**可以读但不能写**A，加锁期间其他事务还能对A加S锁，但不能加X锁

兼容关系：

|      |  X   |  S   |
| :--: | :--: | :--: |
|  X   | 不能 | 不能 |
|  S   | 不能 |  能  |



### 意向锁

更容易地支持多粒度封锁

IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁

兼容关系：

|      |  X   |  IX  |  S   |  IS  |
| :--: | :--: | :--: | :--: | :--: |
|  X   |  ×   |  ×   |  ×   |  ×   |
|  IX  |  ×   |      |  ×   |      |
|  S   |  ×   |  ×   |      |      |
|  IS  |  ×   |      |      |      |

- 任意 IS/IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁；
- X锁与所有锁不兼容
- 这里兼容关系针对的是**表级锁**，而表级的 IX 锁和行级的 X 锁兼容

### 悲观锁

使用DB锁机制，读/写完就锁，直到提交事务。长事务来说可能导致系统性能差

### 乐观锁

假设不会并发冲突，只在提交时检查。实现：版本号机制或CAS算法



# 多版本并发控制（MVCC）

是 MySQL 的 存储引擎 **InnoDB**实现隔离级别的一种**具体方式**，用于实现提交读和可重复读

## 基本思想

读写锁中读和写操作仍然是互斥的，而 MVCC 利用了多版本的思想，写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系

## 版本号

- 系统版本号 SYS_ID：是一个递增的数字，每开始一个新的事务，系统版本号就会**自动递增**。
- 事务版本号 TRX_ID ：事务开始时的系统版本号。

## Undo 日志

MVCC 的多版本指的是多个版本的**快照**，快照存储在 **Undo **日志中，该日志通过回滚指针** ROLL_PTR** 把一个数据行的所有快照连接起来。

```sql
// 例如在 MySQL 创建一个表 t，包含主键 id 和一个字段 x。我们先插入一个数据行，然后对该数据行执行两次更新操作。
INSERT INTO t(id, x) VALUES(1, "a");
UPDATE t SET x="b" WHERE id=1;
UPDATE t SET x="c" WHERE id=1;
```

根据 MySQL 的 AUTOCOMMIT 机制，每个操作都会被当成一个事务来执行，所以上面的操作总共涉及到三个事务。

![img](D:\CS-Note\images\数据库\image-20191208164808217.png)

快照中除了记录事务版本号 TRX_ID 和操作之外，还记录了一个 bit 的 DEL 字段，用于标记是否被删除。

INSERT、UPDATE、DELETE 操作会创建一个快照，并将事务版本号 TRX_ID 写入。

## ReadView

MVCC 维护了一个 ReadView 结构，主要包含了当前系统未提交的事务列表 TRX_IDs {TRX_ID_1, TRX_ID_2, ...}，还有该列表的最小值 TRX_ID_MIN 和 TRX_ID_MAX。

由递增性，可知TRX_ID_MIN表示**系统最早的未提交事务**，TRX_ID_MAX表示最晚的

![img](D:\CS-Note\images\数据库\image-20191208171445674.png)

在进行 SELECT 操作时，根据数据行快照的 TRX_ID 与 TRX_ID_MIN 和 TRX_ID_MAX 之间的关系，从而判断数据行快照是否可以使用：

- TRX_ID < TRX_ID_MIN，表示该数据行快照时在当前所有未提交事务之前进行更改的，因此可以使用。
- TRX_ID > TRX_ID_MAX，表示该数据行快照是在系统某些事务启动之后被更改的，因此不可使用。
- TRX_ID_MIN <= TRX_ID <= TRX_ID_MAX，需要根据隔离级别再进行判断：
  - 提交读：如果 TRX_ID 在 **TRX_IDs 列表** 中，表示该数据行快照对应的事务还未提交，则该快照不可使用。否则表示已经提交，可以使用。
  - 可重复读：都不可以使用。因为如果可以使用的话，那么其它事务也可以读到这个数据行快照并进行修改，那么当前事务再去读这个数据行得到的值就会发生改变，也就是出现了不可重复读问题。

在数据行快照不可使用的情况下，需要沿着 Undo Log 的回滚指针 ROLL_PTR 找到下一个快照（TRX_ID更小的），再进行上面的判断。

### 快照读与当前读

#### 1. 快照读

MVCC 的 SELECT 操作是快照中的数据，不需要进行加锁操作。

```sql
SELECT * FROM table ...;
```

#### 2. 当前读

MVCC 其它会对数据库进行修改的操作（INSERT、UPDATE、DELETE）需要进行加锁操作，从而读取最新的数据。可以看到 MVCC 并不是完全不用加锁，而只是避免了 SELECT 的加锁操作。

```sql
INSERT;
UPDATE;
DELETE;
```

在进行 SELECT 操作时，可以强制指定进行加锁操作。以下第一个语句需要加 S 锁，第二个需要加 X 锁。

```sql
SELECT * FROM table WHERE ? lock in share mode;
SELECT * FROM table WHERE ? for update;
```

## Next-Key Locks

Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。

MVCC 不能解决幻影读问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读级别下，使用**MVCC + Next-Key Locks**可以解决幻读问题。

### Record Locks

锁定某个（单行）。

如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。

### Gap Locks

锁定一个范围，但是不包含记录本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。

```sql
SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;
```

### Next-Key Locks

它是 Record Locks 和 Gap Locks 的结合，锁定一个范围，且锁定记录本身。它锁定一个**前开后闭**区间。

例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：

```sql
(-∞, 10]
(10, 11]
(11, 13]
(13, 20]
(20, +∞)
```

即在五个间隙上锁，只能操作这四个值
