# 基本架构

单体redis分为0~15号DB（配置文件设置），每个DB相当于命名空间，并不是传统意义上的DB。

DB内key不能重复，不同DB互不影响

redis集群模式只能使用一个数据库空间：db0

# 数据结构

Redis本质都是**k - v键值对**，用一个唯一的字符串key来标识存储，数据结构指value的存储结构。

- Key的大小上限为512MB，但建议不超过1KB，这样既节约存储空间，也利于检索。

基本数据结构共有5种：字符串string、列表list、字典hash、集合set、有序集合zset。

此外还有3种特殊类型：

- Geo：地理位置定位，用于存储地理位置信息，并对存储的信息进行操作（Redis 3.2 推出）。
- HyperLogLog：用来做基数统计算法的数据结构，如统计网站的 UV。
- Bitmaps：用一个比特位来映射某个元素的状态，在 Redis 中，它的底层是基于字符串类型实现的，可以把 bitmaps 成作一个以比特位为单位的数组。

<img src="images/Redis/image-20220419002910447.png" alt="image-20220419002910447" style="zoom:80%;" />

## String（字符串）

- 简介：最常用的数据结构，是一个k-v键值对，v是字符串。它是二进制安全的，最大存储为 512M

- 简单使用举例：set key value、get key 等

- 应用场景：共享session、分布式锁，计数器、限流、存储图片或序列化的对象

- 内部编码有 3 种：
  1. int（8 字节，java的Long）
  
  2. embstr（小于等于 39 字节字符串）
  
  3. raw（大于 39 个字节字符串）
  
     

## Hash（哈希）

- 简介：存储二级map，无序，第一级是 k - v 键值对，其中 v 本身又是一个 k-v 键值对

- 简单使用举例：

  1. **hset** key field value：设置map（key对应的map，下文不再强调）中的k-v为 field value 

  2. **hget** key field：获取map中的k = field的v

  3. **hgetall** key：获取map中所有k-v

  4. **hlen** key：得到map的k-v对总数

  5. **hdel** key ：删除map

  6. **hincrby** key filed inc：map中k=field的值加上inc

- 内部编码：ziplist（压缩列表） 、hashtable（哈希表）

- 应用场景：存对象（k为对象唯一id，v为map，恰好存放对象的所有属性）



## List（列表）

- 简介：k-v 键值对，v是列表（list）类型，从左向右存储多个有序的字符串，一个列表最多可存储 **2^32-1** 个元素

- 简单使用举例：

  1. **lpush** key value [value ...]：列表（key对应的列表，下文不再强调）头插一个（或多个）

  2. **rpush** key value [value ...]：列表尾插一个（或多个）

  3. **lpop** key：从列表头部弹出

  4. **rpop** key：从列表尾部弹出

  4. **blpop** key [key ...] timeout：从列表头部弹出一个（或多个）元素，若**列表空**则阻塞等待timeout秒，若=0则一直阻塞

  4. **brpop** key [key ...] timeout：从列表尾部弹出一个（或多个）元素，若**列表空**则阻塞等待timeout秒，若=0则一直阻塞

  7. **lindex** key idx：通过索引取值：

     - 若下标（idx）为非负数，返回`list[idx]`元素，idx=0为最左元素。

     - 若下标为负，从右向左，idx=-1为最右元素。

     - 若下标超过数组长度，返回nil

     <img src="images/Redis/image-20220419093351771.png" alt="image-20220419093351771" style="zoom: 67%;" />

  6. **lset** key idx val：通过索引设值：`list[idx] = val`

  7. **lrange** key start end：获取`[start, stop]`区间元素，与java数组不同，右边是闭区间（stop号元素也能取到）。

     

- 内部编码：ziplist（压缩列表）、linkedlist（链表）

- 应用场景：栈（lpush+lpop）、消息队列（lpush+rpop）、阻塞队列（lpush+brpop）

  公众号文章列表（或微博信息流）：分库分表分布式的db，order by 本来就很耗时，再聚合排序更耗时。
  
  利用redis全局一致的特性，对每个用户id，博主发布一条就 lpush msg:{用户id} 消息id，则顺序读list就是最新的消息。查看最新的5条消息列表用 lrange msg:{用户id} 0 5  
  
  异步队列：将需要延后处理的任务结构体序列化为字符串，放入Redis列表，再用一个线程从列表中轮询处理。



## Set（集合）

- 简介：k-v 键值对，其中v是字符串集合（元素不重复），无序

- 简单使用举例：

  1. **sadd** key member1 [member2 ...]：（key对应的，下文不再强调）集合添加一个（或多个）成员
  2. **srem** key member1 [member2 ...]：集合删除一个或多个成员
3. **sismember** key member：判断member是否在集合中，若在返回1；若不在或key不存在，返回0
  4. **smembers** key：返回集合所有成员
5. **scard** key：返回集合成员数量
  6. **srandmember** key [count]：返回随机count个成员，不加count则默认一个
7. **spop** key [count]：弹出随机count个成员，不加count则默认一个
  8. **sdiff** key1 key2：求两个集合的差集
9. **SINTER** key1 [key2 … ]：求两个及以上集合的交集
  9. **SUNION** key1 [key2]：求几个集合并集

- 内部编码：intset（整数集合）、hashtable（哈希表）

- 应用场景：用户标签、社交需求

  1. 生成随机数抽奖

     添加抽奖人：sadd key {userID}；查看所有参与抽奖用户：smembers key；

     抽取n名中奖者：srandmember key n 或者spop key n

  2. 朋友圈点赞

     点赞，把对某条朋友圈点赞的用户id存在一个集合里：sadd like:{消息id} {用户id}；

     取消点赞：srem  like:{消息id} {用户id};

     检查用户是否点过赞：sismember  like:{消息id} {用户id}；

     获取点赞的用户列表：smembers  like:{消息id}；获取点赞用户数：scard  like:{消息id}；

  3. 微博关注模型

     a关注的人：aSet -> {w, x, y, z}

     b关注的人：bSet -> {u, v, w, x}

     求a和b的共同关注，用交集：sinter aSet bSet; 返回{w, x}

     a和b是好友，则a可能认识的人，用差集：sdiff bSet aSet；返回{u, v}

     判断a关注的人也关注x，看x是否在集合a：sismember aSet x

     



## zset（有序集合）

- 简介：k-v 键值对，v是**已排序**的字符串集合，排序依据是元素的score

  **注意**：

  - score相同时，redis对元素使用**字典排序**

  - score 值可以是整数值或**双精度浮点数**。

- 简单格式举例：
  1. **zadd** key score member [[score2 member2] ...]：有序集合中加入一个（或多个）带分值元素
  
  2. **zrem** key member [member ...]：从有序集合中删除元素
  
  3. **zscore** key member：返回member的分值
  
  3. **zincrby** key increment member：将member的分值加上increment，increment可以为负数；当key不存在 ，或member不再集合中，该命令等同于**zadd** key increment member
  
  4. **zrank** key member：返回member在集合中的排名
  
  5. **zrange** key start stop [withscores]：顺序返回排名在`[start, stop]`区间的元素；带withscores则带上分值，以value1,score1, ..., valueN,scoreN格式返回
  
     下标为负数则从最后排名开始，-1为倒数第一，以此类推
  
  5. **zrevrange** key start stop [withscores]：倒序
  
  2. **zrangebyscore** key min max [WITHSCORES] [LIMIT offset count] ：返回score介于`[min, max]`区间的元素，顺序根据分值排名（从小到大）。可选的 LIMIT 参数指定返回结果的数量及区间（就像 SQL 中的 SELECT LIMIT offset,  count )
  
- 底层内部编码：

  1. ziplist（压缩列表）

     类似数组，但本质上是链表，根据socre排序

     <img src="images/Redis/image-20220419160219909.png" alt="image-20220419160219909" style="zoom:50%;" />

  2. skiplist（跳跃表）

     将有序链表改造为多层索引，元素较多时，查找效率接近二分（OlogN）

     ![image-20220419112349770](images/Redis/image-20220419112349770.png)

- 应用场景：用户点赞排序。

  1. 热门排行榜

     点击新闻：zincrby hotNews:20220419 1 总理记者会

     展示当日排行前十：zrevrange hotNews:20220419 0 9 withscores







# Rehash？

- Redis采用渐进式rehash，同时保留新旧两个hash结构，在后续的定时任务和hash操作中，逐渐将旧hash的内容转移到新hash中。

# Redis为何高效？

官方数据是10万+的QPS（每秒内查询次数）

1. 单线程

   单线程避免了多线程的竞争，省去了多线程切换带来的时间和性能开销，并且不会出现死锁。

   > 多线程的本质就是 CPU 模拟出来多个线程的情况，这种模拟出来的情况代价就是上下文的切换，对于一个内存的系统来说，没有上下文的切换就是效率最高的。

   - 4.0之前是单线程，具体而言 **网络I/O 、Get/Set** 操作是单线程。持久化、集群同步还是用其他线程完成

   - 4.0之后添加多线程，将耗时的命令异步化，避免阻塞单线程的事件循环。具体是大数据的异步删除功能，例如 `unlink key`、`flushdb async`、`flushall async` 等

   - 6.0开始用多线程处理网络IO

2. 基于内存存储实现，省去磁盘IO开销

3. 文件事件Proc使用**IO多路复用程序**监听多个socket，基于非阻塞IO模型，实现高性能网络通信模型。

   对于一个 DB 来说，CPU 通常不会是瓶颈，因为大多数请求不会是 CPU 密集型的，而是 I/O 密集型。Redis真正的性能瓶颈在于网络 I/O，也就是客户端和服务端之间的网络传输延迟



# 如何实现数据不丢失？

把数据从内存存储到磁盘上（持久化），三种方式

1. AOF 日志（Append Only File，文件追加方式）：记录所有的操作命令，并以文本的形式追加到文件中。
2. RDB 快照（Redis DataBase）：将某一个时刻的内存数据，以二进制的方式写入磁盘。
3. 混合持久化方式：Redis 4.0 新增了混合持久化的方式，集成了 RDB 和 AOF 的优点。

# 持久化

Redis 是基于内存，为避免数据丢失，需要持久化到磁盘，有两种方式

## 1. RDB

是 **Redis 默认 **的持久化方式。把内存数据以**快照**的形式保存到磁盘上。在指定的时间间隔内，执行指定次数的写操作，将内存中的数据集快照写入磁盘中

执行完操作后，在指定目录下会生成一个 dump.rdb 文件，Redis 重启的时候，通过加载 dump.rdb 文件来恢复数据。

优点：适合大规模的数据恢复场景，如备份，全量复制等。缺点：没办法做到实时持久化/秒级持久化；新老版本存在 RDB 格式兼容问题

### 写后日志的风险？

- 数据可能会丢失：如果 Redis 刚执行完命令，此时发生故障宕机，会导致这条命令存在丢失的风险。
- 可能阻塞其他操作：AOF 日志其实也是在**主线程**中执行，所以当 Redis 把日志文件写入磁盘的时候，还是会阻塞后续的操作无法执行。

### RDB做快照时会阻塞线程吗？

Redis 提供了两个命令，用于手动生成 RDB 快照文件，分别是 `save` 和 `bgsave`。

- `save` 命令：同步，在主线程中执行，会导致**阻塞**（因此快照时不能写）。
- `bgsave` 命令：异步，fork操作创建一个子进程，用于写入 RDB 文件的操作，避免了对主线程的阻塞（当主线程读，则主线程和 `bgsave` 子进程互相不影响；当主线程写，被修改的数据会复制一份副本，然后 `bgsave`子进程会把副本数据写入 RDB 文件）

此外还有自动触发命令 `sava m n`，表示m秒内数据集存在n次修改时，自动触发`bgsave`。

## 2. AOF

AOF（append only file） 持久化，采用日志记录每个操作命令，追加到文件中，重启时再重新执行 AOF 文件中的命令来恢复数据。它主要解决数据持久化的实时性问题。默认不开启。

文件会越来越大，为避免出现此种情况，新增了重写机制，当AOF文件的大小超过所设定的阈值时， Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集。

优点：数据的一致性和完整性更高。缺点：AOF 记录的内容越多，文件越大，数据恢复变慢。

## 3. 混合

Redis 4.0 后，增加了 AOF 和 RDB 混合的机制： 把数据以 RDB 的方式写入文件，再将后续的操作命令以 AOF 的格式存入文件，既保证了 Redis 重启速度，又降低数据丢失风险。

缺点是兼容性差，一旦开启了混合持久化，在4.0之前版本都不识别该混合文件，同时由于前部分是RDB格式，阅读性较差。

## 比较

|          | RDB      | AOF    |
| -------- | -------- | ------ |
| 使用时机 | 重启时   | 重启时 |
| 记录时机 | 指定间隔 | 实时   |
|          |          |        |



# 主从复制

是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master/leader)，后者称为从节点(slave/follower)； 

数据的复制是**单向**的，只能由主节点到从节点。 

Master可写可读，Slave 只能读。 

## 优点

1. 数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。 

2. 故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务 

   的冗余。 

3. 负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务 

   （即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写 

   少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。 

4. 高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是 

   Redis高可用的基础。 

## 典型架构 

1. 一主多从，一对多。 

<img src="images\Redis\GetImage.png" alt="GetImage" style="zoom:50%;" />

2. 特殊的**链式**架构，中间的结点整体作为从机，但同时也是最右边从机的主机。 

<img src="images\Redis\GetImage-16442891132211.png" alt="GetImage" style="zoom:50%;" />

## 复制原理 

Slave 启动成功连接到 master 后会发送一个sync命令 

Master 接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave，并完成一次完全同步。 

全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。 

增量复制：Master 继续将新的所有收集到的修改命令依次传给slave，完成同步。 

但是只要是重新连接master，一次完全同步（全量复制）将被自动执行 

## 哨兵模式 

主从切换的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，需要人工干预，不推荐。Redis2.8开始正式提供了Sentinel（哨兵） 架构来解决这个问题。 

哨兵是一个**独立的进程**。通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。 

哨兵有两个作用： 

- 通过发送命令，让Redis服务器返回其运行状态，包括主服务器和从服务器。 

- 当哨兵监测到master宕机，会根据**投票算法**，自动决定将哪个slave切换成master，然后通过**发布订阅模式**通知其他的从服务器，修改配置文件，让它们切换主机。之前的master恢复后，也只能做slave。 


## 实战

**主要配置** 

编辑sentinel.conf 文件 

```
# 哨兵sentinel监控的redis主节点的 ip port
# master-name 可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符".-_"组成。
# quorum 配置多少个sentinel哨兵统一认为master主节点失联 那么这时客观上认为主节点失联了
# sentinel monitor <master-name> <ip> <redis-port> <quorum>
sentinel monitor mymaster 127.0.0.1 6379 2
```

 

**启动** 

linux下，使用命令（sentinel.conf是配置文件名，可自定义）： 

```
$ redis-sentinel sentinel.conf 
```

# Redis集群

Redis Cluster 是一种分布式去中心化的运行模式，是Redis 3.0 版本中推出，集群由多个redis节点组成，它将数据分布在不同的服务器上，以此来降低系统对单主节点的依赖，从而提高 Redis 服务的读写性能。

Redis集群系统满足**CAP理论中的CP**，cp系统还有zookeeper

## 如何确定节点

使用**类一致性哈希算法**。Redis Cluster将自己分成了**16384**个Slot（槽位），哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中。集群模式不再分多db，只使用一个db0

计算方式：

1. 根据键值对的 key，按照 CRC16 算法计算一个 16 bit 的值。
2. 再用 16bit 值对 16384 取模，结果就是该key对应的哈希槽。

每个Redis节点负责处理一部分槽位，加入你有三个master节点 ABC，每个节点负责的槽位如下：节点A：0-5000，节点B：5001-10000，节点C：10001-16383

# 淘汰策略

由前面我们知道redis放内存，然而内存是有限的，**内存满**时就会执行淘汰（回收）

1. no-eviction：不删除
2. allkeys-lru
3. volatile-lru
4. allkeys-random
5. volatile-random

6. volatile-ttl：从已设置过期时间的哈希表中随机挑选多个 Key，然后选择**剩余时间最短**的数据淘汰掉

**Redis 4.0后增加以下两种**：

7. volatile-lfu：从已设置过期时间的数据集中挑选最不经常使用的数据淘汰算法，也就是最频繁被访问的数据将来最有可能被访问到)

8. allkeys-lfu：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的key。

说明：

- allkeys前缀：从所有 Key 的数据集（`server.db[i].dict`）中挑选

- volatile前缀：从已设置过期时间的数据集（`server.db[i].expires`）中挑选

- 带-lru后缀的：先随机挑，再从挑出的用lru算法（Least Recently Used）淘汰最近最少使用

- 带-random后缀的：直接随机
- 带-lfu后缀的：先随机挑，再从挑出的用lfu算法(Least Frequently Used)淘汰最不经常使用

# Q：如何实现定时机制？

Redis server是**事件驱动**的程序，要处理两种事件：

- 文件事件：server对**socket**的抽象

- 时间事件：server对**定时操作**的抽象


定时机制通过**时间事件**实现，由三个属性组成：

1. id：时间事件标识
2. when：记录时间事件的到达时刻
3. timeProc：时间事件处理器

# 过期删除策略

redis数据可以设定过期时间，到期后执行删除。Redis的过期删除策略是：**惰性删除** 和 **定期删除**，两种策略配合使用。

1. （**被动**触发）惰性删除：由`db.c/expireIfNeeded`函数实现，所有键读写命令执行之前都会调用 `expireIfNeeded`函数对其进行检查，如果过期，则删除该键，然后执行键不存在的操作；未过期则不作操作，继续执行原有的命令。

   优点：节省计算资源

   缺点：占用内存大，若某个key已过期却一直未读写，则一直存在

2. （**主动**触发）定期删除：由`Redis.c/activeExpireCycle` 函数实现，函数以一定的频率运行，每次运行时，都从一定数量的数据库中取出一定数量的**随机键**进行检查，并删除其中的过期键。

   优点：有效释放过期key占用内存

   缺点：计算开销大，而且触发的时机难以确定（每个key的过期时间不一样，如何定批处理时机？）

3. （**主动**触发）定时删除：对每个设置过期时间的key，都创建一个定时器

   缺点：计算开销很大

# Q：如何实现分布式锁

- 加锁：用一个唯一标识做key，uuid做value（区分加锁者，解锁要用）

  1）先用setnx命令设置k-v

  2）再设置锁过期时间：EXPIRE key timeout，避免资源被永远锁住。

  两条都成功则说明加锁成功。失败则说明key被其他客户端占用，轮询等待。

  然而这两条命令不是原子的，高并发环境会出问题。用lua脚本执行两条命令，保证原子性

  **注意**

  redis2.6.12版本增加新命令，一条就可以完成

  ```
  SET product:10001 true EX 10 NX  // 当且仅当product:10001不存在时，设product:10001值为true，10秒过期
  ```

  

- 解锁：传入k、v，用k查询redis得到v1，判断v1==v？如果相等，说明是同一个客户端上的锁，可以解锁；若不相等不能解锁。解锁操作就是del key。

  del key之前需要看key是否存在，然后再用del命令删，redis没有执行这两个功能的命令，必须用lua脚本保证原子性：

  ```lua
  if redis.call('get', KEYS[1]) == ARGV[1]
      then
          return redis.call('del', KEYS[1])
      else
          return 0
  end
  ```

  

- 锁续期：开一个定时任务，在分线程里检查主线程的锁（key）是否还存在，存在则续期。

# 缓存穿透问题

用户频繁的模拟请求缓存中不存在的数据（未命中redis），以致这些请求短时间内直接落在了数据库上，导致数据库性能急剧下降，最终影响服务整体的性能。这个在实际项目很容易遇到，如抢购活动、秒杀活动的接口 API 被大量的恶意用户刷，导致短时间内数据库宕机。

**解决方案**

1. 命中db不存在数据，也写redis，给一个自定义的空值（如“{}”），下次读到这个空值就知道数据不存在，顶多查redis，不会查db。
1. 使用分布式互斥锁排队。当从缓存中获取数据失败时，给当前接口加上锁，从数据库中加载完数据并写入后再释放锁。若其它线程获取锁失败，则等待一段时间后重试。该方式将高并发压力从db转移到分布式锁，对分布式锁考验很大。
2. 使用布隆过滤器。将所有可能存在的数据缓存放到布隆过滤器中，当黑客访问不存在的缓存时迅速返回避免缓存及 DB 挂掉。

>布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力；
>
>![未命名图片]( images/Redis/未命名图片.png)

3. 缓存空对象。

   当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源；


# 缓存雪崩问题

在短时间内有大量缓存失效。

如果这期间有大量的请求发生，大量查询直接请求db也有可能导致db宕机。在 Redis 集群的数据分布算法上如果使用的是传统的 hash 取模，在增加或移除 Redis 节点的时候就会出现大量的缓存失效的情形。

**解决方案**

1. 像解决缓存穿透一样加锁排队。

2. 加机器。建立备份缓A和B，A 设置超时时间，B 不设值超时时间，先从 A 读缓存，A 没有读 B，并且更新 A 缓存和 B 缓存。

3. 计算数据缓存节点的时候采用**一致性hash** 算法，这样在节点数量发生改变时不会存在大量的缓存数据需要迁移的情况发生。

4. 数据预热（本质是使过期时间分散）

   在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间。
   
   或者给   缓存失效的时间取随机值。

# Q：如何保证双写一致性？

双写一致性：缓存和数据库一致

1. 常用方案：查询时先查缓存，没有才查库，并用库数据更新缓存

   问题：查库与更新缓存不是原子操作，若查库后库又更新了，则写入的缓存不是最新的

2. 



# Q：如何实现数据冷热分离？

例：对于用户信息user，写库时写一份redis，过期时间一天。查询时对每个key，先查redis，有则返回，并给key延期； 没有再查库，并写redis



# Redis与Memcached比较

|            | Redis                | Memcached        |
| ---------- | -------------------- | ---------------- |
| 数据类型   | 多种                 | 只有字符串       |
| 持久化     | 有                   | 无               |
| 网络IO模型 | 单线程的多路 IO 复用 | 多线程的非阻塞IO |

# JCS

本地缓存

主要实现类：package org.apache.jcs下，JCS类

配置文件：cache.ccf

主要api：

```java
JCS cache = JCS.getInstance(); //获取缓存实例
cache.get(key);  // 用key查询元素
cache.put(key, ele);  // 放入元素
```

**优点**

1. 缓存和应用在同一个进程（本地）内，请求缓存非常快，**没有网络开销**。
2. 轻量级，几乎不依赖其他库。

**缺点**

1. 不适用于存在分布式事务的系统。 
2. 缓存跟应用程序耦合性较高。 
3. 分布式的支持较简单，不适合特别大型的分布式项目。
