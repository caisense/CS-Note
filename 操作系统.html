<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>计算机面试指北</title>
    <meta name="generator" content="VuePress 1.9.10">
    
    <meta name="description" content="计算机面试指北">
    
    <link rel="preload" href="/CS-Note/assets/css/0.styles.37b6130a.css" as="style"><link rel="preload" href="/CS-Note/assets/js/app.499d959b.js" as="script"><link rel="preload" href="/CS-Note/assets/js/2.3a0ab2ea.js" as="script"><link rel="preload" href="/CS-Note/assets/js/1.2a19e319.js" as="script"><link rel="preload" href="/CS-Note/assets/js/43.9cf3acc6.js" as="script"><link rel="prefetch" href="/CS-Note/assets/js/10.d51ac22e.js"><link rel="prefetch" href="/CS-Note/assets/js/11.b53fe42a.js"><link rel="prefetch" href="/CS-Note/assets/js/12.7aa00c78.js"><link rel="prefetch" href="/CS-Note/assets/js/13.67223a8e.js"><link rel="prefetch" href="/CS-Note/assets/js/14.207a62d8.js"><link rel="prefetch" href="/CS-Note/assets/js/15.13447313.js"><link rel="prefetch" href="/CS-Note/assets/js/16.5f3d6fd5.js"><link rel="prefetch" href="/CS-Note/assets/js/17.56e70d25.js"><link rel="prefetch" href="/CS-Note/assets/js/18.f14668a4.js"><link rel="prefetch" href="/CS-Note/assets/js/19.fd36e329.js"><link rel="prefetch" href="/CS-Note/assets/js/20.ac1cf63f.js"><link rel="prefetch" href="/CS-Note/assets/js/21.c82e808b.js"><link rel="prefetch" href="/CS-Note/assets/js/22.8a129fa2.js"><link rel="prefetch" href="/CS-Note/assets/js/23.4bc57570.js"><link rel="prefetch" href="/CS-Note/assets/js/24.73b21b26.js"><link rel="prefetch" href="/CS-Note/assets/js/25.b8611692.js"><link rel="prefetch" href="/CS-Note/assets/js/26.a296c369.js"><link rel="prefetch" href="/CS-Note/assets/js/27.42b29ccc.js"><link rel="prefetch" href="/CS-Note/assets/js/28.f5d9ff11.js"><link rel="prefetch" href="/CS-Note/assets/js/29.734fa758.js"><link rel="prefetch" href="/CS-Note/assets/js/3.9d4db8bf.js"><link rel="prefetch" href="/CS-Note/assets/js/30.17548d71.js"><link rel="prefetch" href="/CS-Note/assets/js/31.3dc09066.js"><link rel="prefetch" href="/CS-Note/assets/js/32.0fe7da6f.js"><link rel="prefetch" href="/CS-Note/assets/js/33.a522da37.js"><link rel="prefetch" href="/CS-Note/assets/js/34.09c983b1.js"><link rel="prefetch" href="/CS-Note/assets/js/35.e76434f5.js"><link rel="prefetch" href="/CS-Note/assets/js/36.39026a8c.js"><link rel="prefetch" href="/CS-Note/assets/js/37.e0c6270e.js"><link rel="prefetch" href="/CS-Note/assets/js/38.a3b88467.js"><link rel="prefetch" href="/CS-Note/assets/js/39.cbbe4c99.js"><link rel="prefetch" href="/CS-Note/assets/js/4.eed64932.js"><link rel="prefetch" href="/CS-Note/assets/js/40.32d35e6a.js"><link rel="prefetch" href="/CS-Note/assets/js/41.96ec4146.js"><link rel="prefetch" href="/CS-Note/assets/js/42.1c7206ce.js"><link rel="prefetch" href="/CS-Note/assets/js/44.de1adacc.js"><link rel="prefetch" href="/CS-Note/assets/js/45.0d47c93a.js"><link rel="prefetch" href="/CS-Note/assets/js/46.6109a5cc.js"><link rel="prefetch" href="/CS-Note/assets/js/47.e3ee1a02.js"><link rel="prefetch" href="/CS-Note/assets/js/48.7c856d25.js"><link rel="prefetch" href="/CS-Note/assets/js/49.08d863fe.js"><link rel="prefetch" href="/CS-Note/assets/js/5.8ea92bac.js"><link rel="prefetch" href="/CS-Note/assets/js/50.b38b6f84.js"><link rel="prefetch" href="/CS-Note/assets/js/51.eb35dbda.js"><link rel="prefetch" href="/CS-Note/assets/js/6.7df2cbe2.js"><link rel="prefetch" href="/CS-Note/assets/js/7.e0fadba1.js"><link rel="prefetch" href="/CS-Note/assets/js/vendors~docsearch.2493936b.js">
    <link rel="stylesheet" href="/CS-Note/assets/css/0.styles.37b6130a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/CS-Note/" class="home-link router-link-active"><img src="images/hero.png" alt="计算机面试指北" class="logo"> <span class="site-name can-hide">计算机面试指北</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/CS-Note/" class="nav-link">
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java" class="dropdown-title"><span class="title">Java</span> <span class="arrow down"></span></button> <button type="button" aria-label="Java" class="mobile-dropdown-title"><span class="title">Java</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/CS-Note/Java基础.html" class="nav-link">
  Java基础
</a></li><li class="dropdown-item"><!----> <a href="/CS-Note/Java并发.html" class="nav-link">
  Java并发
</a></li><li class="dropdown-item"><!----> <a href="/CS-Note/Java高级.html" class="nav-link">
  Java高级
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Spring" class="dropdown-title"><span class="title">Spring</span> <span class="arrow down"></span></button> <button type="button" aria-label="Spring" class="mobile-dropdown-title"><span class="title">Spring</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/CS-Note/Spring常见问题.html" class="nav-link">
  Spring常见问题
</a></li><li class="dropdown-item"><!----> <a href="/CS-Note/Spring常用注解.html" class="nav-link">
  Spring常用注解
</a></li><li class="dropdown-item"><!----> <a href="/CS-Note/Spring源码.html" class="nav-link">
  Spring源码
</a></li><li class="dropdown-item"><!----> <a href="/CS-Note/Spring事务.html" class="nav-link">
  Spring事务
</a></li><li class="dropdown-item"><!----> <a href="/CS-Note/SpringCloud-Netflix实战.html" class="nav-link">
  SpringCloud-Netflix实战
</a></li><li class="dropdown-item"><!----> <a href="/CS-Note/SpringCloud-Netflix源码.html" class="nav-link">
  SpringCloud-Netflix源码
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据库" class="dropdown-title"><span class="title">数据库</span> <span class="arrow down"></span></button> <button type="button" aria-label="数据库" class="mobile-dropdown-title"><span class="title">数据库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/CS-Note/MySQL.html" class="nav-link">
  MySQL
</a></li><li class="dropdown-item"><!----> <a href="/CS-Note/数据库.html" class="nav-link">
  数据库
</a></li><li class="dropdown-item"><!----> <a href="/CS-Note/存储.html" class="nav-link">
  存储
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="计算机基础" class="dropdown-title"><span class="title">计算机基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="计算机基础" class="mobile-dropdown-title"><span class="title">计算机基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/CS-Note/计算机网络.html" class="nav-link">
  计算机网络
</a></li><li class="dropdown-item"><!----> <a href="/CS-Note/操作系统.html" class="nav-link">
  操作系统
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="分布式" class="dropdown-title"><span class="title">分布式</span> <span class="arrow down"></span></button> <button type="button" aria-label="分布式" class="mobile-dropdown-title"><span class="title">分布式</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/CS-Note/分布式.html" class="nav-link">
  分布式
</a></li><li class="dropdown-item"><!----> <a href="/CS-Note/Redis.html" class="nav-link">
  Redis
</a></li><li class="dropdown-item"><!----> <a href="/CS-Note/消息队列.html" class="nav-link">
  消息队列
</a></li><li class="dropdown-item"><!----> <a href="/CS-Note/注册中心.html" class="nav-link">
  注册中心
</a></li><li class="dropdown-item"><!----> <a href="/CS-Note/容器.html" class="nav-link">
  容器
</a></li><li class="dropdown-item"><!----> <a href="/CS-Note/RPC.html" class="nav-link">
  RPC
</a></li></ul></div></div><div class="nav-item"><a href="/CS-Note/算法.html" class="nav-link">
  算法
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="其他" class="dropdown-title"><span class="title">其他</span> <span class="arrow down"></span></button> <button type="button" aria-label="其他" class="mobile-dropdown-title"><span class="title">其他</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/CS-Note/设计模式.html" class="nav-link">
  设计模式
</a></li><li class="dropdown-item"><!----> <a href="/CS-Note/系统设计.html" class="nav-link">
  系统设计
</a></li><li class="dropdown-item"><!----> <a href="/CS-Note/Linux.html" class="nav-link">
  Linux
</a></li><li class="dropdown-item"><!----> <a href="/CS-Note/Git.html" class="nav-link">
  Git
</a></li><li class="dropdown-item"><!----> <a href="/CS-Note/信息doc安全.html" class="nav-link">
  信息安全
</a></li><li class="dropdown-item"><!----> <a href="/CS-Note/编码.html" class="nav-link">
  编码
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="项目" class="dropdown-title"><span class="title">项目</span> <span class="arrow down"></span></button> <button type="button" aria-label="项目" class="mobile-dropdown-title"><span class="title">项目</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/CS-Note/高性能数字货币交易系统.html" class="nav-link">
  高性能数字货币交易系统
</a></li><li class="dropdown-item"><!----> <a href="/CS-Note/手写Spring.html" class="nav-link">
  手写Spring
</a></li></ul></div></div> <a href="https://github.com/caisense/CS-Note" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/CS-Note/" class="nav-link">
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java" class="dropdown-title"><span class="title">Java</span> <span class="arrow down"></span></button> <button type="button" aria-label="Java" class="mobile-dropdown-title"><span class="title">Java</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/CS-Note/Java基础.html" class="nav-link">
  Java基础
</a></li><li class="dropdown-item"><!----> <a href="/CS-Note/Java并发.html" class="nav-link">
  Java并发
</a></li><li class="dropdown-item"><!----> <a href="/CS-Note/Java高级.html" class="nav-link">
  Java高级
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Spring" class="dropdown-title"><span class="title">Spring</span> <span class="arrow down"></span></button> <button type="button" aria-label="Spring" class="mobile-dropdown-title"><span class="title">Spring</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/CS-Note/Spring常见问题.html" class="nav-link">
  Spring常见问题
</a></li><li class="dropdown-item"><!----> <a href="/CS-Note/Spring常用注解.html" class="nav-link">
  Spring常用注解
</a></li><li class="dropdown-item"><!----> <a href="/CS-Note/Spring源码.html" class="nav-link">
  Spring源码
</a></li><li class="dropdown-item"><!----> <a href="/CS-Note/Spring事务.html" class="nav-link">
  Spring事务
</a></li><li class="dropdown-item"><!----> <a href="/CS-Note/SpringCloud-Netflix实战.html" class="nav-link">
  SpringCloud-Netflix实战
</a></li><li class="dropdown-item"><!----> <a href="/CS-Note/SpringCloud-Netflix源码.html" class="nav-link">
  SpringCloud-Netflix源码
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据库" class="dropdown-title"><span class="title">数据库</span> <span class="arrow down"></span></button> <button type="button" aria-label="数据库" class="mobile-dropdown-title"><span class="title">数据库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/CS-Note/MySQL.html" class="nav-link">
  MySQL
</a></li><li class="dropdown-item"><!----> <a href="/CS-Note/数据库.html" class="nav-link">
  数据库
</a></li><li class="dropdown-item"><!----> <a href="/CS-Note/存储.html" class="nav-link">
  存储
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="计算机基础" class="dropdown-title"><span class="title">计算机基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="计算机基础" class="mobile-dropdown-title"><span class="title">计算机基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/CS-Note/计算机网络.html" class="nav-link">
  计算机网络
</a></li><li class="dropdown-item"><!----> <a href="/CS-Note/操作系统.html" class="nav-link">
  操作系统
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="分布式" class="dropdown-title"><span class="title">分布式</span> <span class="arrow down"></span></button> <button type="button" aria-label="分布式" class="mobile-dropdown-title"><span class="title">分布式</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/CS-Note/分布式.html" class="nav-link">
  分布式
</a></li><li class="dropdown-item"><!----> <a href="/CS-Note/Redis.html" class="nav-link">
  Redis
</a></li><li class="dropdown-item"><!----> <a href="/CS-Note/消息队列.html" class="nav-link">
  消息队列
</a></li><li class="dropdown-item"><!----> <a href="/CS-Note/注册中心.html" class="nav-link">
  注册中心
</a></li><li class="dropdown-item"><!----> <a href="/CS-Note/容器.html" class="nav-link">
  容器
</a></li><li class="dropdown-item"><!----> <a href="/CS-Note/RPC.html" class="nav-link">
  RPC
</a></li></ul></div></div><div class="nav-item"><a href="/CS-Note/算法.html" class="nav-link">
  算法
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="其他" class="dropdown-title"><span class="title">其他</span> <span class="arrow down"></span></button> <button type="button" aria-label="其他" class="mobile-dropdown-title"><span class="title">其他</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/CS-Note/设计模式.html" class="nav-link">
  设计模式
</a></li><li class="dropdown-item"><!----> <a href="/CS-Note/系统设计.html" class="nav-link">
  系统设计
</a></li><li class="dropdown-item"><!----> <a href="/CS-Note/Linux.html" class="nav-link">
  Linux
</a></li><li class="dropdown-item"><!----> <a href="/CS-Note/Git.html" class="nav-link">
  Git
</a></li><li class="dropdown-item"><!----> <a href="/CS-Note/信息doc安全.html" class="nav-link">
  信息安全
</a></li><li class="dropdown-item"><!----> <a href="/CS-Note/编码.html" class="nav-link">
  编码
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="项目" class="dropdown-title"><span class="title">项目</span> <span class="arrow down"></span></button> <button type="button" aria-label="项目" class="mobile-dropdown-title"><span class="title">项目</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/CS-Note/高性能数字货币交易系统.html" class="nav-link">
  高性能数字货币交易系统
</a></li><li class="dropdown-item"><!----> <a href="/CS-Note/手写Spring.html" class="nav-link">
  手写Spring
</a></li></ul></div></div> <a href="https://github.com/caisense/CS-Note" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span></span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/CS-Note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#进程和线程区别" class="sidebar-link">进程和线程区别？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/CS-Note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#父进程和子进程的关系" class="sidebar-link">父进程和子进程的关系</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/CS-Note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#io模型" class="sidebar-link">IO模型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/CS-Note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#阻塞式-io" class="sidebar-link">阻塞式 IO</a></li><li class="sidebar-sub-header"><a href="/CS-Note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#非阻塞式-io-nio" class="sidebar-link">非阻塞式 IO（NIO）</a></li><li class="sidebar-sub-header"><a href="/CS-Note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#i-o-复用" class="sidebar-link">I/O 复用</a></li><li class="sidebar-sub-header"><a href="/CS-Note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#信号驱动-i-o" class="sidebar-link">信号驱动 I/O</a></li><li class="sidebar-sub-header"><a href="/CS-Note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#异步-i-o" class="sidebar-link">异步 I/O</a></li><li class="sidebar-sub-header"><a href="/CS-Note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#五大-i-o-模型比较" class="sidebar-link">五大 I/O 模型比较</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/CS-Note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#阻塞式io到非阻塞式io的演进" class="sidebar-link">阻塞式IO到非阻塞式IO的演进</a></li></ul></li></ul></li><li><a href="/CS-Note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#io多路复用" class="sidebar-link">IO多路复用</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/CS-Note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#三者比较" class="sidebar-link">三者比较</a></li><li class="sidebar-sub-header"><a href="/CS-Note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#select" class="sidebar-link">select</a></li><li class="sidebar-sub-header"><a href="/CS-Note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#poll" class="sidebar-link">poll</a></li><li class="sidebar-sub-header"><a href="/CS-Note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#epoll" class="sidebar-link">epoll</a></li><li class="sidebar-sub-header"><a href="/CS-Note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#q-多路复用比阻塞io快的原因" class="sidebar-link">Q：多路复用比阻塞IO快的原因？</a></li><li class="sidebar-sub-header"><a href="/CS-Note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#q-epoll的两种模式是" class="sidebar-link">Q：epoll的两种模式是？</a></li><li class="sidebar-sub-header"><a href="/CS-Note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#应用场景" class="sidebar-link">应用场景</a></li></ul></li><li><a href="/CS-Note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#swap交换分区" class="sidebar-link">Swap交换分区</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/CS-Note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#程序编译" class="sidebar-link">程序编译</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/CS-Note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#amdahl定律" class="sidebar-link">Amdahl定律</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p>操作系统</p> <h1 id="进程和线程区别"><a href="#进程和线程区别" class="header-anchor">#</a> 进程和线程区别？</h1> <table><thead><tr><th></th> <th>进程</th> <th>线程</th></tr></thead> <tbody><tr><td>概念</td> <td>运行时的程序</td> <td>是进程的子任务</td></tr> <tr><td>从属关系</td> <td>一个进程可以有多个线程</td> <td>一个线程只属于一个进程</td></tr> <tr><td>调度粒度</td> <td>是操作系统调度的最小单位</td> <td>是CPU调度的最小单位</td></tr> <tr><td>内存</td> <td>有独立内存单元，进程之间互不影响</td> <td>多个线程共享所在进程的内存，线程也有自己的内存空间</td></tr> <tr><td>切换开销</td> <td>大</td> <td>小</td></tr> <tr><td>通信</td> <td>共享内存、管道、信号量、套接字socket</td> <td>1. 共享内存（临界区）; 2. 事件（信号），如java的wait() notify()；3. 互斥量，如Synchronized、Lock</td></tr></tbody></table> <h1 id="父进程和子进程的关系"><a href="#父进程和子进程的关系" class="header-anchor">#</a> 父进程和子进程的关系</h1> <p>fork()会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，Linux中引入了写时复制（COW）技术，也就是只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。在fork之后exec之前两个进程用的是相同的物理空间（内存区），子进程的代码段、数据段、堆栈都是指向父进程的物理空间，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间，如果不是因为exec，内核会给子进程的数据段、堆栈段分配相应的物理空间（至此两者有各自的进程空间，互不影响），而代码段继续共享父进程的物理空间（两者的代码完全相同）。而如果是因为exec，由于两者执行的代码不同，子进程的代码段也会分配单独的物理空间。</p> <h1 id="io模型"><a href="#io模型" class="header-anchor">#</a> IO模型</h1> <p>一个输入操作通常包括两个阶段：</p> <ul><li>等待数据准备好</li> <li>从内核向进程复制数据</li></ul> <p>对于一个套接字上的输入操作，第一步通常涉及等待数据从网络上到达本系统，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。</p> <p>Unix 有五种 I/O 模型：</p> <ul><li>阻塞式 I/O（BIO，Blocking I/O）</li> <li>非阻塞式 I/O（NIO，Non-blocking I/O），jdk1.4：<code>java.nio</code>包。</li> <li>I/O 复用</li> <li>信号驱动式 I/O（SIGIO）</li> <li>异步 I/O（AIO，Asynchronous I/O），jdk1.7：<code>java.nio.channels.AsynchronousSocketChannel</code>等</li></ul> <blockquote><p><strong>阻塞/非阻塞</strong>关注的是程序在等待调用结果（消息，返回值）时的状态：</p> <ul><li>阻塞：调用结果返回之前，当前线程被挂起，直到结果返回才继续执行。</li> <li>非阻塞：无论调用结果是否返回，都不影响当前线程继续执行。</li></ul> <p><strong>同步/异步</strong>关注的是消息通信机制：</p> <ul><li>同步：方法A调用方法B，没得到B的结果之前， A不返回，一直等待B的结果到来A才返回。</li> <li>异步：方法A调用方法B之后，就直接返回了，不需要等待B的结果（B有结果后回调通知A）。</li></ul></blockquote> <p>举个例子，中午吃饭：</p> <ul><li>自选餐线，我们点餐的时候都得在队伍里排队等待，必须等待前面的同学打好菜才到我们，这就是同步阻塞模型BIO。</li> <li>煮面餐线，会给我们发个号牌，不需排队原地等待，可以做其他事情，面煮好之后凭号来拿，这就是同步非阻塞NIO。</li> <li>包厢模式，我们只要点好菜，坐在包厢可以自己玩，等到饭做好，服务员亲自送，无需自己取，这就是信号驱动SIGIO。</li> <li>包厢模式，点菜之后，等着服务员<strong>直接塞肚子里</strong>，这就是异步非阻塞模型AIO。</li></ul> <h2 id="阻塞式-io"><a href="#阻塞式-io" class="header-anchor">#</a> 阻塞式 IO</h2> <p>应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。</p> <p>应该注意到，在阻塞的过程中，其它应用进程还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其它应用进程还可以执行，所以不消耗 CPU 时间，这种模型的 CPU 利用率会比较高。</p> <p>下图中，recvfrom() 用于接收 Socket 传来的数据，并复制到应用进程的缓冲区 buf 中。这里把 recvfrom() 当成<strong>系统调用</strong>。</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token class-name">ssize_t</span> <span class="token function">recvfrom</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> len<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span>src_addr<span class="token punctuation">,</span> <span class="token class-name">socklen_t</span> <span class="token operator">*</span>addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><img src="images/操作系统/1492928416812_4.png" alt="img"> <h2 id="非阻塞式-io-nio"><a href="#非阻塞式-io-nio" class="header-anchor">#</a> 非阻塞式 IO（NIO）</h2> <p>应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询（polling）。</p> <p>由于 CPU 要处理更多的系统调用，因此这种模型的 CPU 利用率比较低。</p> <img src="images/操作系统/1492929000361_5.png" alt="img"> <h2 id="i-o-复用"><a href="#i-o-复用" class="header-anchor">#</a> I/O 复用</h2> <p>使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中。</p> <p>它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即<strong>事件驱动 I/O</strong>。</p> <p>如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统<strong>开销更小</strong>。</p> <img src="images/操作系统/1492929444818_6.png" alt="img"> <h2 id="信号驱动-i-o"><a href="#信号驱动-i-o" class="header-anchor">#</a> 信号驱动 I/O</h2> <p>应用进程使用 <strong>sigaction</strong> 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。</p> <p>相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。</p> <img src="images/操作系统/1492929553651_7.png" alt="img"> <h2 id="异步-i-o"><a href="#异步-i-o" class="header-anchor">#</a> 异步 I/O</h2> <p>应用进程执行 <strong>aio_read</strong> 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。</p> <p>异步 I/O 与信号驱动 I/O 的区别：异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。</p> <img src="images/操作系统/1492930243286_8.png" alt="img"> <h2 id="五大-i-o-模型比较"><a href="#五大-i-o-模型比较" class="header-anchor">#</a> 五大 I/O 模型比较</h2> <ul><li>同步 I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段（第二阶段），应用进程会阻塞。包括阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O</li> <li>异步 I/O：第二阶段应用进程不会阻塞。</li></ul> <p>在第一阶段不会阻塞的：非阻塞式 I/O 、信号驱动 I/O 和异步 I/O 。</p> <p>全程无阻塞的：异步IO。</p> <img src="images/操作系统/1492928105791_3.png" alt="img"> <h3 id="阻塞式io到非阻塞式io的演进"><a href="#阻塞式io到非阻塞式io的演进" class="header-anchor">#</a> 阻塞式IO到非阻塞式IO的演进</h3> <p>服务端为了处理客户端的连接和请求的数据，写了如下伪代码。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>listenfd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 打开一个网络通信端口（fd）*</span>
<span class="token function">bind</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 绑定</span>
<span class="token function">listen</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 监听</span>
<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    connfd <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 阻塞建立连接</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>connfd<span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 阻塞读数据</span>
    <span class="token function">doSomeThing</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 利用读到的数据做些什么</span>
    <span class="token function">close</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 关闭连接，循环等待下一个连接</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><blockquote><p>*注：<strong>文件描述符</strong>（file descriptor，后文简称<strong>fd</strong>）是一个索引值，指向一个文件记录表，该表记录内核为每一个进程维护的文件信息。</p> <p><strong>Linux中，一切皆文件</strong>。因此一个socket（即tcp连接）也是一个文件，对应一个fd。</p></blockquote> <p>这段代码与客户端的交互流程：</p> <img src="images/操作系统/阻塞io.gif" alt="未命名图片" style="zoom:67%;"> <p>可以看到，服务端的线程阻塞在了两个地方，一个是 accept 函数，一个是 read 函数。</p> <p>如果再把 read 函数的细节展开，我们会发现其阻塞在<strong>网卡--内核缓冲区</strong>、<strong>内核缓冲区--用户缓冲区buf</strong> 两个阶段</p> <img src="images/操作系统/read.png" alt="图片" style="zoom:67%;"> <p>所以，如果这个连接的客户端一直不发数据，那么服务端线程将会一直阻塞在 read 函数上不返回，也无法接受其他客户端连接。</p> <p>为了解决上面的问题，其关键在于改造这个 read 函数。</p> <p>一种办法是每次都创建一个新的进程或线程，去调用 read 函数，并做业务处理。这样，当给一个客户端建立好连接后，就可以立刻等待新的客户端连接，而不用阻塞在原客户端的 read 请求上：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    connfd <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 阻塞建立连接</span>
    <span class="token function">pthread_create</span><span class="token punctuation">(</span>doWork<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 创建一个新的线程</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>connfd<span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 阻塞读数据</span>
    <span class="token function">doSomeThing</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 利用读到的数据做些什么</span>
    <span class="token function">close</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 关闭连接，循环等待下一个连接</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>这样本质上并不是非阻塞IO，只是开多线程而已，线程各自调用read还是阻塞的。而且线程太多会耗尽服务器资源。</p> <p>真正的非阻塞IO是<strong>操作系统层面提供非阻塞read函数</strong>。该read函数要在没有数据到达时（拷贝到了内核缓冲区），立刻返回一个错误值（-1），而不是阻塞地等待。</p> <p>操作系统提供了这样的功能，只需要在调用 read 前，将fd设置为非阻塞即可：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token function">fcntl</span><span class="token punctuation">(</span>connfd<span class="token punctuation">,</span> F_SETFL<span class="token punctuation">,</span> O_NONBLOCK<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 设置非阻塞</span>
<span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>connfd<span class="token punctuation">,</span> buffer<span class="token punctuation">)</span> <span class="token operator">!=</span> SUCCESS<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>非阻塞的 read，指的是在数据到达前（即数据还未到达网卡，或者到达网卡但还没有拷贝到内核缓冲区之前）这个阶段是非阻塞的。</p> <p>当数据已到达内核缓冲区，此时调用 read 函数仍然是阻塞的，需要等待数据从内核缓冲区拷贝到用户缓冲区，才能返回。</p> <p>整体流程：</p> <img src="images/操作系统/640-1694017231081-6.png" alt="图片" style="zoom:80%;"> <h1 id="io多路复用"><a href="#io多路复用" class="header-anchor">#</a> IO多路复用</h1> <blockquote><p>I/O multiplexing，翻译成IO多路复用有歧义，其实并不是多路IO复用一个物理链路，而是：<strong>多个IO复用一次系统调用</strong>，通过记录跟踪每个I/O流(sock)的状态，由单个线程来同时管理多个I/O流 。</p> <p>IO多路复用是相对于阻塞IO而言的，单个线程调用操作系统的阻塞IO就会挂起，无法处理多个IO（fd）</p></blockquote> <p>select, poll, 和 epoll 都是 Linux 中常见的 I/O 多路复用技术，它们可以用于同时监听多个<strong>文件描述符</strong>（file descriptor，后文简称fd），当任意一个fd<strong>就绪</strong>时，就能够非阻塞的读写数据。</p> <ul><li>select 是最原始的 I/O 多路复用技术，它的缺点是最多只能监听 1024 个文件描述符。</li> <li>poll 在 select 的基础上，取消了监听文件描述符个数的限制，但是复杂度增加，并且线程不安全。</li> <li>epoll 在 poll 的基础上进一步优化了复杂度，并且<strong>线程安全</strong>。</li></ul> <h2 id="三者比较"><a href="#三者比较" class="header-anchor">#</a> 三者比较</h2> <table><thead><tr><th></th> <th>select</th> <th>poll</th> <th>epoll</th></tr></thead> <tbody><tr><td>fd长度（个数）</td> <td>1024</td> <td>无限制*</td> <td>无限制*</td></tr> <tr><td>遍历所有fd</td> <td>是</td> <td>是</td> <td>否</td></tr> <tr><td>把fd从用户态copy到内核态</td> <td>是</td> <td>是</td> <td>否</td></tr></tbody></table> <p>*注：上限是系统可以打开的最大文件数，远大于1024，具体可以用命令<code>cat /proc/sys/fs/file-max</code>查看。在1GB内存的机器上，大于10万。</p> <h2 id="select"><a href="#select" class="header-anchor">#</a> select</h2> <blockquote><p>接前面 <a href="####%E9%98%BB%E5%A1%9E%E5%BC%8FIO%E5%88%B0%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%8FIO%E7%9A%84%E6%BC%94%E8%BF%9B">阻塞式IO到非阻塞式IO的演进</a>  的思路，可以每 accept 一个客户端连接后，将这个文件描述符（connfd）放到一个数组里。然后起一个新的线程一直循环这个数组，调用每一个元素的非阻塞 read 方法，这样就能用<strong>一个线程处理多个客户端连接</strong>。</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code>fdlist<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">for</span><span class="token punctuation">(</span>fd <span class="token operator">&lt;</span><span class="token operator">--</span> fdlist<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">doSomeThing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>但每次遍历遇到 read 返回 -1 时仍然是一次浪费资源的系统调用。在 while 循环里做系统调用是不划算的，每次调用都有开销，合理的做法是一次系统调用，在调用中while循环。</p> <p>这就引出了select。</p></blockquote> <p>select是操作系统提供的系统调用函数，传入一个<strong>fd数组</strong>发给操作系统， 让操作系统去遍历，确定哪个fd可以读写（顾名思义，select 【选择】就绪的fd）。方法定义如下，可以监听read、write、except（异常）类型的fd：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">// 返回&gt;0为就绪的fd数；返回-1为出错；返回0为超时</span>
<span class="token keyword">int</span> <span class="token function">select</span><span class="token punctuation">(</span>
    <span class="token keyword">int</span> nfds<span class="token punctuation">,</span>  <span class="token comment">// nfds:监控的文件描述符集里最大文件描述符加1</span>
    fd_set <span class="token operator">*</span>readfds<span class="token punctuation">,</span>  <span class="token comment">// readfds：监控有读数据到达文件描述符集合，指针</span>
    fd_set <span class="token operator">*</span>writefds<span class="token punctuation">,</span>  <span class="token comment">// writefds：监控写数据到达文件描述符集合，指针</span>
    fd_set <span class="token operator">*</span>exceptfds<span class="token punctuation">,</span>  <span class="token comment">// exceptfds：监控异常发生达文件描述符集合, 指针</span>
    <span class="token keyword">struct</span> <span class="token class-name">timeval</span> <span class="token operator">*</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// timeout：定时阻塞监控时间，3种情况：1.NULL，永远等下去 2.设置timeval，等待固定时间                                                                // 3.设置timeval里时间均为0，检查描述字后立即返回，轮询</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>服务端代码示例：</p> <p>一个线程不断接受客户端连接，并把 socket 文件描述符放到一个 list 里。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    connfd <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">fcntl</span><span class="token punctuation">(</span>connfd<span class="token punctuation">,</span> <span class="token constant">F_SETFL</span><span class="token punctuation">,</span> <span class="token constant">O_NONBLOCK</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    fdlist<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>另一个线程不再自己遍历，而是调用 select，将这个fd 数组交给操作系统去遍历。</p> <p>不过，当 select 函数返回后，用户依然需要遍历刚刚提交给操作系统的 list，但是<strong>少了很多无效的系统调用</strong></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    nready <span class="token operator">=</span> <span class="token function">select</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 传入一个fd list，返回已就绪fd的个数</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>fd <span class="token operator">&lt;</span><span class="token operator">--</span> fdlist<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 用户层依然要遍历</span>
        <span class="token comment">// 只读已就绪的fd</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>fd <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 总共只有 nready 个已就绪fd，不用过多遍历</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">--</span>nready <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>总结：</p> <ol><li>select 调用需要传入 fd 数组，需要拷贝一份到内核，高并发场景下这样的拷贝消耗的资源是惊人的。（可优化为不复制）</li> <li>select 在内核层仍然是通过遍历的方式检查fd的就绪状态，是个同步的过程，也是<strong>阻塞</strong>的，只不过无系统调用切换上下文的开销。（内核层可优化为异步事件通知）</li> <li>select 仅仅返回可读文件描述符的个数，具体哪个可读还是要用户自己遍历。（可优化为只返回给用户就绪的文件描述符，无需用户做无效的遍历）</li></ol> <p>select 的流程图：</p> <img src="images/操作系统/640-1694014902940-3.png" alt="图片" style="zoom:80%;"> <h2 id="poll"><a href="#poll" class="header-anchor">#</a> poll</h2> <p>也是操作系统提供的函数，用法是调用poll返回后，轮询fd列表获取就绪的fd。</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">poll</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pollfd</span> <span class="token operator">*</span>fds<span class="token punctuation">,</span> nfds_tnfds<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">pollfd</span> <span class="token punctuation">{</span>
    intfd<span class="token punctuation">;</span> <span class="token comment">/*文件描述符*/</span>
    shortevents<span class="token punctuation">;</span> <span class="token comment">/*监控的事件*/</span>
    shortrevents<span class="token punctuation">;</span> <span class="token comment">/*监控事件中满足条件返回的事件*/</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><strong>select 和 poll 的比较</strong></p> <ul><li>poll对select的改进：取消了监听<strong>1024个fd</strong>的限制（poll的fds基于链表，select的fd列表是数组）。</li> <li>select 会<strong>修改描述符</strong>，而 poll 不会；</li> <li>poll 提供了更多的事件类型，并且对fd的重复利用上比 select 高。</li> <li>线程不安全：如果一个线程对某个fd调用了 select 或者 poll，另一个线程关闭了该fd，会导致调用结果不确定。</li> <li>速度：都很慢，因为拷贝fd还是要在内核态和用户态之间切换。</li> <li>可移植性：几乎所有的系统都支持 select，但是只有比较新的系统支持 poll。</li></ul> <h2 id="epoll"><a href="#epoll" class="header-anchor">#</a> epoll</h2> <p>针对上面select总结的三点进行了改进：</p> <ol><li>拷贝一份 fd 集合到内核（用<strong>红黑树</strong>存储），无需用户每次都重新传入，只需告诉内核修改的部分即可。</li> <li>内核不再通过轮询的方式找到就绪的 fd ，而是通过<strong>异步 IO 事件</strong>唤醒，也避免 fd 再从内核拷贝到用户的开销。</li> <li>内核仅会将有 IO 事件的 fd 返回给用户，用户也无需遍历整个 fd 集合。</li></ol> <p>使用示例：</p> <ol><li><p>创建一个 epoll 句柄，size告诉内核监听的fd数量：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">epoll_create</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><p>向内核注册新的fd或改变某个fd的状态，以此监控fd。该方法将传入fd拷贝到内核，而不是在epoll_wait方法中重复拷贝，保证epoll只拷贝一次。所有fd在内核中用<strong>红黑树</strong>维护。通过异步回调将就绪的fd放入链表，进程调用 <code>epoll_wait()</code> 便可以得到事件完成的fd。</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">epoll_ctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">int</span> op<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token operator">*</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><p>类似于 select ，调用<code>epoll_wait</code>返回就绪状态的fd，若有则直接使用，而不像poll和select需要遍历</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">epoll_wait</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token operator">*</span>events<span class="token punctuation">,</span> <span class="token keyword">int</span> max events<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ol> <p>总之，epoll 只需要将fd从进程缓冲区向内核缓冲区拷贝一次，并且进程不需要通过轮询来获得就绪的fd。</p> <p>流程图：</p> <p><img src="images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/v2-8a58e70c01e31c15d6f58f9d68b59906_720w.png" alt="img"></p> <ul><li>epoll 仅适用于 Linux。</li> <li>epoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也不会产生像 select 和 poll 的不确定情况。</li></ul> <h2 id="q-多路复用比阻塞io快的原因"><a href="#q-多路复用比阻塞io快的原因" class="header-anchor">#</a> Q：多路复用比阻塞IO快的原因？</h2> <p>错误：用一个线程就可以监控多个文件描述符。（这样的效果，完全可以由用户态去遍历文件描述符并调用其非阻塞的 read 函数实现）</p> <p>正确：操作系统提供了这样的系统调用，使得原来的 while 循环里多次系统调用，变成了一次系统调用 + 内核层 while 循环遍历这些文件描述符。（就好比我们平时写业务代码，把原来 while 循环里调 http 接口进行批量，改成了让对方提供一个批量添加的 http 接口，然后我们一次 rpc 请求就完成了批量添加。）</p> <h2 id="q-epoll的两种模式是"><a href="#q-epoll的两种模式是" class="header-anchor">#</a> Q：epoll的两种模式是？</h2> <p>我们知道epoll是通过epoll_wait来获取就绪的fd，那么如果就绪的fd一直没有被消费，该如何处理呢？这就有了两种模式。LT（level trigger）和ET（edge trigger）：</p> <ul><li>LT模式（<strong>默认模式</strong>）：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。支持阻塞和非阻塞。</li> <li>ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须<strong>立即处理</strong>该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。只支持非阻塞。</li></ul> <p>因为ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞socket，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p> <h2 id="应用场景"><a href="#应用场景" class="header-anchor">#</a> 应用场景</h2> <p>很容易产生一种错觉认为只要用 epoll 就可以了，select 和 poll 都已经过时了，其实它们都有各自的使用场景。</p> <ol><li><p>select 应用场景
select 的 timeout 参数精度为微秒，而 poll 和 epoll 为毫秒，因此 select 更加适用于<strong>实时性</strong>要求比较高的场景，比如核反应堆的控制。select 可移植性更好，几乎被所有主流平台所支持。</p></li> <li><p>poll 应用场景
poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。</p></li> <li><p>epoll 应用场景
只需要运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接。</p> <p>需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。</p> <p>需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll。因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且 epoll 的描述符存储在内核，不容易调试。</p></li></ol> <h1 id="swap交换分区"><a href="#swap交换分区" class="header-anchor">#</a> Swap交换分区</h1> <p>Linux中的一个区域，类似于Windows的虚拟内存，当内存不足时，把一部分硬盘空间虚拟成内存，解决内存容量不足的问题。</p> <p>合理取值一般是<strong>内存的2倍</strong></p> <h1 id="程序编译"><a href="#程序编译" class="header-anchor">#</a> 程序编译</h1> <ul><li><p>程序功能的实现通常可以分为两个阶段：</p></li> <li><p>静态处理阶段（static），在程序本身开始执行前的处理。通常包括：</p></li> <li><ul><li>翻译阶段（编译）：对源程序做各种检查（语法检查，类型检查等）和变换，将其转变为某种适宜动态执行的形式</li> <li>连接阶段（可能）：构造出可动态运行的程序形式</li> <li>装载阶段（可能）：把可运行程序装入运行环境，必要的处理</li></ul></li> <li><p>动态执行阶段（run-time），指程序的实际运行期间</p></li> <li><p>例：若变量x 的（绝对或相对）位置可静态确定，运行中就可以直接访问。若不能静态确定，运行中每次访问都要查表，效率就比较低</p></li> <li><p>语言的“编译实现”：在静态阶段完成尽可能多的处理工作，对源程序做深入的分析和变换，生成的目标形式通常与源程序差异巨大</p></li></ul> <h1 id="amdahl定律"><a href="#amdahl定律" class="header-anchor">#</a> Amdahl定律</h1> <p>加快某部件执行速度所获得的系统性能加速比，受限于该部件在系统中所占的比例。</p> <p>Amdahl定律既可以用来确定系统中对性能限制最大的部件，也可以用来计算通过改进某些部件所获得的系统性能的提高。</p> <ul><li>Amdahl定律：加快某部件执行速度所获得的系统性能加速比，受限于该部件在系统中所占的比例。</li> <li>Amdahl定律既可以用来确定系统中对性能限制最大的部件，也可以用来计算通过改进某些部件所获得的系统性能的提高。</li></ul> <img src="images/操作系统/未命名图片.jpg" alt="未命名图片" style="zoom:50%;"> <img src="images/操作系统/1png.jpg" alt="1png" style="zoom:33%;"></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">9/18/2023, 1:45:58 AM</span></div></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/CS-Note/assets/js/app.499d959b.js" defer></script><script src="/CS-Note/assets/js/2.3a0ab2ea.js" defer></script><script src="/CS-Note/assets/js/1.2a19e319.js" defer></script><script src="/CS-Note/assets/js/43.9cf3acc6.js" defer></script>
  </body>
</html>
